<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Creator</title>
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Html2Canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div id="root"></div>

  <!-- GIF Instructions Modal -->
  <div id="gif-instructions-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h3>ğŸ“¹ High Quality GIF Capture (v2)</h3>
      </div>
      <div class="modal-body">
        <p>To get a perfect result, we need to capture the screen:</p>
        <div class="steps-list">
          <div class="step-item">
            <span class="step-number">1</span>
            <div id="gif-modal-step-1" class="step-text">Select the <strong>"Chrome Tab"</strong> tab.</div>
          </div>
          <div class="step-item">
            <span class="step-number">2</span>
            <div id="gif-modal-step-2" class="step-text">Choose <strong>this page</strong> from the list.</div>
          </div>
          <div class="step-item">
            <span class="step-number">3</span>
            <div id="gif-modal-step-3" class="step-text">Click <strong>"Share"</strong>.</div>
          </div>
        </div>
        <div class="modal-note">
          <span class="note-icon">ğŸ’¡</span>
          <span>The mouse will be automatically hidden and the card cropped.</span>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancel-gif-btn" class="secondary-btn">Cancel</button>
        <button id="start-gif-btn" class="primary-btn">Start Capture</button>
      </div>
    </div>
  </div>

  <script type="text/babel">

    const { useState, useRef, useMemo, useCallback, useEffect, createContext, useContext } = React;
    const LANGUAGES = {
      en: { name: 'English', flag: 'ğŸ‡¬ğŸ‡§' }, fr: { name: 'FranÃ§ais', flag: 'ğŸ‡«ğŸ‡·' }, es: { name: 'EspaÃ±ol', flag: 'ğŸ‡ªğŸ‡¸' }, de: { name: 'Deutsch', flag: 'ğŸ‡©ğŸ‡ª' }, ru: { name: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹', flag: 'ğŸ‡·ğŸ‡º' }, ja: { name: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ' }, zh: { name: 'ä¸­æ–‡', flag: 'ğŸ‡¨ğŸ‡³' },
    };
    const TRANSLATIONS = {
      en: {
        gifModal: {
          title: "ğŸ“¹ High Quality GIF Capture",
          body: "To get a perfect result, we need to capture the screen:",
          step1: "Select the <strong>\"Tab\"</strong> option.",
          step2: "Choose <strong>this page</strong> from the list.",
          step3: "Click <strong>\"Share\"</strong>.",
          note: "The mouse will be automatically hidden and the card cropped.",
          cancel: "Cancel",
          start: "Start Capture"
        },
        appTitle: 'Card Creator', appSubtitle: 'Create your own personalized collectible cards', hoverHint: 'âœ¨ Hover over the card to intensify the effect âœ¨', elements: { Fire: 'Fire', Water: 'Water', Nature: 'Nature', Electric: 'Electric', Mystic: 'Mystic', Fighting: 'Fighting', Shadow: 'Shadow', Metal: 'Metal', Light: 'Light', Dragon: 'Dragon', Ice: 'Ice', Neutral: 'Neutral' }, effects: { none: { name: 'None', description: 'No effect' }, holographic: { name: 'Holographic', description: 'Classic rainbow effect' }, rainbow: { name: 'Rainbow', description: 'Animated multicolor gradient' }, gold: { name: 'Gold', description: 'Luxurious golden reflections' }, silver: { name: 'Silver', description: 'Metallic silver reflections' }, prismatic: { name: 'Prismatic', description: 'Refracting crystal effect' }, neon: { name: 'Neon', description: 'Vibrant neon glow' }, galaxy: { name: 'Galaxy', description: 'Starry cosmic effect' }, fire: { name: 'Flames', description: 'Animated flame effect' }, ice: { name: 'Frost', description: 'Sparkling ice effect' } }, stages: ['Base', 'Stage 1', 'Stage 2', 'Special', 'Legendary', 'Mythic', 'Ultra'], rarities: { common: 'Common', uncommon: 'Uncommon', rare: 'Rare', epic: 'Epic', legendary: 'Legendary', mythic: 'Mythic' }, sections: { image: 'Image', basicInfo: 'Basic Information', rarityEffects: 'Rarity & Effects', abilities: 'Abilities', stats: 'Statistics', appearance: 'Appearance' }, labels: { name: 'Name', hp: 'Hit Points', element: 'Element', stage: 'Stage', description: 'Description', author: 'Author', rarity: 'Rarity', effect: 'Effect', weakness: 'Weakness', resistance: 'Resistance', retreatCost: 'Retreat Cost', abilityName: 'Ability Name', damage: 'Damage', energyCost: 'Energy Cost', abilityDesc: 'Description', borderColor: 'Border Color', backgroundColor: 'Background Color', textColor: 'Text Color', font: 'Font', zoom: 'Zoom' }, buttons: { addAbility: '+ Add Ability', remove: 'Remove', change: 'Change', recenter: 'Recenter', download: 'Download', autoRotate: '3D Preview' }, checkboxes: { showHP: 'Show hit points', showWeakRes: 'Show weakness/resistance', showRetreat: 'Show retreat cost', showDescription: 'Show description', showTexture: 'Show texture pattern', showParticles: 'Show particles', showDamage: 'Show damage' }, imageEditor: { dropHint: 'Drag & drop an image here', orClick: 'or click to select', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Loading...', unsupportedFormat: 'Unsupported format. Use PNG,JPG,GIF or WEBP.', fileTooLarge: 'File too large. Maximum 15MB.' }, download: { title: 'ğŸ“¥ Download', pngTitle: 'Transparent PNG image', jpgTitle: 'JPG image with background', gifTitle: 'Animated GIF (3 seconds)', htmlTitle: 'Interactive HTML file', capturing: 'â³ Capturing...', encoding: 'âš™ï¸ Encoding...' }, card: { hp: 'HP', weakness: 'Weakness', resistance: 'Resistance', cost: 'Cost', illus: 'Illus.' }, defaults: { newAbility: 'New Ability' }, display: { title: 'Display Options' }, tabs: { info: 'Info', combat: 'Combat', visual: 'Visual' }
      },
      fr: {
        gifModal: {
          title: "ğŸ“¹ Capture GIF Haute QualitÃ©",
          body: "Pour obtenir un rÃ©sultat parfait, nous devons capturer l'Ã©cran :",
          step1: "SÃ©lectionnez l'option <strong>\"Onglet\"</strong>.",
          step2: "Choisissez <strong>cette page</strong> dans la liste.",
          step3: "Cliquez sur <strong>\"Partager\"</strong>.",
          note: "La souris sera automatiquement masquÃ©e et la carte recadrÃ©e.",
          cancel: "Annuler",
          start: "Lancer la capture"
        },
        appTitle: 'Card Creator', appSubtitle: 'CrÃ©ez vos propres cartes Ã  collectionner personnalisÃ©es', hoverHint: 'âœ¨ Survolez la carte pour intensifier l\'effet âœ¨', elements: { Fire: 'Feu', Water: 'Eau', Nature: 'Nature', Electric: 'Ã‰lectrique', Mystic: 'Mystique', Fighting: 'Combat', Shadow: 'Ombre', Metal: 'MÃ©tal', Light: 'LumiÃ¨re', Dragon: 'Dragon', Ice: 'Glace', Neutral: 'Neutre' }, effects: { none: { name: 'Aucun', description: 'Pas d\'effet' }, holographic: { name: 'Holographique', description: 'Effet arc-en-ciel classique' }, rainbow: { name: 'Arc-en-ciel', description: 'DÃ©gradÃ© multicolore animÃ©' }, gold: { name: 'DorÃ©', description: 'Reflets dorÃ©s luxueux' }, silver: { name: 'ArgentÃ©', description: 'Reflets argentÃ©s mÃ©talliques' }, prismatic: { name: 'Prismatique', description: 'Effet cristal rÃ©fractant' }, neon: { name: 'NÃ©on', description: 'Lueur nÃ©on vibrante' }, galaxy: { name: 'Galaxie', description: 'Effet cosmique Ã©toilÃ©' }, fire: { name: 'Flammes', description: 'Effet de flammes animÃ©es' }, ice: { name: 'GivrÃ©', description: 'Effet de glace scintillante' } }, stages: ['Base', 'Ã‰volution 1', 'Ã‰volution 2', 'SpÃ©cial', 'LÃ©gendaire', 'Mythique', 'Ultra'], rarities: { common: 'Commune', uncommon: 'Peu commune', rare: 'Rare', epic: 'Ã‰pique', legendary: 'LÃ©gendaire', mythic: 'Mythique' }, sections: { image: 'Image', basicInfo: 'Informations de base', rarityEffects: 'RaretÃ© & Effets', abilities: 'CapacitÃ©s', stats: 'Statistiques', appearance: 'Apparence' }, labels: { name: 'Nom', hp: 'Points de vie', element: 'Ã‰lÃ©ment', stage: 'Stade', description: 'Description', author: 'Auteur', rarity: 'RaretÃ©', effect: 'Effet', weakness: 'Faiblesse', resistance: 'RÃ©sistance', retreatCost: 'CoÃ»t de retraite', abilityName: 'Nom de la capacitÃ©', damage: 'DÃ©gÃ¢ts', energyCost: 'CoÃ»t en Ã©nergie', abilityDesc: 'Description', borderColor: 'Couleur de bordure', backgroundColor: 'Couleur de fond', textColor: 'Couleur du texte', font: 'Police', zoom: 'Zoom' }, buttons: { addAbility: '+ Ajouter une capacitÃ©', remove: 'Supprimer', change: 'Changer', recenter: 'Recentrer', download: 'TÃ©lÃ©charger', autoRotate: 'AperÃ§u 3D' }, checkboxes: { showHP: 'Afficher les points de vie', showWeakRes: 'Afficher faiblesse/rÃ©sistance', showRetreat: 'Afficher le coÃ»t de retraite', showDescription: 'Afficher la description', showTexture: 'Afficher le motif', showParticles: 'Afficher les particules', showDamage: 'Afficher les dÃ©gÃ¢ts' }, imageEditor: { dropHint: 'Glissez-dÃ©posez une image ici', orClick: 'ou cliquez pour sÃ©lectionner', formats: 'PNG,JPG,GIF,WEBP (max 15Mo)', loading: 'Chargement...', unsupportedFormat: 'Format non supportÃ©. Utilisez PNG,JPG,GIF ou WEBP.', fileTooLarge: 'Fichier trop volumineux. Maximum 15Mo.' }, download: { title: 'ğŸ“¥ TÃ©lÃ©charger', pngTitle: 'Image PNG transparente', jpgTitle: 'Image JPG avec fond', gifTitle: 'GIF animÃ© (3 secondes)', htmlTitle: 'Fichier HTML interactif', capturing: 'â³ Capture...', encoding: 'âš™ï¸ Encodage...' }, card: { hp: 'PV', weakness: 'Faiblesse', resistance: 'RÃ©sistance', cost: 'CoÃ»t', illus: 'Illus.' }, defaults: { newAbility: 'Nouvelle CapacitÃ©' }, display: { title: 'Options d\'affichage' }, tabs: { info: 'Infos', combat: 'Combat', visual: 'Visuel' }
      },
      es: {
        gifModal: {
          title: "ğŸ“¹ Captura GIF de Alta Calidad",
          body: "Para obtener un resultado perfecto, necesitamos capturar la pantalla:",
          step1: "Selecciona la opciÃ³n <strong>\"PestaÃ±a\"</strong>.",
          step2: "Elige <strong>esta pÃ¡gina</strong> de la lista.",
          step3: "Haz clic en <strong>\"Compartir\"</strong>.",
          note: "El ratÃ³n se ocultarÃ¡ automÃ¡ticamente y la carta se recortarÃ¡.",
          cancel: "Cancelar",
          start: "Iniciar Captura"
        },
        appTitle: 'Card Creator', appSubtitle: 'Crea tus propias cartas coleccionables personalizadas', hoverHint: 'âœ¨ Pasa el cursor sobre la carta para intensificar el efecto âœ¨', elements: { Fire: 'Fuego', Water: 'Agua', Nature: 'Naturaleza', Electric: 'ElÃ©ctrico', Mystic: 'MÃ­stico', Fighting: 'Lucha', Shadow: 'Sombra', Metal: 'Metal', Light: 'Luz', Dragon: 'DragÃ³n', Ice: 'Hielo', Neutral: 'Neutral' }, effects: { none: { name: 'Ninguno', description: 'Sin efecto' }, holographic: { name: 'HologrÃ¡fico', description: 'Efecto arcoÃ­ris clÃ¡sico' }, rainbow: { name: 'ArcoÃ­ris', description: 'Degradado multicolor animado' }, gold: { name: 'Dorado', description: 'Reflejos dorados lujosos' }, silver: { name: 'Plateado', description: 'Reflejos metÃ¡licos plateados' }, prismatic: { name: 'PrismÃ¡tico', description: 'Efecto cristal refractante' }, neon: { name: 'NeÃ³n', description: 'Brillo neÃ³n vibrante' }, galaxy: { name: 'Galaxia', description: 'Efecto cÃ³smico estrellado' }, fire: { name: 'Llamas', description: 'Efecto de llamas animadas' }, ice: { name: 'Escarcha', description: 'Efecto de hielo brillante' } }, stages: ['Base', 'Fase 1', 'Fase 2', 'Especial', 'Legendario', 'MÃ­tico', 'Ultra'], rarities: { common: 'ComÃºn', uncommon: 'Poco comÃºn', rare: 'Rara', epic: 'Ã‰pica', legendary: 'Legendaria', mythic: 'MÃ­tica' }, sections: { image: 'Imagen', basicInfo: 'InformaciÃ³n bÃ¡sica', rarityEffects: 'Rareza y Efectos', abilities: 'Habilidades', stats: 'EstadÃ­sticas', appearance: 'Apariencia' }, labels: { name: 'Nombre', hp: 'Puntos de vida', element: 'Elemento', stage: 'Fase', description: 'DescripciÃ³n', author: 'Autor', rarity: 'Rareza', effect: 'Efecto', weakness: 'Debilidad', resistance: 'Resistencia', retreatCost: 'Coste de retirada', abilityName: 'Nombre de habilidad', damage: 'DaÃ±o', energyCost: 'Coste de energÃ­a', abilityDesc: 'DescripciÃ³n', borderColor: 'Color del borde', backgroundColor: 'Color de fondo', textColor: 'Color del texto', font: 'Fuente', zoom: 'Zoom' }, buttons: { addAbility: '+ AÃ±adir habilidad', remove: 'Eliminar', change: 'Cambiar', recenter: 'Recentrar', download: 'Descargar', autoRotate: 'Vista previa 3D' }, checkboxes: { showHP: 'Mostrar puntos de vida', showWeakRes: 'Mostrar debilidad/resistencia', showRetreat: 'Mostrar coste de retirada', showDescription: 'Mostrar descripciÃ³n', showTexture: 'Mostrar patrÃ³n', showParticles: 'Mostrar partÃ­culas', showDamage: 'Mostrar daÃ±o' }, imageEditor: { dropHint: 'Arrastra y suelta una imagen aquÃ­', orClick: 'o haz clic para seleccionar', formats: 'PNG,JPG,GIF,WEBP (mÃ¡x 15MB)', loading: 'Cargando...', unsupportedFormat: 'Formato no soportado. Use PNG,JPG,GIF o WEBP.', fileTooLarge: 'Archivo demasiado grande. MÃ¡ximo 15MB.' }, download: { title: 'ğŸ“¥ Descargar', pngTitle: 'Imagen PNG transparente', jpgTitle: 'Imagen JPG con fondo', gifTitle: 'GIF animado (3 segundos)', htmlTitle: 'Archivo HTML interactivo', capturing: 'â³ Capturando...', encoding: 'âš™ï¸ Codificando...' }, card: { hp: 'PS', weakness: 'Debilidad', resistance: 'Resistencia', cost: 'Coste', illus: 'Illus.' }, defaults: { newAbility: 'Nueva Habilidad' }, display: { title: 'Opciones de visualizaciÃ³n' }, tabs: { info: 'Info', combat: 'Combate', visual: 'Visual' }
      },
      de: {
        gifModal: {
          title: "ğŸ“¹ Hochwertige GIF-Aufnahme",
          body: "FÃ¼r ein perfektes Ergebnis mÃ¼ssen wir den Bildschirm aufnehmen:",
          step1: "WÃ¤hlen Sie die Option <strong>\"Tab\"</strong>.",
          step2: "WÃ¤hlen Sie <strong>diese Seite</strong> aus der Liste.",
          step3: "Klicken Sie auf <strong>\"Teilen\"</strong>.",
          note: "Die Maus wird automatisch ausgeblendet und die Karte zugeschnitten.",
          cancel: "Abbrechen",
          start: "Aufnahme starten"
        },
        appTitle: 'Card Creator', appSubtitle: 'Erstellen Sie Ihre eigenen personalisierten Sammelkarten', hoverHint: 'âœ¨ Fahren Sie mit der Maus Ã¼ber die Karte,um den Effekt zu verstÃ¤rken âœ¨', elements: { Fire: 'Feuer', Water: 'Wasser', Nature: 'Natur', Electric: 'Elektro', Mystic: 'Mystik', Fighting: 'Kampf', Shadow: 'Schatten', Metal: 'Metall', Light: 'Licht', Dragon: 'Drache', Ice: 'Eis', Neutral: 'Neutral' }, effects: { none: { name: 'Keiner', description: 'Kein Effekt' }, holographic: { name: 'Holografisch', description: 'Klassischer Regenbogeneffekt' }, rainbow: { name: 'Regenbogen', description: 'Animierter mehrfarbiger Verlauf' }, gold: { name: 'Gold', description: 'LuxuriÃ¶se goldene Reflexionen' }, silver: { name: 'Silber', description: 'Metallische Silberreflexionen' }, prismatic: { name: 'Prismatisch', description: 'Brechender Kristalleffekt' }, neon: { name: 'Neon', description: 'Lebhaftes Neonleuchten' }, galaxy: { name: 'Galaxie', description: 'Sternenkosmischer Effekt' }, fire: { name: 'Flammen', description: 'Animierter Flammeneffekt' }, ice: { name: 'Frost', description: 'Funkelnder Eiseffekt' } }, stages: ['Basis', 'Phase 1', 'Phase 2', 'Spezial', 'LegendÃ¤r', 'Mythisch', 'Ultra'], rarities: { common: 'GewÃ¶hnlich', uncommon: 'UngewÃ¶hnlich', rare: 'Selten', epic: 'Episch', legendary: 'LegendÃ¤r', mythic: 'Mythisch' }, sections: { image: 'Bild', basicInfo: 'Grundinformationen', rarityEffects: 'Seltenheit & Effekte', abilities: 'FÃ¤higkeiten', stats: 'Statistiken', appearance: 'Aussehen' }, labels: { name: 'Name', hp: 'Lebenspunkte', element: 'Element', stage: 'Phase', description: 'Beschreibung', author: 'Autor', rarity: 'Seltenheit', effect: 'Effekt', weakness: 'SchwÃ¤che', resistance: 'Resistenz', retreatCost: 'RÃ¼ckzugskosten', abilityName: 'FÃ¤higkeitsname', damage: 'Schaden', energyCost: 'Energiekosten', abilityDesc: 'Beschreibung', borderColor: 'Rahmenfarbe', backgroundColor: 'Hintergrundfarbe', textColor: 'Textfarbe', font: 'Schriftart', zoom: 'Zoom' }, buttons: { addAbility: '+ FÃ¤higkeit hinzufÃ¼gen', remove: 'Entfernen', change: 'Ã„ndern', recenter: 'Zentrieren', download: 'Herunterladen', autoRotate: '3D-Vorschau' }, checkboxes: { showHP: 'Lebenspunkte anzeigen', showWeakRes: 'SchwÃ¤che/Resistenz anzeigen', showRetreat: 'RÃ¼ckzugskosten anzeigen', showDescription: 'Beschreibung anzeigen', showTexture: 'Muster anzeigen', showParticles: 'Partikel anzeigen', showDamage: 'Schaden anzeigen' }, imageEditor: { dropHint: 'Bild hier ablegen', orClick: 'oder klicken zum AuswÃ¤hlen', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Laden...', unsupportedFormat: 'Nicht unterstÃ¼tztes Format. Verwenden Sie PNG,JPG,GIF oder WEBP.', fileTooLarge: 'Datei zu groÃŸ. Maximal 15MB.' }, download: { title: 'ğŸ“¥ Herunterladen', pngTitle: 'Transparentes PNG-Bild', jpgTitle: 'JPG-Bild mit Hintergrund', gifTitle: 'Animiertes GIF (3 Sekunden)', htmlTitle: 'Interaktive HTML-Datei', capturing: 'â³ Aufnahme...', encoding: 'âš™ï¸ Kodierung...' }, card: { hp: 'KP', weakness: 'SchwÃ¤che', resistance: 'Resistenz', cost: 'Kosten', illus: 'Illus.' }, defaults: { newAbility: 'Neue FÃ¤higkeit' }, display: { title: 'Anzeigeoptionen' }, tabs: { info: 'Info', combat: 'Kampf', visual: 'Visuell' }
      },
      ru: {
        gifModal: {
          title: "ğŸ“¹ Ğ’Ñ‹ÑĞ¾ĞºĞ¾ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ğ°Ñ GIF-ÑÑŠĞµĞ¼ĞºĞ°",
          body: "Ğ”Ğ»Ñ Ğ¸Ğ´ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ° Ğ½Ğ°Ğ¼ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ñ‚ÑŒ ÑĞºÑ€Ğ°Ğ½:",
          step1: "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¾Ğ¿Ñ†Ğ¸Ñ <strong>\"Ğ’ĞºĞ»Ğ°Ğ´ĞºĞ°\"</strong>.",
          step2: "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ <strong>ÑÑ‚Ñƒ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ</strong> Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°.",
          step3: "ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ <strong>\"ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ\"</strong>.",
          note: "ĞœÑ‹ÑˆÑŒ Ğ±ÑƒĞ´ĞµÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑĞºÑ€Ñ‹Ñ‚Ğ°, Ğ° ĞºĞ°Ñ€Ñ‚Ğ° Ğ¾Ğ±Ñ€ĞµĞ·Ğ°Ğ½Ğ°.",
          cancel: "ĞÑ‚Ğ¼ĞµĞ½Ğ°",
          start: "ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚"
        },
        appTitle: 'Card Creator', appSubtitle: 'Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ ÑĞ²Ğ¾Ğ¸ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ¾Ğ»Ğ»ĞµĞºÑ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹', hoverHint: 'âœ¨ ĞĞ°Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒÑĞ¸Ğ»Ğ¸Ñ‚ÑŒ ÑÑ„Ñ„ĞµĞºÑ‚ âœ¨', elements: { Fire: 'ĞĞ³Ğ¾Ğ½ÑŒ', Water: 'Ğ’Ğ¾Ğ´Ğ°', Nature: 'ĞŸÑ€Ğ¸Ñ€Ğ¾Ğ´Ğ°', Electric: 'Ğ­Ğ»ĞµĞºÑ‚Ñ€Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾', Mystic: 'ĞœĞ¸ÑÑ‚Ğ¸ĞºĞ°', Fighting: 'Ğ‘Ğ¾ĞµĞ²Ğ¾Ğ¹', Shadow: 'Ğ¢ĞµĞ½ÑŒ', Metal: 'ĞœĞµÑ‚Ğ°Ğ»Ğ»', Light: 'Ğ¡Ğ²ĞµÑ‚', Dragon: 'Ğ”Ñ€Ğ°ĞºĞ¾Ğ½', Ice: 'Ğ›Ñ‘Ğ´', Neutral: 'ĞĞµĞ¹Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹' }, effects: { none: { name: 'ĞĞµÑ‚', description: 'Ğ‘ĞµĞ· ÑÑ„Ñ„ĞµĞºÑ‚Ğ°' }, holographic: { name: 'Ğ“Ğ¾Ğ»Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹', description: 'ĞšĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ñ€Ğ°Ğ´ÑƒĞ¶Ğ½Ñ‹Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚' }, rainbow: { name: 'Ğ Ğ°Ğ´ÑƒĞ³Ğ°', description: 'ĞĞ½Ğ¸Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ñ†Ğ²ĞµÑ‚Ğ½Ñ‹Ğ¹ Ğ³Ñ€Ğ°Ğ´Ğ¸ĞµĞ½Ñ‚' }, gold: { name: 'Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ¾', description: 'Ğ Ğ¾ÑĞºĞ¾ÑˆĞ½Ñ‹Ğµ Ğ·Ğ¾Ğ»Ğ¾Ñ‚Ñ‹Ğµ Ğ¾Ñ‚Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ' }, silver: { name: 'Ğ¡ĞµÑ€ĞµĞ±Ñ€Ğ¾', description: 'ĞœĞµÑ‚Ğ°Ğ»Ğ»Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑĞµÑ€ĞµĞ±Ñ€ÑĞ½Ñ‹Ğµ Ğ¾Ñ‚Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ' }, prismatic: { name: 'ĞŸÑ€Ğ¸Ğ·Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹', description: 'Ğ­Ñ„Ñ„ĞµĞºÑ‚ Ğ¿Ñ€ĞµĞ»Ğ¾Ğ¼Ğ»ÑÑÑ‰ĞµĞ³Ğ¾ ĞºÑ€Ğ¸ÑÑ‚Ğ°Ğ»Ğ»Ğ°' }, neon: { name: 'ĞĞµĞ¾Ğ½', description: 'Ğ¯Ñ€ĞºĞ¾Ğµ Ğ½ĞµĞ¾Ğ½Ğ¾Ğ²Ğ¾Ğµ ÑĞ²ĞµÑ‡ĞµĞ½Ğ¸Ğµ' }, galaxy: { name: 'Ğ“Ğ°Ğ»Ğ°ĞºÑ‚Ğ¸ĞºĞ°', description: 'Ğ—Ğ²Ñ‘Ğ·Ğ´Ğ½Ñ‹Ğ¹ ĞºĞ¾ÑĞ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚' }, fire: { name: 'ĞŸĞ»Ğ°Ğ¼Ñ', description: 'ĞĞ½Ğ¸Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚ Ğ¾Ğ³Ğ½Ñ' }, ice: { name: 'Ğ›Ñ‘Ğ´', description: 'Ğ¡Ğ²ĞµÑ€ĞºĞ°ÑÑ‰Ğ¸Ğ¹ Ğ»ĞµĞ´ÑĞ½Ğ¾Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚' } }, stages: ['Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹', 'Ğ¡Ñ‚Ğ°Ğ´Ğ¸Ñ 1', 'Ğ¡Ñ‚Ğ°Ğ´Ğ¸Ñ 2', 'ĞÑĞ¾Ğ±Ñ‹Ğ¹', 'Ğ›ĞµĞ³ĞµĞ½Ğ´Ğ°Ñ€Ğ½Ñ‹Ğ¹', 'ĞœĞ¸Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹', 'Ğ£Ğ»ÑŒÑ‚Ñ€Ğ°'], rarities: { common: 'ĞĞ±Ñ‹Ñ‡Ğ½Ğ°Ñ', uncommon: 'ĞĞµĞ¾Ğ±Ñ‹Ñ‡Ğ½Ğ°Ñ', rare: 'Ğ ĞµĞ´ĞºĞ°Ñ', epic: 'Ğ­Ğ¿Ğ¸Ñ‡ĞµÑĞºĞ°Ñ', legendary: 'Ğ›ĞµĞ³ĞµĞ½Ğ´Ğ°Ñ€Ğ½Ğ°Ñ', mythic: 'ĞœĞ¸Ñ„Ğ¸Ñ‡ĞµÑĞºĞ°Ñ' }, sections: { image: 'Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ', basicInfo: 'ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ', rarityEffects: 'Ğ ĞµĞ´ĞºĞ¾ÑÑ‚ÑŒ Ğ¸ Ğ­Ñ„Ñ„ĞµĞºÑ‚Ñ‹', abilities: 'Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸', stats: 'Ğ¥Ğ°Ñ€Ğ°ĞºÑ‚ĞµÑ€Ğ¸ÑÑ‚Ğ¸ĞºĞ¸', appearance: 'Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ Ğ²Ğ¸Ğ´' }, labels: { name: 'Ğ˜Ğ¼Ñ', hp: 'ĞÑ‡ĞºĞ¸ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ', element: 'Ğ­Ğ»ĞµĞ¼ĞµĞ½Ñ‚', stage: 'Ğ¡Ñ‚Ğ°Ğ´Ğ¸Ñ', description: 'ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ', author: 'ĞĞ²Ñ‚Ğ¾Ñ€', rarity: 'Ğ ĞµĞ´ĞºĞ¾ÑÑ‚ÑŒ', effect: 'Ğ­Ñ„Ñ„ĞµĞºÑ‚', weakness: 'Ğ¡Ğ»Ğ°Ğ±Ğ¾ÑÑ‚ÑŒ', resistance: 'Ğ¡Ğ¾Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ»ĞµĞ½Ğ¸Ğµ', retreatCost: 'Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ñ', abilityName: 'ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸', damage: 'Ğ£Ñ€Ğ¾Ğ½', energyCost: 'Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ ÑĞ½ĞµÑ€Ğ³Ğ¸Ğ¸', abilityDesc: 'ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ', borderColor: 'Ğ¦Ğ²ĞµÑ‚ Ñ€Ğ°Ğ¼ĞºĞ¸', backgroundColor: 'Ğ¦Ğ²ĞµÑ‚ Ñ„Ğ¾Ğ½Ğ°', textColor: 'Ğ¦Ğ²ĞµÑ‚ Ñ‚ĞµĞºÑÑ‚Ğ°', font: 'Ğ¨Ñ€Ğ¸Ñ„Ñ‚', zoom: 'ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±' }, buttons: { addAbility: '+ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚ÑŒ', remove: 'Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ', change: 'Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ', recenter: 'Ğ¦ĞµĞ½Ñ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ', download: 'Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ', autoRotate: '3D Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€' }, checkboxes: { showHP: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¾Ñ‡ĞºĞ¸ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ', showWeakRes: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ»Ğ°Ğ±Ğ¾ÑÑ‚ÑŒ/ÑĞ¾Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ»ĞµĞ½Ğ¸Ğµ', showRetreat: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ñ', showDescription: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ', showTexture: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑÑ‚ÑƒÑ€Ñƒ', showParticles: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹', showDamage: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑƒÑ€Ğ¾Ğ½' }, imageEditor: { dropHint: 'ĞŸĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑÑĞ´Ğ°', orClick: 'Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°', formats: 'PNG,JPG,GIF,WEBP (Ğ¼Ğ°ĞºÑ 15ĞœĞ‘)', loading: 'Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°...', unsupportedFormat: 'ĞĞµĞ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµĞ¼Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ PNG,JPG,GIF Ğ¸Ğ»Ğ¸ WEBP.', fileTooLarge: 'Ğ¤Ğ°Ğ¹Ğ» ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹. ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 15ĞœĞ‘.' }, download: { title: 'ğŸ“¥ Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ', pngTitle: 'ĞŸÑ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾Ğµ PNG Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ', jpgTitle: 'JPG Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ñ Ñ„Ğ¾Ğ½Ğ¾Ğ¼', gifTitle: 'ĞĞ½Ğ¸Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ GIF (3 ÑĞµĞºÑƒĞ½Ğ´Ñ‹)', htmlTitle: 'Ğ˜Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ HTML Ñ„Ğ°Ğ¹Ğ»', capturing: 'â³ Ğ—Ğ°Ñ…Ğ²Ğ°Ñ‚...', encoding: 'âš™ï¸ ĞšĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ...' }, card: { hp: 'ĞĞ—', weakness: 'Ğ¡Ğ»Ğ°Ğ±Ğ¾ÑÑ‚ÑŒ', resistance: 'Ğ¡Ğ¾Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ»ĞµĞ½Ğ¸Ğµ', cost: 'Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ', illus: 'Ğ¥ÑƒĞ´.' }, defaults: { newAbility: 'ĞĞ¾Ğ²Ğ°Ñ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚ÑŒ' }, display: { title: 'ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ' }, tabs: { info: 'Ğ˜Ğ½Ñ„Ğ¾', combat: 'Ğ‘Ğ¾Ğ¹', visual: 'Ğ’Ğ¸Ğ´' }
      },
      ja: {
        gifModal: {
          title: "ğŸ“¹ é«˜å“è³ªGIFã‚­ãƒ£ãƒ—ãƒãƒ£",
          body: "å®Œç’§ãªçµæœã‚’å¾—ã‚‹ãŸã‚ã«ã€ç”»é¢ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š",
          step1: "<strong>ã€Œã‚¿ãƒ–ã€</strong>ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¾ã™ã€‚",
          step2: "ãƒªã‚¹ãƒˆã‹ã‚‰<strong>ã“ã®ãƒšãƒ¼ã‚¸</strong>ã‚’é¸æŠã—ã¾ã™ã€‚",
          step3: "<strong>ã€Œå…±æœ‰ã€</strong>ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚",
          note: "ãƒã‚¦ã‚¹ã¯è‡ªå‹•çš„ã«éè¡¨ç¤ºã«ãªã‚Šã€ã‚«ãƒ¼ãƒ‰ã¯åˆ‡ã‚Šå–ã‚‰ã‚Œã¾ã™ã€‚",
          cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
          start: "ã‚­ãƒ£ãƒ—ãƒãƒ£é–‹å§‹"
        },
        appTitle: 'Card Creator', appSubtitle: 'ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã‚ˆã†', hoverHint: 'âœ¨ ã‚«ãƒ¼ãƒ‰ã«ãƒã‚¦ã‚¹ã‚’ä¹—ã›ã‚‹ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå¼·ããªã‚Šã¾ã™ âœ¨', elements: { Fire: 'ç‚', Water: 'æ°´', Nature: 'è‡ªç„¶', Electric: 'é›»æ°—', Mystic: 'ç¥ç§˜', Fighting: 'æ ¼é—˜', Shadow: 'é—‡', Metal: 'é‹¼', Light: 'å…‰', Dragon: 'ãƒ‰ãƒ©ã‚´ãƒ³', Ice: 'æ°·', Neutral: 'ç„¡' }, effects: { none: { name: 'ãªã—', description: 'ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã—' }, holographic: { name: 'ãƒ›ãƒ­ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯', description: 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯ãªè™¹è‰²ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' }, rainbow: { name: 'ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼', description: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ©ãƒ¼ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³' }, gold: { name: 'ã‚´ãƒ¼ãƒ«ãƒ‰', description: 'è±ªè¯ãªé‡‘è‰²ã®åå°„' }, silver: { name: 'ã‚·ãƒ«ãƒãƒ¼', description: 'ãƒ¡ã‚¿ãƒªãƒƒã‚¯ãªéŠ€è‰²ã®åå°„' }, prismatic: { name: 'ãƒ—ãƒªã‚ºãƒãƒ†ã‚£ãƒƒã‚¯', description: 'å±ˆæŠ˜ã™ã‚‹ã‚¯ãƒªã‚¹ã‚¿ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' }, neon: { name: 'ãƒã‚ªãƒ³', description: 'é®®ã‚„ã‹ãªãƒã‚ªãƒ³ã®è¼ã' }, galaxy: { name: 'ã‚®ãƒ£ãƒ©ã‚¯ã‚·ãƒ¼', description: 'æ˜Ÿç©ºã®å®‡å®™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' }, fire: { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ', description: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' }, ice: { name: 'ãƒ•ãƒ­ã‚¹ãƒˆ', description: 'ãã‚‰ã‚ãæ°·ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' } }, stages: ['ãƒ™ãƒ¼ã‚·ãƒƒã‚¯', 'ã‚¹ãƒ†ãƒ¼ã‚¸1', 'ã‚¹ãƒ†ãƒ¼ã‚¸2', 'ã‚¹ãƒšã‚·ãƒ£ãƒ«', 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼', 'ãƒŸã‚·ãƒƒã‚¯', 'ã‚¦ãƒ«ãƒˆãƒ©'], rarities: { common: 'ã‚³ãƒ¢ãƒ³', uncommon: 'ã‚¢ãƒ³ã‚³ãƒ¢ãƒ³', rare: 'ãƒ¬ã‚¢', epic: 'ã‚¨ãƒ”ãƒƒã‚¯', legendary: 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼', mythic: 'ãƒŸã‚·ãƒƒã‚¯' }, sections: { image: 'ç”»åƒ', basicInfo: 'åŸºæœ¬æƒ…å ±', rarityEffects: 'ãƒ¬ã‚¢ãƒªãƒ†ã‚£ï¼†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ', abilities: 'æŠ€', stats: 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹', appearance: 'å¤–è¦³' }, labels: { name: 'åå‰', hp: 'HP', element: 'ã‚¿ã‚¤ãƒ—', stage: 'ã‚¹ãƒ†ãƒ¼ã‚¸', description: 'èª¬æ˜', author: 'ä½œè€…', rarity: 'ãƒ¬ã‚¢ãƒªãƒ†ã‚£', effect: 'ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ', weakness: 'å¼±ç‚¹', resistance: 'æŠµæŠ—åŠ›', retreatCost: 'ã«ã’ã‚‹ã‚³ã‚¹ãƒˆ', abilityName: 'æŠ€å', damage: 'ãƒ€ãƒ¡ãƒ¼ã‚¸', ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚³ã‚¹ãƒˆ: 'ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚³ã‚¹ãƒˆ', abilityDesc: 'èª¬æ˜', borderColor: 'æ ã®è‰²', backgroundColor: 'èƒŒæ™¯è‰²', textColor: 'æ–‡å­—è‰²', font: 'ãƒ•ã‚©ãƒ³ãƒˆ', zoom: 'ã‚ºãƒ¼ãƒ ' }, buttons: { addAbility: '+ æŠ€ã‚’è¿½åŠ ', remove: 'å‰Šé™¤', change: 'å¤‰æ›´', recenter: 'ä¸­å¤®ã«æˆ»ã™', download: 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰', autoRotate: '3Dãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼' }, checkboxes: { showHP: 'HPã‚’è¡¨ç¤º', showWeakRes: 'å¼±ç‚¹/æŠµæŠ—åŠ›ã‚’è¡¨ç¤º', showRetreat: 'ã«ã’ã‚‹ã‚³ã‚¹ãƒˆã‚’è¡¨ç¤º', showDescription: 'èª¬æ˜ã‚’è¡¨ç¤º', showTexture: 'ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¡¨ç¤º', showParticles: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¡¨ç¤º', showDamage: 'ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¡¨ç¤º' }, imageEditor: { dropHint: 'ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—', orClick: 'ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ', formats: 'PNG,JPG,GIF,WEBP (æœ€å¤§15MB)', loading: 'èª­ã¿è¾¼ã¿ä¸­...', unsupportedFormat: 'ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å½¢å¼ã§ã™ã€‚PNGã€JPGã€GIFã€WEBPã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚', fileTooLarge: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤§ãã™ãã¾ã™ã€‚æœ€å¤§15MBã§ã™ã€‚' }, download: { title: 'ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰', pngTitle: 'é€éPNGç”»åƒ', jpgTitle: 'èƒŒæ™¯ä»˜ãJPGç”»åƒ', gifTitle: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³GIFï¼ˆ3ç§’ï¼‰', htmlTitle: 'ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–HTMLãƒ•ã‚¡ã‚¤ãƒ«', capturing: 'â³ ã‚­ãƒ£ãƒ—ãƒãƒ£ä¸­...', encoding: 'âš™ï¸ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­...' }, card: { hp: 'HP', weakness: 'å¼±ç‚¹', resistance: 'æŠµæŠ—åŠ›', cost: 'ã‚³ã‚¹ãƒˆ', illus: 'ã‚¤ãƒ©ã‚¹ãƒˆ' }, defaults: { newAbility: 'æ–°ã—ã„æŠ€' }, display: { title: 'è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³' }, tabs: { info: 'æƒ…å ±', combat: 'æˆ¦é—˜', visual: 'å¤–è¦³' }
      },
      zh: {
        gifModal: {
          title: "ğŸ“¹ é«˜è´¨é‡GIFæ•è·",
          body: "ä¸ºäº†è·å¾—å®Œç¾çš„æ•ˆæœï¼Œæˆ‘ä»¬éœ€è¦æ•è·å±å¹•ï¼š",
          step1: "é€‰æ‹© <strong>â€œæ ‡ç­¾é¡µâ€</strong> é€‰é¡¹ã€‚",
          step2: "ä»åˆ—è¡¨ä¸­é€‰æ‹© <strong>æ­¤é¡µé¢</strong>ã€‚",
          step3: "ç‚¹å‡» <strong>â€œåˆ†äº«â€</strong>ã€‚",
          note: "é¼ æ ‡å°†è‡ªåŠ¨éšè—ï¼Œå¡ç‰‡å°†è¢«è£å‰ªã€‚",
          cancel: "å–æ¶ˆ",
          start: "å¼€å§‹æ•è·"
        },
        appTitle: 'Card Creator', appSubtitle: 'åˆ›å»ºæ‚¨è‡ªå·±çš„ä¸ªæ€§åŒ–æ”¶è—å¡', hoverHint: 'âœ¨ å°†é¼ æ ‡æ‚¬åœåœ¨å¡ç‰‡ä¸Šä»¥å¢å¼ºæ•ˆæœ âœ¨', elements: { Fire: 'ç«', Water: 'æ°´', Nature: 'è‡ªç„¶', Electric: 'ç”µ', Mystic: 'ç¥ç§˜', Fighting: 'æ ¼æ–—', Shadow: 'æš—', Metal: 'é’¢', Light: 'å…‰', Dragon: 'é¾™', Ice: 'å†°', Neutral: 'æ— ' }, effects: { none: { name: 'æ— ', description: 'æ— æ•ˆæœ' }, holographic: { name: 'å…¨æ¯', description: 'ç»å…¸å½©è™¹æ•ˆæœ' }, rainbow: { name: 'å½©è™¹', description: 'åŠ¨ç”»å¤šè‰²æ¸å˜' }, gold: { name: 'é‡‘è‰²', description: 'å¥¢åé‡‘è‰²åå°„' }, silver: { name: 'é“¶è‰²', description: 'é‡‘å±é“¶è‰²åå°„' }, prismatic: { name: 'æ£±é•œ', description: 'æŠ˜å°„æ°´æ™¶æ•ˆæœ' }, neon: { name: 'éœ“è™¹', description: 'é²œè‰³éœ“è™¹å…‰èŠ’' }, galaxy: { name: 'æ˜Ÿç³»', description: 'æ˜Ÿç©ºå®‡å®™æ•ˆæœ' }, fire: { name: 'ç«ç„°', description: 'åŠ¨ç”»ç«ç„°æ•ˆæœ' }, ice: { name: 'å†°éœœ', description: 'é—ªçƒå†°æ™¶æ•ˆæœ' } }, stages: ['åŸºç¡€', 'é˜¶æ®µ1', 'é˜¶æ®µ2', 'ç‰¹æ®Š', 'ä¼ è¯´', 'ç¥è¯', 'ç©¶æ'], rarities: { common: 'æ™®é€š', uncommon: 'ç¨€æœ‰', rare: 'çè´µ', epic: 'å²è¯—', legendary: 'ä¼ è¯´', mythic: 'ç¥è¯' }, sections: { image: 'å›¾ç‰‡', basicInfo: 'åŸºæœ¬ä¿¡æ¯', rarityEffects: 'ç¨€æœ‰åº¦å’Œæ•ˆæœ', abilities: 'æŠ€èƒ½', stats: 'å±æ€§', appearance: 'å¤–è§‚' }, labels: { name: 'åç§°', hp: 'ç”Ÿå‘½å€¼', element: 'å±æ€§', stage: 'é˜¶æ®µ', description: 'æè¿°', author: 'ä½œè€…', rarity: 'ç¨€æœ‰åº¦', effect: 'æ•ˆæœ', weakness: 'å¼±ç‚¹', resistance: 'æŠ—æ€§', retreatCost: 'æ’¤é€€æ¶ˆè€—', abilityName: 'æŠ€èƒ½åç§°', damage: 'ä¼¤å®³', energyCost: 'èƒ½é‡æ¶ˆè€—', abilityDesc: 'æè¿°', borderColor: 'è¾¹æ¡†é¢œè‰²', backgroundColor: 'èƒŒæ™¯é¢œè‰²', textColor: 'æ–‡å­—é¢œè‰²', font: 'å­—ä½“', zoom: 'ç¼©æ”¾' }, buttons: { addAbility: '+ æ·»åŠ æŠ€èƒ½', remove: 'åˆ é™¤', change: 'æ›´æ”¹', recenter: 'å±…ä¸­', download: 'ä¸‹è½½', autoRotate: '3Dé¢„è§ˆ' }, checkboxes: { showHP: 'æ˜¾ç¤ºç”Ÿå‘½å€¼', showWeakRes: 'æ˜¾ç¤ºå¼±ç‚¹/æŠ—æ€§', showRetreat: 'æ˜¾ç¤ºæ’¤é€€æ¶ˆè€—', showDescription: 'æ˜¾ç¤ºæè¿°', showTexture: 'æ˜¾ç¤ºçº¹ç†', showParticles: 'æ˜¾ç¤ºç²’å­', showDamage: 'æ˜¾ç¤ºä¼¤å®³' }, imageEditor: { dropHint: 'å°†å›¾ç‰‡æ‹–æ”¾åˆ°è¿™é‡Œ', orClick: 'æˆ–ç‚¹å‡»é€‰æ‹©', formats: 'PNG,JPG,GIF,WEBP (æœ€å¤§15MB)', loading: 'åŠ è½½ä¸­...', unsupportedFormat: 'ä¸æ”¯æŒçš„æ ¼å¼ã€‚è¯·ä½¿ç”¨PNGã€JPGã€GIFæˆ–WEBPã€‚', fileTooLarge: 'æ–‡ä»¶å¤ªå¤§ã€‚æœ€å¤§15MBã€‚' }, download: { title: 'ğŸ“¥ ä¸‹è½½', pngTitle: 'é€æ˜PNGå›¾ç‰‡', jpgTitle: 'å¸¦èƒŒæ™¯çš„JPGå›¾ç‰‡', gifTitle: 'åŠ¨ç”»GIFï¼ˆ3ç§’ï¼‰', htmlTitle: 'äº¤äº’å¼HTMLæ–‡ä»¶', capturing: 'â³ æ•è·ä¸­...', encoding: 'âš™ï¸ ç¼–ç ä¸­...' }, card: { hp: 'HP', weakness: 'å¼±ç‚¹', resistance: 'æŠ—æ€§', cost: 'æ¶ˆè€—', illus: 'ç”»å¸ˆ' }, defaults: { newAbility: 'æ–°æŠ€èƒ½' }, display: { title: 'æ˜¾ç¤ºé€‰é¡¹' }, tabs: { info: 'ä¿¡æ¯', combat: 'æˆ˜æ–—', visual: 'è§†è§‰' }
      },
    };
    const LanguageContext = createContext();
    const useLanguage = () => {
      const context = useContext(LanguageContext);
      if (!context) {
        throw new Error('useLanguage must be used within a LanguageProvider')
      }
      return context
    };
    const CARD_LIMITS = {
      HP_MIN: 0, HP_MAX: 999, DAMAGE_MIN: 0, DAMAGE_MAX: 9999, COST_MIN: 0, COST_MAX: 6, RETREAT_MIN: 0, RETREAT_MAX: 5, NAME_MAX_LENGTH: 25, DESC_MAX_LENGTH: 150, ATTACK_DESC_MAX_LENGTH: 80, AUTHOR_MAX_LENGTH: 30, MAX_FILE_SIZE: 15 * 1024 * 1024, // 15MB
      ZOOM_MIN: 1, ZOOM_MAX: 3,
    };
    const ELEMENT_TYPES = {
      Fire: { icon: 'ğŸ”¥', primary: '#FF6B35', secondary: '#FFE066' }, Water: { icon: 'ğŸ’§', primary: '#4FC3F7', secondary: '#E1F5FE' }, Nature: { icon: 'ğŸŒ¿', primary: '#66BB6A', secondary: '#C8E6C9' }, Electric: { icon: 'âš¡', primary: '#FFEE58', secondary: '#FFF9C4' }, Mystic: { icon: 'ğŸ”®', primary: '#BA68C8', secondary: '#F3E5F5' }, Fighting: { icon: 'ğŸ‘Š', primary: '#D84315', secondary: '#FFAB91' }, Shadow: { icon: 'ğŸŒ‘', primary: '#5D4037', secondary: '#A1887F' }, Metal: { icon: 'âš™ï¸', primary: '#90A4AE', secondary: '#ECEFF1' }, Light: { icon: 'âœ¨', primary: '#FFD54F', secondary: '#FFF8E1' }, Dragon: { icon: 'ğŸ‰', primary: '#7E57C2', secondary: '#D1C4E9' }, Ice: { icon: 'â„ï¸', primary: '#4DD0E1', secondary: '#E0F7FA' }, Neutral: { icon: 'â­', primary: '#BDBDBD', secondary: '#F5F5F5' },
    };
    const ELEMENT_KEYS = Object.keys(ELEMENT_TYPES);
    const CARD_EFFECTS = ['none', 'holographic', 'rainbow', 'gold', 'silver', 'prismatic', 'neon', 'galaxy', 'fire', 'ice'];
    const STAGES = ['Base', 'Stage1', 'Stage2', 'Special', 'Legendary', 'Mythic', 'Ultra'];
    const RARITIES = [{ key: 'common', icon: 'âšª', color: '#8b7355', border: '#8b7355', label: 'Common' },
    { key: 'uncommon', icon: 'ğŸŸ¢', color: '#4CAF50', border: '#4CAF50', label: 'Uncommon' },
    { key: 'rare', icon: 'ğŸ’', color: '#2196F3', border: '#2196F3', label: 'Rare' },
    { key: 'epic', icon: 'ğŸ’œ', color: '#9C27B0', border: '#9C27B0', label: 'Epic' },
    { key: 'legendary', icon: 'â­', color: '#ffd700', border: '#ffd700', label: 'Legendary' },
    { key: 'mythic', icon: 'ğŸŒŸ', color: '#ff4081', border: '#ff4081', label: 'Mythic' },];
    const ELEMENT_TEXTURES = {
      Fire: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5c-5 10-15 15-15 25 0 8 7 15 15 15s15-7 15-15c0-10-10-15-15-25z' fill='%23ff6b3520' /%3E%3Cpath d='M30 15c-3 6-9 9-9 15 0 5 4 9 9 9s9-4 9-9c0-6-6-9-9-15z' fill='%23ff450015' /%3E%3C/svg%3E")`, Water: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='15' cy='15' r='8' fill='%2300bcd420' /%3E%3Ccircle cx='45' cy='35' r='6' fill='%232196f315' /%3E%3Ccircle cx='25' cy='45' r='10' fill='%2303a9f418' /%3E%3Cpath d='M5 30 Q15 25 25 30 T45 30 T60 30' stroke='%2300bcd415' fill='none' stroke-width='2'/%3E%3C/svg%3E")`, Nature: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5 Q35 15 30 25 Q25 15 30 5z' fill='%234caf5020' /%3E%3Cpath d='M15 30 Q25 35 20 45 Q15 35 15 30z' fill='%238bc34a18' /%3E%3Cpath d='M45 25 Q50 35 45 45 Q40 35 45 25z' fill='%234caf5015' /%3E%3Ccircle cx='10' cy='50' r='3' fill='%234caf5012' /%3E%3C/svg%3E")`, Electric: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0 L25 25 L35 20 L20 60 L25 30 L15 35 Z' fill='%23ffeb3b15' /%3E%3Cpath d='M50 10 L48 20 L52 18 L45 35' stroke='%23ffc10710' fill='none' stroke-width='2'/%3E%3Ccircle cx='10' cy='45' r='2' fill='%23ffeb3b20' /%3E%3C/svg%3E")`, Mystic: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='30,5 32,15 40,10 35,18 45,20 35,22 40,30 32,25 30,35 28,25 20,30 25,22 15,20 25,18 20,10 28,15' fill='%239c27b015' /%3E%3Ccircle cx='10' cy='50' r='4' fill='%23e91e6310' /%3E%3Ccircle cx='50' cy='45' r='3' fill='%239c27b012' /%3E%3C/svg%3E")`, Fighting: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 10 L50 50' stroke='%23f4433615' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M50 10 L10 50' stroke='%23ff572215' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M30 5 L30 55' stroke='%23f4433610' stroke-width='3'/%3E%3Cpath d='M5 30 L55 30' stroke='%23f4433610' stroke-width='3'/%3E%3C/svg%3E")`, Shadow: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cellipse cx='30' cy='50' rx='20' ry='8' fill='%2300000015' /%3E%3Cellipse cx='15' cy='30' rx='10' ry='5' fill='%2300000010' /%3E%3Cellipse cx='45' cy='20' rx='12' ry='6' fill='%2300000012' /%3E%3Cpath d='M20 10 Q30 20 25 35 Q35 25 40 40' stroke='%2300000008' fill='none' stroke-width='3'/%3E%3C/svg%3E")`, Metal: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='5' y='5' width='20' height='20' rx='2' fill='none' stroke='%2360606015' stroke-width='2'/%3E%3Crect x='35' y='35' width='20' height='20' rx='2' fill='none' stroke='%2360606015' stroke-width='2'/%3E%3Ccircle cx='15' cy='15' r='3' fill='%2390909020' /%3E%3Ccircle cx='45' cy='45' r='3' fill='%2390909020' /%3E%3Ccircle cx='45' cy='15' r='2' fill='%2360606015' /%3E%3Ccircle cx='15' cy='45' r='2' fill='%2360606015' /%3E%3C/svg%3E")`, Light: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='30' cy='30' r='15' fill='%23fff59d10' /%3E%3Cpath d='M30 5 L30 15 M30 45 L30 55 M5 30 L15 30 M45 30 L55 30 M12 12 L19 19 M41 41 L48 48 M12 48 L19 41 M41 19 L48 12' stroke='%23ffeb3b15' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E")`, Dragon: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 20 Q20 15 30 20 Q40 15 50 20 L50 35 Q40 40 30 35 Q20 40 10 35 Z' fill='%23673ab720' /%3E%3Cpath d='M10 35 Q20 30 30 35 Q40 30 50 35 L50 50 Q40 55 30 50 Q20 55 10 50 Z' fill='%23673ab715' /%3E%3Cpath d='M10 5 Q20 0 30 5 Q40 0 50 5 L50 20 Q40 25 30 20 Q20 25 10 20 Z' fill='%23673ab712' /%3E%3C/svg%3E")`, Ice: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5 L30 55 M15 15 L45 45 M45 15 L15 45' stroke='%2381d4fa20' stroke-width='2'/%3E%3Cpath d='M30 20 L25 15 M30 20 L35 15 M30 40 L25 45 M30 40 L35 45' stroke='%2329b6f618' stroke-width='2'/%3E%3Cpolygon points='30,25 33,30 30,35 27,30' fill='%2381d4fa15' /%3E%3C/svg%3E")`, Neutral: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='30' cy='30' r='20' fill='none' stroke='%2390909010' stroke-width='1'/%3E%3Ccircle cx='30' cy='30' r='10' fill='none' stroke='%2390909008' stroke-width='1'/%3E%3C/svg%3E")`,
    };
    const ELEMENT_PARTICLES = {
      Fire: { emoji: 'ğŸ”¥', alt: ['ğŸ”¥', 'âœ¨'], count: 12, speed: 'fast', direction: 'up' },
      Water: { emoji: 'ğŸ’§', alt: ['ğŸ«§', 'ğŸ’¦'], count: 12, speed: 'slow', direction: 'up' },
      Nature: { emoji: 'ğŸƒ', alt: ['ğŸŒ¿', 'ğŸŒ¸'], count: 11, speed: 'medium', direction: 'float' },
      Electric: { emoji: 'âš¡', alt: ['âš¡', 'â­'], count: 9, speed: 'fast', direction: 'random' },
      Mystic: { emoji: 'ğŸ”®', alt: ['âœ¨', 'ğŸ’«'], count: 10, speed: 'slow', direction: 'float' },
      Fighting: { emoji: 'ğŸ’¥', alt: ['ğŸ’¢', 'âš¡'], count: 8, speed: 'fast', direction: 'random' },
      Shadow: { emoji: 'ğŸŒ‘', alt: ['ğŸ’€', 'ğŸ‘»'], count: 7, speed: 'slow', direction: 'down' },
      Metal: { emoji: 'âš™ï¸', alt: ['â›“ï¸', 'ğŸ”©'], count: 6, speed: 'slow', direction: 'float' },
      Light: { emoji: 'âœ¨', alt: ['â­', 'ğŸŒŸ'], count: 12, speed: 'medium', direction: 'radial' },
      Dragon: { emoji: 'ğŸ‰', alt: ['ğŸ’', 'ğŸ”¥'], count: 6, speed: 'medium', direction: 'float' },
      Ice: { emoji: 'â„ï¸', alt: ['â…', 'ğŸ’'], count: 14, speed: 'slow', direction: 'down' },
      Neutral: { emoji: 'âœ¦', alt: ['âšª', 'â—†'], count: 5, speed: 'slow', direction: 'float' },
    };
    const FONTS = [{ id: 'nunito', name: 'Nunito', family: "'Nunito',sans-serif" },
    { id: 'roboto', name: 'Roboto', family: "'Roboto',sans-serif" },
    { id: 'poppins', name: 'Poppins', family: "'Poppins',sans-serif" },
    { id: 'oswald', name: 'Oswald', family: "'Oswald',sans-serif" },
    { id: 'playfair', name: 'Playfair', family: "'Playfair Display',serif" },
    { id: 'bangers', name: 'Bangers', family: "'Bangers',cursive" },];
    const INITIAL_CARD_DATA = {
      name: 'My Creature', hp: 120, type: 'Fire', stage: 'Base', weakness: 'Water', resistance: 'Nature', retreatCost: 2, rarity: 'rare', description: 'A mysterious creature with incredible powers.', author: 'Creator', effect: 'holographic', font: 'nunito', borderColor: '', backgroundColor: '', textColor: '', showHP: true, showWeakRes: true, showRetreat: true, showDescription: true, showTexture: false, showParticles: true,
    };
    const INITIAL_ATTACKS = [{ id: 'attack-1', name: 'Quick Attack', damage: 30, cost: 1, desc: 'Deals basic damage.' },
    { id: 'attack-2', name: 'Special Attack', damage: 80, cost: 3, desc: 'A devastating attack!' },];
    const INITIAL_IMAGE_SETTINGS = {
      zoom: 1, offsetX: 0, offsetY: 0,
    };
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const parseIntSafe = (value, fallback = 0) => {
      const parsed = parseInt(value, 10);
      return isNaN(parsed) ? fallback : parsed
    };
    const parseFloatSafe = (value, fallback = 0) => {
      const parsed = parseFloat(value);
      return isNaN(parsed) ? fallback : parsed
    };
    const generateId = () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const useThrottle = (callback, delay) => {
      const lastCall = useRef(0);
      const callbackRef = useRef(callback);
      callbackRef.current = callback;
      return useCallback((...args) => {
        const now = Date.now();
        if (now - lastCall.current >= delay) {
          lastCall.current = now;
          callbackRef.current(...args)
        }
      }, [delay])
    };
    const captureCard = async (cardElement, options = {}) => {
      if (!cardElement) throw new Error('Element non trouvÃ©');
      if (!window.html2canvas) {
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script)
        })
      }
      const container = cardElement.closest('.card-3d-container') || cardElement.parentElement;
      const originalContainerTransform = container ? container.style.transform : '';
      if (container) {
        container.style.transform = 'perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)'
      }
      const problematicElements = cardElement.querySelectorAll('.effect-layer, .particles-layer, .texture-layer');
      const originalStyles = [];
      problematicElements.forEach((el, i) => {
        originalStyles[i] = {
          display: el.style.display, visibility: el.style.visibility, opacity: el.style.opacity
        };
        el.style.display = 'none';
        el.style.visibility = 'hidden';
        el.style.opacity = '0'
      });
      const originalCardTransform = cardElement.style.transform;
      cardElement.style.transform = 'none';
      await new Promise(r => setTimeout(r, 50));
      const canvas = await window.html2canvas(cardElement, { backgroundColor: options.backgroundColor || null, scale: options.scale || 2, useCORS: true, allowTaint: true, logging: false, removeContainer: true });
      problematicElements.forEach((el, i) => {
        el.style.display = originalStyles[i].display;
        el.style.visibility = originalStyles[i].visibility;
        el.style.opacity = originalStyles[i].opacity
      });
      cardElement.style.transform = originalCardTransform;
      if (container) {
        container.style.transform = originalContainerTransform
      }
      return canvas
    };
    const downloadAsImage = async (cardElement, filename = 'card', format = 'png') => {
      try {
        const options = format === 'jpg' ? { backgroundColor: '#1a1a2e' } : {};
        const canvas = await captureCard(cardElement, options);
        const link = document.createElement('a');
        link.download = filename + '.' + format;
        link.href = canvas.toDataURL(format === 'jpg' ? 'image/jpeg' : 'image/png', 0.95);
        link.click();
        URL.revokeObjectURL(link.href);
        return true;
      } catch (error) {
        console.error('Erreur ' + format.toUpperCase() + ':', error);
        return false
      }
    };
    const downloadAsPNG = (el, fn) => downloadAsImage(el, fn, 'png');
    const downloadAsJPG = (el, fn) => downloadAsImage(el, fn, 'jpg');
    const getEffectCSS = () => `.effect-holographic .layer-1{background:linear-gradient(125deg,rgba(255,0,0,0.08) 0%,rgba(255,154,0,0.08) 10%,rgba(208,222,33,0.08) 20%,rgba(79,220,74,0.08) 30%,rgba(63,218,216,0.08) 40%,rgba(47,201,226,0.08) 50%,rgba(28,127,238,0.08) 60%,rgba(95,21,242,0.08) 70%,rgba(186,12,248,0.08) 80%,rgba(251,7,217,0.08) 90%,rgba(255,0,0,0.08) 100%);background-size:400% 400%;animation:holoGradient 8s ease infinite;mix-blend-mode:color}.effect-holographic:hover .layer-1{background:linear-gradient(125deg,rgba(255,0,0,0.2) 0%,rgba(255,154,0,0.2) 10%,rgba(208,222,33,0.2) 20%,rgba(79,220,74,0.2) 30%,rgba(63,218,216,0.2) 40%,rgba(47,201,226,0.2) 50%,rgba(28,127,238,0.2) 60%,rgba(95,21,242,0.2) 70%,rgba(186,12,248,0.2) 80%,rgba(251,7,217,0.2) 90%,rgba(255,0,0,0.2) 100%);animation:holoGradient 3s ease infinite}@keyframes holoGradient{0%,100%{background-position:0% 50%}50%{background-position:100% 50%}}.effect-rainbow .layer-1{background:linear-gradient(90deg,rgba(255,0,0,0.12) 0%,rgba(255,127,0,0.12) 14%,rgba(255,255,0,0.12) 28%,rgba(0,255,0,0.12) 42%,rgba(0,0,255,0.12) 57%,rgba(75,0,130,0.12) 71%,rgba(148,0,211,0.12) 85%,rgba(255,0,0,0.12) 100%);background-size:300% 100%;animation:rainbowSlide 6s linear infinite;mix-blend-mode:color}.effect-rainbow:hover .layer-1{background:linear-gradient(90deg,rgba(255,0,0,0.28) 0%,rgba(255,127,0,0.28) 14%,rgba(255,255,0,0.28) 28%,rgba(0,255,0,0.28) 42%,rgba(0,0,255,0.28) 57%,rgba(75,0,130,0.28) 71%,rgba(148,0,211,0.28) 85%,rgba(255,0,0,0.28) 100%);animation:rainbowSlide 3s linear infinite}@keyframes rainbowSlide{0%{background-position:0% 50%}100%{background-position:300% 50%}}.effect-gold .layer-1{background:linear-gradient(-45deg,transparent 35%,rgba(255,200,50,0.15) 47%,rgba(255,240,150,0.3) 50%,rgba(255,200,50,0.15) 53%,transparent 65%);background-size:300% 300%;animation:goldShine 4s ease-in-out infinite;mix-blend-mode:soft-light}.effect-gold:hover .layer-1{background:linear-gradient(-45deg,transparent 30%,rgba(255,200,50,0.25) 45%,rgba(255,240,150,0.45) 50%,rgba(255,200,50,0.25) 55%,transparent 70%);animation:goldShine 2s ease-in-out infinite}@keyframes goldShine{0%,100%{background-position:100% 100%}50%{background-position:0% 0%}}.effect-silver .layer-1{background:linear-gradient(-45deg,transparent 35%,rgba(180,180,200,0.18) 47%,rgba(255,255,255,0.35) 50%,rgba(180,180,200,0.18) 53%,transparent 65%);background-size:300% 300%;animation:goldShine 4s ease-in-out infinite;mix-blend-mode:soft-light}.effect-silver:hover .layer-1{background:linear-gradient(-45deg,transparent 30%,rgba(180,180,200,0.28) 45%,rgba(255,255,255,0.5) 50%,rgba(180,180,200,0.28) 55%,transparent 70%);animation:goldShine 2s ease-in-out infinite}.effect-prismatic .layer-1{background:conic-gradient(from 0deg at 50% 50%,rgba(255,0,0,0.15),rgba(255,127,0,0.15),rgba(255,255,0,0.15),rgba(0,255,0,0.15),rgba(0,255,255,0.15),rgba(0,0,255,0.15),rgba(255,0,255,0.15),rgba(255,0,0,0.15));animation:prismaticRotate 8s linear infinite;mix-blend-mode:color}.effect-prismatic:hover .layer-1{background:conic-gradient(from 0deg at 50% 50%,rgba(255,0,0,0.3),rgba(255,127,0,0.3),rgba(255,255,0,0.3),rgba(0,255,0,0.3),rgba(0,255,255,0.3),rgba(0,0,255,0.3),rgba(255,0,255,0.3),rgba(255,0,0,0.3));animation:prismaticRotate 3s linear infinite}@keyframes prismaticRotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.effect-neon .layer-1{background:linear-gradient(45deg,transparent 40%,rgba(0,255,255,0.15) 50%,transparent 60%),linear-gradient(-45deg,transparent 40%,rgba(255,0,255,0.15) 50%,transparent 60%);animation:neonPulse 2s ease-in-out infinite;mix-blend-mode:hard-light}.effect-neon:hover .layer-1{background:linear-gradient(45deg,transparent 35%,rgba(0,255,255,0.3) 50%,transparent 65%),linear-gradient(-45deg,transparent 35%,rgba(255,0,255,0.3) 50%,transparent 65%);animation:neonPulse 1s ease-in-out infinite}@keyframes neonPulse{0%,100%{opacity:0.8}50%{opacity:1}}.effect-galaxy .layer-1{background:radial-gradient(ellipse at 30% 20%,rgba(80,40,140,0.2) 0%,transparent 40%),radial-gradient(ellipse at 70% 80%,rgba(50,30,120,0.18) 0%,transparent 35%),radial-gradient(circle at 20% 70%,rgba(255,255,255,0.9) 0%,transparent 1.5%),radial-gradient(circle at 80% 30%,rgba(255,255,255,0.85) 0%,transparent 1.2%),radial-gradient(circle at 60% 60%,rgba(255,220,255,0.8) 0%,transparent 1.5%);animation:galaxyRotate 20s linear infinite;mix-blend-mode:screen}.effect-galaxy:hover .layer-1{animation:galaxyRotate 10s linear infinite}@keyframes galaxyRotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.effect-fire .layer-1{background:linear-gradient(0deg,rgba(255,100,0,0.2) 0%,transparent 40%),radial-gradient(ellipse at 50% 90%,rgba(255,200,50,0.25) 0%,transparent 30%),radial-gradient(circle at 40% 75%,rgba(255,255,100,0.5) 0%,transparent 8%);animation:fireFlicker 0.4s ease-in-out infinite alternate;mix-blend-mode:hard-light}.effect-fire:hover .layer-1{background:linear-gradient(0deg,rgba(255,100,0,0.35) 0%,transparent 50%),radial-gradient(ellipse at 50% 90%,rgba(255,200,50,0.4) 0%,transparent 35%),radial-gradient(circle at 40% 75%,rgba(255,255,100,0.7) 0%,transparent 10%);animation:fireFlicker 0.25s ease-in-out infinite alternate}@keyframes fireFlicker{0%{transform:translateY(0);opacity:0.9}100%{transform:translateY(-2px);opacity:1}}.effect-ice .layer-1{background:linear-gradient(135deg,rgba(200,240,255,0.12) 0%,transparent 50%,rgba(200,240,255,0.12) 100%),radial-gradient(circle at 20% 20%,rgba(255,255,255,0.85) 0%,transparent 3%),radial-gradient(circle at 80% 25%,rgba(200,240,255,0.75) 0%,transparent 2.5%);animation:iceSparkle 3s ease-in-out infinite;mix-blend-mode:soft-light}.effect-ice:hover .layer-1{background:linear-gradient(135deg,rgba(200,240,255,0.25) 0%,transparent 50%,rgba(200,240,255,0.25) 100%),radial-gradient(circle at 20% 20%,rgba(255,255,255,1) 0%,transparent 4%),radial-gradient(circle at 80% 25%,rgba(200,240,255,0.9) 0%,transparent 3%);animation:iceSparkle 1.5s ease-in-out infinite}@keyframes iceSparkle{0%,100%{opacity:0.85}50%{opacity:1}}`;

    const downloadAsGIF = async (cardElement, filename = 'card', duration = 3000, fps = 15, t, onStatusChange) => {
      if (!cardElement) return false;

      try {
        // 1. Show instructions modal and wait for user confirmation
        const stream = await new Promise((resolve, reject) => {
          const modal = document.getElementById('gif-instructions-modal');
          const startBtn = document.getElementById('start-gif-btn');
          const cancelBtn = document.getElementById('cancel-gif-btn');

          // Update modal text with translations
          const translations = t || (typeof TRANSLATIONS !== 'undefined' ? TRANSLATIONS['en'] : null);

          if (translations && translations.gifModal) {
            const gm = translations.gifModal;
            const titleEl = modal.querySelector('h3');
            if (titleEl) titleEl.textContent = gm.title;

            const bodyEl = modal.querySelector('p');
            if (bodyEl) bodyEl.textContent = gm.body;

            const step1 = modal.querySelector('#gif-modal-step-1');
            const step2 = modal.querySelector('#gif-modal-step-2');
            const step3 = modal.querySelector('#gif-modal-step-3');

            if (step1) step1.innerHTML = gm.step1;
            if (step2) step2.innerHTML = gm.step2;
            if (step3) step3.innerHTML = gm.step3;

            const noteEl = modal.querySelector('.modal-note span:last-child');
            if (noteEl) noteEl.textContent = gm.note;

            if (cancelBtn) cancelBtn.textContent = gm.cancel;
            if (startBtn) startBtn.textContent = gm.start;
          }

          modal.style.display = 'flex';

          const cleanup = () => {
            modal.style.display = 'none';
            startBtn.removeEventListener('click', onStart);
            cancelBtn.removeEventListener('click', onCancel);
          };

          const onStart = async () => {
            cleanup();
            try {
              const s = await navigator.mediaDevices.getDisplayMedia({
                video: {
                  displaySurface: 'browser',
                  cursor: 'never',
                  width: { ideal: 3840 }, // Request 4K resolution
                  height: { ideal: 2160 }
                },
                audio: false,
                preferCurrentTab: true
              });
              resolve(s);
            } catch (err) {
              reject(err);
            }
          };

          const onCancel = () => {
            cleanup();
            reject(new Error('User cancelled'));
          };

          startBtn.addEventListener('click', onStart);
          cancelBtn.addEventListener('click', onCancel);
        });

        // Add capturing class to freeze layout and hide cursor
        document.body.classList.add('is-capturing');
        document.documentElement.classList.add('is-capturing');

        // Create overlay to block mouse
        const overlay = document.createElement('div');
        overlay.id = 'capture-overlay';

        // Brute-force block all mouse events
        const blockEvent = (e) => {
          e.preventDefault();
          e.stopPropagation();
          return false;
        };
        ['mousemove', 'mousedown', 'mouseup', 'click', 'contextmenu', 'dblclick', 'wheel', 'mouseover', 'mouseout'].forEach(event => {
          overlay.addEventListener(event, blockEvent, { capture: true, passive: false });
        });

        document.body.appendChild(overlay);
        if (document.activeElement) document.activeElement.blur(); // Remove focus

        if (onStatusChange) onStatusChange('â³ Loading libs...');

        // 2. Load dependencies
        if (!window.GIF) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        // 3. Setup Video & Canvas
        const video = document.createElement('video');
        video.srcObject = stream;
        video.play();

        // Wait for video dimensions and layout stabilization
        await new Promise(r => video.onloadedmetadata = r);
        await new Promise(r => setTimeout(r, 1000)); // Longer warmup for layout shift

        if (onStatusChange) onStatusChange('ğŸ“¸ Capturing...');

        const workerBlob = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js')
          .then(r => r.blob());
        const workerUrl = URL.createObjectURL(workerBlob);

        // Since we fixed the card to center (50% 50%), we crop the center of the video
        // We target the .game-card specifically to be precise
        const gameCard = document.querySelector('.game-card');
        const rect = gameCard.getBoundingClientRect();

        // Maximum generous padding
        const padding = 0;

        const scaleX = video.videoWidth / window.innerWidth;
        const scaleY = video.videoHeight / window.innerHeight;

        // Calculate crop size based on card size + padding
        const cropW = (rect.width + padding * 2) * scaleX;
        const cropH = (rect.height + padding * 2) * scaleY;

        // Center the crop on the video
        const cropX = (video.videoWidth - cropW) / 2;
        const cropY = (video.videoHeight - cropH) / 2;

        const gif = new GIF({
          workers: 2,
          quality: 1, // Best quality
          workerScript: workerUrl,
          width: cropW,
          height: cropH
        });

        const canvas = document.createElement('canvas');
        canvas.width = cropW;
        canvas.height = cropH;
        const ctx = canvas.getContext('2d');

        // 4. Capture Loop & Promise Wrapper
        return new Promise((resolve, reject) => {
          const frameInterval = 1000 / fps;
          const totalFrames = (duration / 1000) * fps;
          let frameCount = 0;

          const finishCapture = () => {
            // Stop stream
            stream.getTracks().forEach(track => track.stop());
            document.body.classList.remove('is-capturing');
            document.documentElement.classList.remove('is-capturing');
            if (overlay) overlay.remove();

            if (onStatusChange) onStatusChange(t?.download?.encoding || 'âš™ï¸ Encoding...');

            gif.on('finished', (blob) => {
              const link = document.createElement('a');
              link.download = filename + '.gif';
              link.href = URL.createObjectURL(blob);
              link.click();

              URL.revokeObjectURL(link.href);
              URL.revokeObjectURL(workerUrl);
              resolve(true);
            });

            gif.render();
          };

          const captureInterval = setInterval(() => {
            if (frameCount >= totalFrames) {
              clearInterval(captureInterval);
              finishCapture();
              return;
            }

            // Draw cropped video frame to canvas (Center crop)
            ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
            gif.addFrame(canvas, { copy: true, delay: frameInterval });

            frameCount++;
            if (onStatusChange) onStatusChange(`ğŸ“¸ ${Math.round((frameCount / totalFrames) * 100)}%`);
          }, frameInterval);
        });

      } catch (error) {
        console.error('GIF Error:', error);
        document.body.classList.remove('is-capturing');
        document.documentElement.classList.remove('is-capturing');
        const overlay = document.getElementById('capture-overlay');
        if (overlay) overlay.remove();
        throw error; // Re-throw to be handled by caller
      }
    };
    const InputGroup = React.memo(({
      id, label, type = 'text', value, onChange, min, max, step, maxLength, rows, options, style, className = '', disabled = false,
    }) => {
      const inputId = `input-${id}`;
      const handleChange = useCallback((e) => {
        onChange(e.target.value)
      }, [onChange]);
      const renderInput = () => {
        const commonProps = { id: inputId, value, onChange: handleChange, disabled };
        if (options) {
          return (<select {...commonProps}>
            {options.map(opt => (<option key={opt.value} value={opt.value}>
              {opt.label}
            </option>))}
          </select>)
        }
        if (rows) {
          return (<textarea
            {...commonProps}
            rows={rows}
            maxLength={maxLength}
            style={{ resize: 'none' }}
          />)
        }
        if (type === 'color') {
          return (<div className="color-input-wrapper"><input
            {...commonProps}
            type="color"
            className="color-input"
          /><input
              type="text"
              value={value}
              onChange={handleChange}
              placeholder="#RRGGBB"
              className="color-text-input"
              maxLength={7}
            /></div>)
        }
        return (<input
          {...commonProps}
          type={type}
          min={min}
          max={max}
          step={step}
          maxLength={maxLength}
        />)
      };
      return (<div className={`input-group ${className}`} style={style}><label htmlFor={inputId}>{label}</label>
        {renderInput()}
      </div>)
    });
    InputGroup.displayName = 'InputGroup';
    const Checkbox = React.memo(({ id, label, checked, onChange }) => {
      const inputId = `checkbox-${id}`;
      return (<div className="checkbox-group"><input
        type="checkbox"
        id={inputId}
        checked={checked}
        onChange={(e) => onChange(e.target.checked)}
      /><label htmlFor={inputId}>{label}</label></div>)
    });
    Checkbox.displayName = 'Checkbox';
    const AttackEditor = React.memo(({
      index, attack, typeIcon, onUpdate, onRemove, canRemove, t,
    }) => {
      const attackRef = useRef(attack);
      attackRef.current = attack;
      const handleChange = useCallback((field, value) => {
        onUpdate(index, { ...attackRef.current, [field]: value })
      }, [index, onUpdate]);
      const handleNumericChange = useCallback((field, value, min, max) => {
        const parsed = parseIntSafe(value, min);
        handleChange(field, clamp(parsed, min, max))
      }, [handleChange]);
      return (<div className="attack-editor"><div className="attack-header-edit"><h3 className="attack-title">
        {typeIcon} {t.sections.abilities} {index + 1}
      </h3>
        {canRemove && (<button
          type="button"
          className="remove-attack-btn"
          onClick={() => onRemove(index)}
          aria-label={t.buttons.remove}
        >
          âœ•
        </button>)}
      </div><div className="attack-grid"><InputGroup
        id={`attack-${attack.id}-name`}
        label={t.labels.abilityName}
        value={attack.name}
        onChange={(v) => handleChange('name', v)}
        maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
      /><InputGroup
            id={`attack-${attack.id}-damage`}
            label={t.labels.damage}
            type="number"
            value={attack.damage}
            onChange={(v) => handleNumericChange('damage', v, CARD_LIMITS.DAMAGE_MIN, CARD_LIMITS.DAMAGE_MAX)}
          /><InputGroup
            id={`attack-${attack.id}-cost`}
            label={t.labels.energyCost}
            type="number"
            value={attack.cost}
            onChange={(v) => handleNumericChange('cost', v, CARD_LIMITS.COST_MIN, CARD_LIMITS.COST_MAX)}
            min={CARD_LIMITS.COST_MIN}
            max={CARD_LIMITS.COST_MAX}
          /></div><InputGroup
          id={`attack-${attack.id}-desc`}
          label={t.labels.abilityDesc}
          value={attack.desc}
          onChange={(v) => handleChange('desc', v)}
          maxLength={CARD_LIMITS.ATTACK_DESC_MAX_LENGTH}
        /><Checkbox
          id={`attack-${attack.id}-show-damage`}
          label={t.checkboxes.showDamage || 'Afficher les dÃ©gÃ¢ts'}
          checked={attack.showDamage !== false}
          onChange={(v) => handleChange('showDamage', v)}
        /></div>)
    });
    AttackEditor.displayName = 'AttackEditor';
    const RaritySelector = React.memo(({ value, onChange, t }) => (<fieldset className="input-group rarity-fieldset"><legend className="field-legend">{t.labels.rarity}</legend><div className="rarity-selector" role="radiogroup" aria-label={t.labels.rarity}>
      {RARITIES.map(r => (<button
        key={r.key}
        type="button"
        className={`rarity-btn ${value === r.key ? 'active' : ''}`}
        onClick={() => onChange(r.key)}
        role="radio"
        aria-checked={value === r.key}
        style={{ '--rarity-color': r.border }}
      >
        {t.rarities[r.key]}
      </button>))}
    </div></fieldset>));
    RaritySelector.displayName = 'RaritySelector';
    const EffectSelector = React.memo(({ value, onChange, t }) => (<fieldset className="input-group effect-fieldset"><legend className="field-legend">{t.labels.effect}</legend><div className="effect-selector">
      {CARD_EFFECTS.map(effect => (<button
        key={effect}
        type="button"
        className={`effect-btn ${value === effect ? 'active' : ''}`}
        onClick={() => onChange(effect)}
        title={t.effects[effect]?.description || effect}
      >
        {effect === 'none' ? 'âŒ' : effect === 'holographic' ? 'ğŸŒˆ' : effect === 'rainbow' ? 'ğŸ¨' : effect === 'gold' ? 'ğŸ¥‡' : effect === 'silver' ? 'ğŸ¥ˆ' : effect === 'prismatic' ? 'ğŸ’' : effect === 'neon' ? 'ğŸ’¡' : effect === 'galaxy' ? 'ğŸŒŒ' : effect === 'fire' ? 'ğŸ”¥' : effect === 'ice' ? 'â„ï¸' : 'âœ¨'} {t.effects[effect]?.name || effect}
      </button>))}
    </div></fieldset>));
    EffectSelector.displayName = 'EffectSelector';
    const ImageEditor = React.memo(({
      image, settings, onSettingsChange, isLoading, error, onUpload, onClear, t,
    }) => {
      const fileInputRef = useRef(null);
      const containerRef = useRef(null);
      const [isDragging, setIsDragging] = useState(false);
      const [isPanning, setIsPanning] = useState(false);
      const panStart = useRef({ x: 0, y: 0 });
      const offsetStart = useRef({ x: 0, y: 0 });
      const handleDragOver = useCallback((e) => {
        e.preventDefault();
        if (!isPanning) setIsDragging(true)
      }, [isPanning]);
      const handleDragLeave = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false)
      }, []);
      const handleDrop = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false);
        const file = e.dataTransfer.files[0];
        if (file) onUpload(file)
      }, [onUpload]);
      const handleClick = useCallback(() => {
        if (!image) fileInputRef.current?.click()
      }, [image]);
      const handleFileChange = useCallback((e) => {
        const file = e.target.files?.[0];
        if (file) onUpload(file);
        e.target.value = ''
      }, [onUpload]);
      const handleZoomChange = useCallback((value) => {
        const zoom = parseFloatSafe(value, 1);
        const clampedZoom = clamp(zoom, CARD_LIMITS.ZOOM_MIN, CARD_LIMITS.ZOOM_MAX);
        onSettingsChange({
          ...settings, zoom: clampedZoom, offsetX: clamp(settings.offsetX, -(clampedZoom - 1) * 50 - 30, (clampedZoom - 1) * 50 + 30), offsetY: clamp(settings.offsetY, -(clampedZoom - 1) * 50 - 30, (clampedZoom - 1) * 50 + 30)
        })
      }, [settings, onSettingsChange]);
      const handlePanStart = useCallback((e) => {
        if (!image) return;
        e.preventDefault();
        setIsPanning(true);
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        panStart.current = { x: clientX, y: clientY };
        offsetStart.current = { x: settings.offsetX, y: settings.offsetY }
      }, [image, settings.offsetX, settings.offsetY]);
      const handlePanMove = useCallback((e) => {
        if (!isPanning) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const deltaX = clientX - panStart.current.x;
        const deltaY = clientY - panStart.current.y;
        const maxOffset = (settings.zoom - 1) * 50 + 30;
        const newOffsetX = clamp(offsetStart.current.x + deltaX, -maxOffset, maxOffset);
        const newOffsetY = clamp(offsetStart.current.y + deltaY, -maxOffset, maxOffset);
        onSettingsChange({
          zoom: settings.zoom, offsetX: newOffsetX, offsetY: newOffsetY
        })
      }, [isPanning, settings.zoom, onSettingsChange]);
      const handlePanEnd = useCallback(() => {
        setIsPanning(false)
      }, []);
      const handleReset = useCallback(() => {
        onSettingsChange(INITIAL_IMAGE_SETTINGS)
      }, [onSettingsChange]);
      return (<div className="image-editor"><div className="image-editor-header">
        {image && (<div className="image-actions"><button type="button" onClick={() => fileInputRef.current?.click()} className="small-btn">
          {t.buttons.change}
        </button><button type="button" onClick={handleReset} className="small-btn">
            {t.buttons.recenter}
          </button><button type="button" onClick={onClear} className="small-btn danger">
            {t.buttons.remove}
          </button></div>)}
      </div><div
        ref={containerRef}
        className={`image-preview-container ${isDragging ? 'dragging' : ''} ${error ? 'error' : ''} ${image ? 'has-image' : ''}`}
        onClick={handleClick}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onMouseDown={image ? handlePanStart : undefined}
        onMouseMove={image ? handlePanMove : undefined}
        onMouseUp={handlePanEnd}
        onMouseLeave={handlePanEnd}
        onTouchStart={image ? handlePanStart : undefined}
        onTouchMove={image ? handlePanMove : undefined}
        onTouchEnd={handlePanEnd}
        role={image ? "application" : "button"}
        tabIndex={0}
        aria-label={t.imageEditor.dropHint}
      ><input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            accept="image/png,image/jpeg,image/gif,image/webp"
            style={{ display: 'none' }}
            aria-hidden="true"
          />
          {image ? (<div
            className="image-preview"
            style={{ backgroundImage: `url(${image})`, backgroundSize: `${settings.zoom * 100}%`, backgroundPosition: `calc(50% + ${settings.offsetX}px) calc(50% + ${settings.offsetY}px)`, }}
          >
            {isPanning && <div className="pan-overlay">â†”</div>}
          </div>) : (<div className="upload-placeholder"><div className="upload-icon">{isLoading ? 'â³' : 'ğŸ“·'}</div><div className="upload-text">
            {isLoading ? t.imageEditor.loading : error ? error : t.imageEditor.dropHint}
          </div><div className="upload-hint">{t.imageEditor.formats}</div></div>)}
        </div>
        {image && (<div className="image-controls"><div className="zoom-control"><label htmlFor="zoom-slider">{t.labels.zoom}:{(settings.zoom * 100).toFixed(0)}%</label><input
          id="zoom-slider"
          type="range"
          min={CARD_LIMITS.ZOOM_MIN}
          max={CARD_LIMITS.ZOOM_MAX}
          step={0.05}
          value={settings.zoom}
          onChange={(e) => handleZoomChange(e.target.value)}
        /></div></div>)}
      </div>)
    });
    ImageEditor.displayName = 'ImageEditor';
    const getEffectStyles = (effect, mousePos, isHovering) => {
      const x = mousePos.x * 100;
      const y = mousePos.y * 100;
      const angle = Math.atan2(mousePos.y - 0.5, mousePos.x - 0.5) * (180 / Math.PI) + 180;
      if (effect === 'none') {
        return { layer1: {}, layer2: {}, layer3: {}, glow: {}, cardClass: '' }
      }
      const i = isHovering ? 1 : 0.5;
      switch (effect) {
        case 'holographic': return {
          cardClass: 'effect-holographic', layer1: {}, layer2: {
            background: `
            radial-gradient(ellipse 80% 80% at ${x}% ${y}%,hsla(${angle},70%,70%, ${0.5 * i}) 0%,hsla(${angle + 60},70%,65%, ${0.4 * i}) 25%,hsla(${angle + 120},70%,65%, ${0.35 * i}) 50%,transparent 75%)
          `, mixBlendMode: 'color'
          }, layer3: {
            background: `
            radial-gradient(circle at ${x}% ${y}%,rgba(255,255,255,${0.25 * i}) 0%,transparent 30%),radial-gradient(circle at ${100 - x}% ${100 - y}%,hsla(${angle + 180},60%,75%, ${0.3 * i}) 0%,transparent 40%)
          `, mixBlendMode: 'overlay'
          }, glow: {
            boxShadow: `0 0 ${10 * i}px hsla(${angle},80%,70%, ${0.4 * i}),0 0 ${20 * i}px hsla(${angle + 120},80%,70%, ${0.3 * i})`
          }
        };
        case 'rainbow': const rainbowOffset = mousePos.x * 100;
          return {
            cardClass: 'effect-rainbow', layer1: {}, layer2: {
              background: `
            repeating-linear-gradient(${90 + (mousePos.y - 0.5) * 30}deg,rgba(255,0,0,${0.4 * i}) 0%,rgba(255,127,0,${0.4 * i}) 8%,rgba(255,255,0,${0.4 * i}) 16%,rgba(0,255,0,${0.4 * i}) 24%,rgba(0,127,255,${0.4 * i}) 32%,rgba(127,0,255,${0.4 * i}) 40%,rgba(255,0,127,${0.4 * i}) 48%,rgba(255,0,0,${0.4 * i}) 56%)
          `, backgroundSize: '200% 200%', backgroundPosition: `${rainbowOffset}% 0%`, mixBlendMode: 'color'
            }, layer3: {}, glow: {
              boxShadow: `0 0 ${12 * i}px rgba(255,0,0,${0.3 * i}),0 0 ${20 * i}px rgba(0,255,0,${0.25 * i}),0 0 ${25 * i}px rgba(0,0,255,${0.2 * i})`
            }
          };
        case 'prismatic': {
          const beam1 = angle;
          const beam2 = angle + 60;
          const beam3 = angle + 120;
          return {
            cardClass: 'effect-prismatic', layer1: {}, layer2: {
              background: `
            linear-gradient(${beam1}deg,transparent 20%,rgba(255,0,0,${0.35 * i}) 35%,rgba(255,255,0,${0.4 * i}) 50%,rgba(0,255,0,${0.35 * i}) 65%,transparent 80%),linear-gradient(${beam2}deg,transparent 25%,rgba(0,255,255,${0.3 * i}) 40%,rgba(0,100,255,${0.35 * i}) 50%,rgba(100,0,255,${0.3 * i}) 60%,transparent 75%),linear-gradient(${beam3}deg,transparent 30%,rgba(255,0,255,${0.25 * i}) 45%,rgba(255,100,100,${0.3 * i}) 55%,transparent 70%)
          `, mixBlendMode: 'screen'
            }, layer3: { background: `radial-gradient(circle at ${x}% ${y}%,rgba(255,255,255,${0.3 * i}) 0%,transparent 25%)`, mixBlendMode: 'overlay' }, glow: {
              boxShadow: `0 0 ${15 * i}px rgba(255,0,255,${0.4 * i}),0 0 ${25 * i}px rgba(0,255,255,${0.35 * i}),0 0 ${35 * i}px rgba(255,255,0,${0.3 * i})`
            }
          }
        }
        case 'gold': {
          return { layer1: {}, layer2: {}, layer3: {}, glow: {}, cardClass: '' };
        }
        case 'silver': {
          return { layer1: {}, layer2: {}, layer3: {}, glow: {}, cardClass: '' };
        }
        case 'neon': {
          const hue = (mousePos.x * 360 + mousePos.y * 60) % 360;
          const hue2 = (hue + 120) % 360;
          const hue3 = (hue + 240) % 360;
          return {
            cardClass: 'effect-neon', layer1: {}, layer2: {
              background: `
            radial-gradient(ellipse 100% 60% at ${x}% ${y}%,hsla(${hue},100%,55%, ${0.7 * i}) 0%,hsla(${hue},100%,50%, ${0.3 * i}) 40%,transparent 70%),radial-gradient(ellipse 80% 50% at ${100 - x}% ${100 - y}%,hsla(${hue2},100%,55%, ${0.5 * i}) 0%,transparent 50%)
          `, mixBlendMode: 'screen'
            }, layer3: {
              background: `
            radial-gradient(circle at ${20 + mousePos.x * 25}% ${20 + mousePos.y * 25}%,hsla(${hue},100%,70%, ${0.8 * i}) 0%,transparent 20%),radial-gradient(circle at ${80 - mousePos.x * 25}% ${80 - mousePos.y * 25}%,hsla(${hue2},100%,70%, ${0.7 * i}) 0%,transparent 18%),radial-gradient(circle at ${50}% ${50}%,hsla(${hue3},100%,65%, ${0.4 * i}) 0%,transparent 30%)
          `, mixBlendMode: 'screen'
            }, glow: {
              boxShadow: `0 0 ${15 * i}px hsla(${hue},100%,50%, ${0.7 * i}),0 0 ${35 * i}px hsla(${hue2},100%,50%, ${0.5 * i}),0 0 ${50 * i}px hsla(${hue3},100%,50%, ${0.3 * i}),inset 0 0 ${20 * i}px hsla(${hue},100%,60%, ${0.15 * i})`
            }
          }
        }
        case 'galaxy': {
          const starX = (n) => (17 * n + mousePos.x * 35) % 100;
          const starY = (n) => (23 * n + mousePos.y * 30) % 100;
          return {
            cardClass: 'effect-galaxy', layer1: {}, layer2: {
              background: `
            radial-gradient(ellipse 70% 50% at ${25 + mousePos.x * 50}% ${15 + mousePos.y * 35}%,rgba(120,40,200,${0.7 * i}) 0%,rgba(80,20,160,${0.4 * i}) 40%,transparent 70%),radial-gradient(ellipse 60% 45% at ${75 - mousePos.x * 40}% ${85 - mousePos.y * 35}%,rgba(60,30,180,${0.6 * i}) 0%,rgba(40,15,120,${0.35 * i}) 45%,transparent 70%),radial-gradient(ellipse 50% 40% at ${x}% ${y}%,rgba(180,80,255,${0.5 * i}) 0%,transparent 50%),linear-gradient(180deg,rgba(20,10,60,${0.3 * i}) 0%,transparent 30%,transparent 70%,rgba(30,15,80,${0.25 * i}) 100%)
          `, mixBlendMode: 'screen'
            }, layer3: {
              background: `
            radial-gradient(circle at ${starX(1)}% ${starY(1)}%,rgba(255,255,255,${1 * i}) 0%,rgba(200,180,255,${0.5 * i}) 2%,transparent 4%),radial-gradient(circle at ${starX(2)}% ${starY(2)}%,rgba(255,220,255,${0.95 * i}) 0%,transparent 3%),radial-gradient(circle at ${starX(3)}% ${starY(3)}%,rgba(200,200,255,${0.9 * i}) 0%,transparent 3.5%),radial-gradient(circle at ${starX(4)}% ${starY(4)}%,rgba(255,255,200,${0.85 * i}) 0%,transparent 2.5%),radial-gradient(circle at ${starX(5)}% ${starY(5)}%,rgba(255,180,255,${0.9 * i}) 0%,transparent 3%),radial-gradient(circle at ${starX(6)}% ${starY(6)}%,rgba(180,180,255,${0.85 * i}) 0%,transparent 2%),radial-gradient(circle at ${starX(7)}% ${starY(7)}%,rgba(255,255,255,${0.95 * i}) 0%,transparent 4%),radial-gradient(circle at ${starX(8)}% ${starY(8)}%,rgba(255,200,200,${0.8 * i}) 0%,transparent 2.5%),radial-gradient(circle at ${starX(9)}% ${starY(9)}%,rgba(200,255,255,${0.85 * i}) 0%,transparent 2%),radial-gradient(circle at ${starX(10)}% ${starY(10)}%,rgba(255,255,180,${0.9 * i}) 0%,transparent 3%)
          `, mixBlendMode: 'screen'
            }, glow: {
              boxShadow: `0 0 ${20 * i}px rgba(140,60,255,${0.5 * i}),0 0 ${40 * i}px rgba(100,30,200,${0.4 * i}),0 0 ${60 * i}px rgba(60,20,150,${0.3 * i})`
            }
          }
        }
        case 'fire': {
          const flameY = 100 - (mousePos.y * 25);
          const flicker = Math.sin(Date.now() / 100) * 5;
          return {
            cardClass: 'effect-fire', layer1: {}, layer2: {
              background: `
            radial-gradient(ellipse 90% 60% at ${x}% ${flameY}%,rgba(255,255,100,${0.8 * i}) 0%,rgba(255,200,0,${0.6 * i}) 20%,rgba(255,100,0,${0.5 * i}) 40%,rgba(255,50,0,${0.3 * i}) 60%,transparent 80%),radial-gradient(ellipse 70% 50% at ${50 + (mousePos.x - 0.5) * 25}% 90%,rgba(255,150,0,${0.7 * i}) 0%,rgba(255,80,0,${0.5 * i}) 40%,transparent 70%),linear-gradient(0deg,rgba(255,100,0,${0.5 * i}) 0%,rgba(255,50,0,${0.3 * i}) 20%,transparent 50%)
          `, mixBlendMode: 'screen'
            }, layer3: {
              background: `
            radial-gradient(circle at ${30 + mousePos.x * 20}% ${65 - mousePos.y * 15}%,rgba(255,255,150,${1 * i}) 0%,rgba(255,200,50,${0.5 * i}) 5%,transparent 10%),radial-gradient(circle at ${70 - mousePos.x * 15}% ${60 + mousePos.y * 10}%,rgba(255,220,80,${0.9 * i}) 0%,transparent 8%),radial-gradient(circle at ${50 + mousePos.x * 25}% ${70 - mousePos.y * 20}%,rgba(255,180,0,${0.85 * i}) 0%,transparent 9%),radial-gradient(circle at ${40 - mousePos.x * 20}% ${75 + mousePos.y * 10}%,rgba(255,150,50,${0.8 * i}) 0%,transparent 7%),radial-gradient(circle at ${60 + mousePos.x * 15}% ${55 - mousePos.y * 15}%,rgba(255,200,100,${0.85 * i}) 0%,transparent 8%)
          `, mixBlendMode: 'screen'
            }, glow: {
              boxShadow: `0 0 ${20 * i}px rgba(255,150,0,${0.7 * i}),0 0 ${40 * i}px rgba(255,100,0,${0.5 * i}),0 0 ${60 * i}px rgba(255,50,0,${0.35 * i}),0 ${10 * i}px ${25 * i}px rgba(255,100,0,${0.4 * i})`
            }
          }
        }
        case 'ice': {
          const crystalX = (n) => (19 * n + mousePos.x * 30) % 100;
          const crystalY = (n) => (29 * n + mousePos.y * 25) % 100;
          return {
            cardClass: 'effect-ice', layer1: {}, layer2: {
              background: `
            radial-gradient(ellipse 100% 70% at ${x}% ${y}%,rgba(180,230,255,${0.5 * i}) 0%,rgba(140,200,255,${0.35 * i}) 30%,transparent 60%),linear-gradient(${angle}deg,transparent 20%,rgba(200,240,255,${0.4 * i}) 45%,rgba(230,250,255,${0.5 * i}) 50%,rgba(200,240,255,${0.4 * i}) 55%,transparent 80%),linear-gradient(${angle + 60}deg,transparent 30%,rgba(180,230,255,${0.3 * i}) 50%,transparent 70%),linear-gradient(${angle + 120}deg,transparent 35%,rgba(160,220,255,${0.25 * i}) 50%,transparent 65%)
          `, mixBlendMode: 'hard-light'
            }, layer3: {
              background: `
            radial-gradient(circle at ${crystalX(1)}% ${crystalY(1)}%,rgba(255,255,255,${1 * i}) 0%,rgba(200,240,255,${0.6 * i}) 3%,transparent 6%),radial-gradient(circle at ${crystalX(2)}% ${crystalY(2)}%,rgba(230,250,255,${0.95 * i}) 0%,transparent 5%),radial-gradient(circle at ${crystalX(3)}% ${crystalY(3)}%,rgba(255,255,255,${0.9 * i}) 0%,transparent 4%),radial-gradient(circle at ${crystalX(4)}% ${crystalY(4)}%,rgba(200,240,255,${0.85 * i}) 0%,transparent 5.5%),radial-gradient(circle at ${crystalX(5)}% ${crystalY(5)}%,rgba(255,255,255,${0.95 * i}) 0%,transparent 3.5%),radial-gradient(circle at ${crystalX(6)}% ${crystalY(6)}%,rgba(220,250,255,${0.9 * i}) 0%,transparent 4.5%),radial-gradient(circle at ${crystalX(7)}% ${crystalY(7)}%,rgba(255,255,255,${0.85 * i}) 0%,transparent 3%),radial-gradient(circle at ${crystalX(8)}% ${crystalY(8)}%,rgba(180,230,255,${0.8 * i}) 0%,transparent 5%)
          `, mixBlendMode: 'overlay'
            }, glow: {
              boxShadow: `0 0 ${15 * i}px rgba(150,220,255,${0.55 * i}),0 0 ${35 * i}px rgba(100,200,255,${0.4 * i}),0 0 ${50 * i}px rgba(180,240,255,${0.3 * i}),inset 0 0 ${15 * i}px rgba(200,240,255,${0.1 * i})`
            }
          }
        }
        default: return { layer1: {}, layer2: {}, layer3: {}, glow: {}, cardClass: '' }
      }
    };
    const Card = React.memo(({
      cardData, attacks, image, imageSettings, mousePos, isHovering, cardRef, onMouseMove, onMouseEnter, onMouseLeave, autoRotate, t
    }) => {
      const typeData = ELEMENT_TYPES[cardData.type] || ELEMENT_TYPES.Neutral;
      const weaknessData = ELEMENT_TYPES[cardData.weakness] || ELEMENT_TYPES.Neutral;
      const resistanceData = ELEMENT_TYPES[cardData.resistance] || ELEMENT_TYPES.Neutral;
      const rarityData = RARITIES.find(r => r.key === cardData.rarity) || RARITIES[0];
      const fontData = FONTS.find(f => f.id === cardData.font) || FONTS[0];
      const borderColor = cardData.borderColor || rarityData.border;
      const backgroundColor = cardData.backgroundColor || '';
      const textColor = cardData.textColor || '#1a1a2e';
      const cardStyle = useMemo(() => {
        const capturing = document.body.classList.contains('is-capturing');
        return {
          transform: (isHovering && !capturing) ? `perspective(1000px) rotateY(${(mousePos.x - 0.5) * 15}deg) rotateX(${(0.5 - mousePos.y) * 15}deg) scale(1.02)` : 'perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)',
          transition: autoRotate ? 'none' : 'transform 0.12s ease-out'
        }
      }, [isHovering, mousePos.x, mousePos.y, autoRotate]);
      const effectStyles = useMemo(() => {
        if (document.body.classList.contains('is-capturing')) {
          return { layer1: {}, layer2: {}, layer3: {}, glow: {}, cardClass: '' };
        }
        return getEffectStyles(cardData.effect, mousePos, isHovering);
      }, [cardData.effect, mousePos, isHovering]);
      const imageStyle = useMemo(() => {
        const baseStyle = { borderColor: typeData.primary };
        if (image) {
          return {
            ...baseStyle, backgroundImage: `url(${image})`, backgroundSize: `${imageSettings.zoom * 100}%`, backgroundPosition: `calc(50% + ${imageSettings.offsetX}px) calc(50% + ${imageSettings.offsetY}px)`, backgroundRepeat: 'no-repeat'
          }
        }
        return {
          ...baseStyle, background: `linear-gradient(135deg, ${typeData.primary}40, ${typeData.secondary}40)`
        }
      }, [image, imageSettings, typeData.primary, typeData.secondary]);
      const cardGradient = useMemo(() => {
        if (backgroundColor) {
          return backgroundColor
        }
        return `linear-gradient(135deg, ${typeData.primary} 0%, ${typeData.secondary} 50%, ${typeData.primary} 100%)`
      }, [backgroundColor, typeData.primary, typeData.secondary]);
      return (<div
        ref={cardRef}
        className="card-container"
        style={cardStyle}
        onMouseMove={onMouseMove}
        onMouseEnter={onMouseEnter}
        onMouseLeave={onMouseLeave}
      ><div
        className={`game-card ${effectStyles.cardClass || ''}`}
        style={{
          background: cardGradient, borderColor: borderColor, fontFamily: fontData.family,
          ...effectStyles.glow,
        }}
      >
          {/* Inner card frame */}
          <div className="card-inner" style={{ color: textColor }}>
            {/* Header */}
            <div className="card-header"><div className="card-header-left"><span className="stage-badge" style={{ background: typeData.primary }}>
              {t.stages[STAGES.indexOf(cardData.stage)] || cardData.stage}
            </span><span className="creature-name">{cardData.name}</span></div>
              {cardData.showHP && (<div className="card-header-right"><span className="hp-value">{t.card.hp} {cardData.hp}</span><span className="type-icon">{typeData.icon}</span></div>)}
            </div>
            {/* Image */}
            <div className="card-image" style={imageStyle}>
              {!image && (<span className="placeholder-icon">{typeData.icon}</span>)}
            </div>
            {/* Description bar */}
            {cardData.showDescription && cardData.description && (<div className="card-description">{cardData.description}</div>)}
            {/* Attacks */}
            <div className="attacks-container">
              {attacks.map((attack) => (<div key={attack.id} className="attack-card"><div className="attack-header"><div className="attack-cost">
                {[...Array(Math.max(0, Math.min(10, attack.cost)))].map((_, i) => (<span key={i} className="energy-icon">{typeData.icon}</span>))}
              </div><span className="attack-name">{attack.name}</span>{attack.showDamage !== false && <span className="attack-damage">{attack.damage}</span>}</div>
                {attack.desc && <div className="attack-desc">{attack.desc}</div>}
              </div>))}
            </div>
            {/* Footer */}
            <div className="card-footer">
              {cardData.showWeakRes && (<div className="footer-stats"><div className="stat"><span className="stat-label">{t.card.weakness} </span><span className="stat-icon">{weaknessData.icon}</span><span className="stat-value weakness"> Ã—2</span></div><div className="stat"><span className="stat-label">{t.card.resistance} </span><span className="stat-icon">{resistanceData.icon}</span><span className="stat-value resistance"> -30</span></div></div>)}
              {cardData.showRetreat && (<div className="retreat-cost"><span className="stat-label">{t.card.cost} </span>
                {[...Array(Math.max(0, cardData.retreatCost))].map((_, i) => (<span key={i} className="retreat-icon">âšª</span>))}
              </div>)}
            </div>
            {/* Author */}
            <div className="card-author">
              {t.card.illus} {cardData.author} â€¢ Card Creator
            </div></div>
          {/* Element texture layer */}
          {cardData.showTexture && (<div
            className="texture-layer"
            style={{ backgroundImage: ELEMENT_TEXTURES[cardData.type], backgroundSize: '60px 60px', }}
          />)}
          {/* Effect layers */}
          <div className="effect-layer layer-1" style={effectStyles.layer1} /><div className="effect-layer layer-2" style={effectStyles.layer2} /><div className="effect-layer layer-3" style={effectStyles.layer3} />
          {/* Particles layer */}
          {cardData.showParticles && (<div className={`particles-layer particles-${cardData.type.toLowerCase()}`}>
            {[...Array(ELEMENT_PARTICLES[cardData.type]?.count || 5)].map((_, i) => (<span
              key={i}
              className={`particle particle-${i % 3}`}
              style={{
                left: `${3 + (i * 31) % 94}%`,
                top: `${2 + (i * 37) % 96}%`,
                animationDelay: `${i * 0.5}s`,
                animationDuration: `${3 + (i % 4) * 0.5}s`,
              }}
            >
              {i % 2 === 0 ? ELEMENT_PARTICLES[cardData.type]?.emoji : ELEMENT_PARTICLES[cardData.type]?.alt[i % 2]}
            </span>))}
          </div>)}
          {/* Rarity indicator */}
          {(cardData.rarity === 'legendary' || cardData.rarity === 'mythic') && (<div className={`rarity-indicator ${cardData.rarity}`}>
            {cardData.rarity === 'mythic' ? 'ğŸŒŸ' : 'â­'}
          </div>)}
          {cardData.rarity === 'epic' && (<div className="rarity-indicator epic">ğŸ’œ</div>)}
        </div></div>)
    });
    Card.displayName = 'Card';
    const CollapsibleSection = React.memo(({ title, icon, children, defaultOpen = true, isOpen: controlledIsOpen, onToggle }) => {
      const [internalIsOpen, setInternalIsOpen] = useState(defaultOpen);
      const isControlled = controlledIsOpen !== undefined;
      const isOpen = isControlled ? controlledIsOpen : internalIsOpen;

      const handleToggle = () => {
        if (isControlled) {
          onToggle && onToggle();
        } else {
          setInternalIsOpen(!internalIsOpen);
        }
      };

      return (<div className={`collapsible-section ${isOpen ? 'open' : ''}`}><button
        type="button"
        className="collapsible-header"
        onClick={handleToggle}
        aria-expanded={isOpen}
      ><span>{icon} {title}</span><span className="collapse-icon">{isOpen ? 'â–¼' : 'â–¶'}</span></button>
        {isOpen && <div className="collapsible-content">{children}</div>}
      </div>)
    });
    CollapsibleSection.displayName = 'CollapsibleSection';

    function CardCreatorContent() {
      const { t, lang } = useLanguage();
      const [cardData, setCardData] = useState(INITIAL_CARD_DATA);
      const [attacks, setAttacks] = useState(INITIAL_ATTACKS);
      const [image, setImage] = useState(null);
      const [imageSettings, setImageSettings] = useState(INITIAL_IMAGE_SETTINGS);
      const [imageLoading, setImageLoading] = useState(false);
      const [imageError, setImageError] = useState(null);
      const [mousePos, setMousePos] = useState({ x: 0.5, y: 0.5 });
      const [isHovering, setIsHovering] = useState(false);
      const [autoRotate, setAutoRotate] = useState(true);
      const [activeTab, setActiveTab] = useState('visual');
      const [openSection, setOpenSection] = useState('image'); // Default open section for visual tab
      const cardRef = useRef(null);
      const autoRotateRef = useRef(null);
      useEffect(() => {
        const modal = document.getElementById('gif-instructions-modal');
        if (modal && t && t.gifModal) {
          const gm = t.gifModal;
          const titleEl = modal.querySelector('h3');
          if (titleEl) titleEl.textContent = gm.title;

          const bodyEl = modal.querySelector('p');
          if (bodyEl) bodyEl.textContent = gm.body;

          const step1 = modal.querySelector('#gif-modal-step-1');
          if (step1) step1.innerHTML = gm.step1;
          const step2 = modal.querySelector('#gif-modal-step-2');
          if (step2) step2.innerHTML = gm.step2;
          const step3 = modal.querySelector('#gif-modal-step-3');
          if (step3) step3.innerHTML = gm.step3;

          const noteEl = modal.querySelector('.modal-note span:last-child');
          if (noteEl) noteEl.textContent = gm.note;

          const cancelBtn = document.getElementById('cancel-gif-btn');
          if (cancelBtn) cancelBtn.textContent = gm.cancel;
          const startBtn = document.getElementById('start-gif-btn');
          if (startBtn) startBtn.textContent = gm.start;
        }
      }, [t]);

      useEffect(() => {
        const capturing = document.body.classList.contains('is-capturing');
        if (autoRotate && !capturing) {
          let angle = 0;
          setIsHovering(true); // Active l'effet 3D
          autoRotateRef.current = setInterval(() => {
            angle += 0.02; // Mouvement plus lent et fluide
            const x = 0.5 + Math.sin(angle) * 0.35;
            const y = 0.5 + Math.sin(angle * 2) * 0.25;
            setMousePos({ x, y })
          }, 40)
        } else {
          if (autoRotateRef.current) {
            clearInterval(autoRotateRef.current);
            autoRotateRef.current = null
          }
          setIsHovering(false);
          setMousePos({ x: 0.5, y: 0.5 })
        }
        return () => {
          if (autoRotateRef.current) {
            clearInterval(autoRotateRef.current)
          }
        }
      }, [autoRotate]);
      const handleMouseEnterManual = useCallback(() => {
        if (document.body.classList.contains('is-capturing')) return;
        if (autoRotate && autoRotateRef.current) {
          clearInterval(autoRotateRef.current);
          autoRotateRef.current = null
        }
        setIsHovering(true)
      }, [autoRotate]);
      const handleMouseLeaveManual = useCallback(() => {
        if (document.body.classList.contains('is-capturing')) return;
        if (autoRotate) {
          let angle = 0;
          autoRotateRef.current = setInterval(() => {
            angle += 0.02;
            const x = 0.5 + Math.sin(angle) * 0.35;
            const y = 0.5 + Math.sin(angle * 2) * 0.25;
            setMousePos({ x, y })
          }, 40);
          setIsHovering(true); // Garder l'effet 3D actif
        } else {
          setIsHovering(false);
          setMousePos({ x: 0.5, y: 0.5 })
        }
      }, [autoRotate]);
      const updateCardData = useCallback((field, value) => {
        setCardData(prev => ({ ...prev, [field]: value }))
      }, []);
      const updateCardDataNumeric = useCallback((field, value, min, max) => {
        const parsed = parseIntSafe(value, min);
        setCardData(prev => ({ ...prev, [field]: clamp(parsed, min, max) }))
      }, []);
      const updateAttack = useCallback((index, newAttack) => {
        setAttacks(prev => prev.map((a, i) => i === index ? newAttack : a))
      }, []);
      const addAttack = useCallback(() => {
        if (attacks.length >= 3) return;
        setAttacks(prev => [...prev, { id: generateId(), name: t.defaults.newAbility, damage: 50, cost: 2, desc: '', showDamage: true }])
      }, [attacks.length, t]);
      const removeAttack = useCallback((index) => {
        if (attacks.length <= 1) return;
        setAttacks(prev => prev.filter((_, i) => i !== index))
      }, [attacks.length]);
      const processImageFile = useCallback((file) => {
        if (!file) return;
        const validTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
        if (!validTypes.includes(file.type)) {
          setImageError(t.imageEditor.unsupportedFormat);
          return
        }
        if (file.size > CARD_LIMITS.MAX_FILE_SIZE) {
          setImageError(t.imageEditor.fileTooLarge);
          return
        }
        setImageLoading(true);
        setImageError(null);
        const reader = new FileReader();
        reader.onload = (e) => {
          setImage(e.target.result);
          setImageSettings(INITIAL_IMAGE_SETTINGS);
          setImageLoading(false)
        };
        reader.onerror = () => {
          setImageError('Error');
          setImageLoading(false)
        };
        reader.readAsDataURL(file)
      }, [t]);
      const clearImage = useCallback(() => {
        setImage(null);
        setImageSettings(INITIAL_IMAGE_SETTINGS);
        setImageError(null)
      }, []);
      const handleMouseMoveThrottled = useCallback((e) => {
        if (document.body.classList.contains('is-capturing')) return;
        if (!cardRef.current) return;
        const rect = cardRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        setMousePos({ x: clamp(x, 0, 1), y: clamp(y, 0, 1) })
      }, []);
      const handleMouseMove = useThrottle(handleMouseMoveThrottled, 16);
      const typeOptions = useMemo(() => ELEMENT_KEYS.map(type => ({
        value: type, label: `${ELEMENT_TYPES[type].icon} ${t.elements[type] || type}`
      })),
        [t]);
      const stageOptions = useMemo(() => STAGES.map((stage, index) => ({
        value: stage, label: t.stages[index] || stage
      })),
        [t]);
      const fontOptions = useMemo(() => FONTS.map(font => ({ value: font.id, label: font.name })),
        []);
      const typeIcon = ELEMENT_TYPES[cardData.type]?.icon || 'â­';
      return (<div className="app-container"><h1 className="title">âœ¨ {t.appTitle} âœ¨</h1><p className="subtitle">{t.appSubtitle}</p><div className="main-layout">
        {/* Card Preview */}
        <div className="card-preview"><Card
          cardData={cardData}
          attacks={attacks}
          image={image}
          imageSettings={imageSettings}
          mousePos={mousePos}
          isHovering={isHovering}
          cardRef={cardRef}
          onMouseMove={handleMouseMove}
          onMouseEnter={handleMouseEnterManual}
          onMouseLeave={handleMouseLeaveManual}
          autoRotate={autoRotate}
          t={t}
        /><p className="hover-hint">{t.hoverHint}</p>
          {/* Auto Rotate Button */}
          <button
            className={`auto-rotate-btn ${autoRotate ? 'active' : ''}`}
            onClick={() => setAutoRotate(!autoRotate)}
          >
            {autoRotate ? 'â¸ï¸' : 'â–¶ï¸'} {t.buttons.autoRotate}
          </button>
          {/* Download Section */}
          <div className="download-section"><p className="download-title">{t.download.title}</p><div className="download-buttons"><button
            className="download-btn download-png"
            onClick={() => downloadAsPNG(cardRef.current, cardData.name || 'card')}
            title={t.download.pngTitle}
          >
            ğŸ–¼ï¸ PNG
          </button><button
            className="download-btn download-jpg"
            onClick={() => downloadAsJPG(cardRef.current, cardData.name || 'card')}
            title={t.download.jpgTitle}
          >
              ğŸ“· JPG
            </button><button
              className="download-btn download-gif"
              onClick={async (e) => {
                const btn = e.currentTarget;
                const originalText = btn.textContent;

                // Debug translation
                console.log('GIF Click - Lang:', lang, 'Capturing text:', t.download.capturing);

                try {
                  btn.textContent = t.download.capturing;
                  btn.disabled = true;
                  await downloadAsGIF(
                    cardRef.current,
                    cardData.name || 'card',
                    3000,
                    10,
                    t,
                    (text) => { btn.textContent = text; }
                  );
                } catch (err) {
                  console.log('GIF capture cancelled or failed:', err);
                } finally {
                  btn.textContent = originalText;
                  btn.disabled = false;
                }
              }}
              title={t.download.gifTitle}
            >
              ğŸ¬ GIF
            </button></div></div></div>
        {/* Editor Panel */}
        <div className="editor-panel">
          <div className="editor-tabs">
            <button
              className={`tab-btn ${activeTab === 'visual' ? 'active' : ''}`}
              onClick={() => { setActiveTab('visual'); setOpenSection('image'); }}
            >
              ğŸ¨ {t.tabs.visual}
            </button>
            <button
              className={`tab-btn ${activeTab === 'info' ? 'active' : ''}`}
              onClick={() => { setActiveTab('info'); setOpenSection('basicInfo'); }}
            >
              ğŸ“ {t.tabs.info}
            </button>
            <button
              className={`tab-btn ${activeTab === 'combat' ? 'active' : ''}`}
              onClick={() => { setActiveTab('combat'); setOpenSection('abilities'); }}
            >
              âš”ï¸ {t.tabs.combat}
            </button>
          </div>

          <div className="tab-content">
            {activeTab === 'info' && (
              <>
                <CollapsibleSection
                  title={t.sections.basicInfo}
                  icon="ğŸ“"
                  isOpen={openSection === 'basicInfo'}
                  onToggle={() => setOpenSection(openSection === 'basicInfo' ? null : 'basicInfo')}
                >
                  <div className="grid-2">
                    <InputGroup
                      id="creature-name"
                      label={t.labels.name}
                      value={cardData.name}
                      onChange={(v) => updateCardData('name', v)}
                      maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
                    />
                    <InputGroup
                      id="creature-hp"
                      label={t.labels.hp}
                      type="number"
                      value={cardData.hp}
                      onChange={(v) => updateCardDataNumeric('hp', v, CARD_LIMITS.HP_MIN, CARD_LIMITS.HP_MAX)}
                      min={CARD_LIMITS.HP_MIN}
                      max={CARD_LIMITS.HP_MAX}
                    />
                  </div>
                  <div className="grid-2">
                    <InputGroup
                      id="creature-type"
                      label={t.labels.element}
                      value={cardData.type}
                      onChange={(v) => updateCardData('type', v)}
                      options={typeOptions}
                    />
                    <InputGroup
                      id="creature-stage"
                      label={t.labels.stage}
                      value={cardData.stage}
                      onChange={(v) => updateCardData('stage', v)}
                      options={stageOptions}
                    />
                  </div>
                  <InputGroup
                    id="creature-description"
                    label={t.labels.description}
                    value={cardData.description}
                    onChange={(v) => updateCardData('description', v)}
                    rows={2}
                    maxLength={CARD_LIMITS.DESC_MAX_LENGTH}
                  />
                  <InputGroup
                    id="creature-author"
                    label={t.labels.author}
                    value={cardData.author}
                    onChange={(v) => updateCardData('author', v)}
                    maxLength={CARD_LIMITS.AUTHOR_MAX_LENGTH}
                  />
                </CollapsibleSection>

                <CollapsibleSection
                  title={t.sections.stats}
                  icon="ğŸ“Š"
                  isOpen={openSection === 'stats'}
                  onToggle={() => setOpenSection(openSection === 'stats' ? null : 'stats')}
                >
                  <div className="grid-3">
                    <InputGroup
                      id="creature-weakness"
                      label={t.labels.weakness}
                      value={cardData.weakness}
                      onChange={(v) => updateCardData('weakness', v)}
                      options={typeOptions}
                    />
                    <InputGroup
                      id="creature-resistance"
                      label={t.labels.resistance}
                      value={cardData.resistance}
                      onChange={(v) => updateCardData('resistance', v)}
                      options={typeOptions}
                    />
                    <InputGroup
                      id="creature-retreat"
                      label={t.labels.retreatCost}
                      type="number"
                      value={cardData.retreatCost}
                      onChange={(v) => updateCardDataNumeric('retreatCost', v, CARD_LIMITS.RETREAT_MIN, CARD_LIMITS.RETREAT_MAX)}
                      min={CARD_LIMITS.RETREAT_MIN}
                      max={CARD_LIMITS.RETREAT_MAX}
                    />
                  </div>
                </CollapsibleSection>
              </>
            )}

            {activeTab === 'combat' && (
              <CollapsibleSection
                title={t.sections.abilities}
                icon="âš”ï¸"
                isOpen={openSection === 'abilities'}
                onToggle={() => setOpenSection(openSection === 'abilities' ? null : 'abilities')}
              >
                {attacks.map((attack, idx) => (
                  <AttackEditor
                    key={attack.id}
                    index={idx}
                    attack={attack}
                    typeIcon={typeIcon}
                    onUpdate={updateAttack}
                    onRemove={removeAttack}
                    canRemove={attacks.length > 1}
                    t={t}
                  />
                ))}
                <button
                  type="button"
                  className="add-attack-btn"
                  onClick={addAttack}
                  disabled={attacks.length >= 3}
                >
                  {t.buttons.addAbility} {attacks.length >= 3 && '(max 3)'}
                </button>
              </CollapsibleSection>
            )}

            {activeTab === 'visual' && (
              <>
                <CollapsibleSection
                  title={t.sections.image}
                  icon="ğŸ“·"
                  isOpen={openSection === 'image'}
                  onToggle={() => setOpenSection(openSection === 'image' ? null : 'image')}
                >
                  <ImageEditor
                    image={image}
                    settings={imageSettings}
                    onSettingsChange={setImageSettings}
                    isLoading={imageLoading}
                    error={imageError}
                    onUpload={processImageFile}
                    onClear={clearImage}
                    t={t}
                  />
                </CollapsibleSection>

                <CollapsibleSection
                  title={t.sections.rarityEffects}
                  icon="âœ¨"
                  isOpen={openSection === 'rarityEffects'}
                  onToggle={() => setOpenSection(openSection === 'rarityEffects' ? null : 'rarityEffects')}
                >
                  <RaritySelector
                    value={cardData.rarity}
                    onChange={(v) => updateCardData('rarity', v)}
                    t={t}
                  />
                  <div style={{ marginTop: '12px' }}>
                    <EffectSelector
                      value={cardData.effect}
                      onChange={(v) => updateCardData('effect', v)}
                      t={t}
                    />
                  </div>
                </CollapsibleSection>

                <CollapsibleSection
                  title={t.sections.appearance}
                  icon="ğŸ¨"
                  isOpen={openSection === 'appearance'}
                  onToggle={() => setOpenSection(openSection === 'appearance' ? null : 'appearance')}
                >
                  <InputGroup
                    id="card-font"
                    label={t.labels.font}
                    value={cardData.font}
                    onChange={(v) => updateCardData('font', v)}
                    options={fontOptions}
                  />
                  <div className="grid-3">
                    <InputGroup
                      id="card-border-color"
                      label={t.labels.borderColor}
                      type="color"
                      value={cardData.borderColor || '#ffd700'}
                      onChange={(v) => updateCardData('borderColor', v)}
                    />
                    <InputGroup
                      id="card-bg-color"
                      label={t.labels.backgroundColor}
                      type="color"
                      value={cardData.backgroundColor || '#ff6b35'}
                      onChange={(v) => updateCardData('backgroundColor', v)}
                    />
                    <InputGroup
                      id="card-text-color"
                      label={t.labels.textColor}
                      type="color"
                      value={cardData.textColor || '#1a1a2e'}
                      onChange={(v) => updateCardData('textColor', v)}
                    />
                  </div>
                  <div style={{ marginTop: '16px' }}>
                    <Checkbox
                      id="show-hp"
                      label={t.checkboxes.showHP}
                      checked={cardData.showHP}
                      onChange={(v) => updateCardData('showHP', v)}
                    />
                    <Checkbox
                      id="show-weak-res"
                      label={t.checkboxes.showWeakRes}
                      checked={cardData.showWeakRes}
                      onChange={(v) => updateCardData('showWeakRes', v)}
                    />
                    <Checkbox
                      id="show-retreat"
                      label={t.checkboxes.showRetreat}
                      checked={cardData.showRetreat}
                      onChange={(v) => updateCardData('showRetreat', v)}
                    />
                    <Checkbox
                      id="show-description"
                      label={t.checkboxes.showDescription}
                      checked={cardData.showDescription}
                      onChange={(v) => updateCardData('showDescription', v)}
                    />
                    <Checkbox
                      id="show-texture"
                      label={t.checkboxes.showTexture}
                      checked={cardData.showTexture}
                      onChange={(v) => updateCardData('showTexture', v)}
                    />
                    <Checkbox
                      id="show-particles"
                      label={t.checkboxes.showParticles}
                      checked={cardData.showParticles}
                      onChange={(v) => updateCardData('showParticles', v)}
                    />
                  </div>
                </CollapsibleSection>
              </>
            )}
          </div>
        </div></div></div>)
    }
    function CardCreator() {
      const [lang, setLang] = useState('en');
      const t = TRANSLATIONS[lang];
      return (<LanguageContext.Provider value={{ lang, setLang, t }}><div className="language-dropdown"><select
        value={lang}
        onChange={(e) => setLang(e.target.value)}
        className="lang-select"
      >
        {Object.entries(LANGUAGES).map(([code, { name, flag }]) => (<option key={code} value={code}>
          {flag} {name}
        </option>))}
      </select></div><CardCreatorContent /></LanguageContext.Provider>)
    }
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CardCreator />);


  </script>
</body>

</html>
