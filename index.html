<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Creator</title>
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Html2Canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Emoji Picker -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
  <link rel="stylesheet" href="styles.css">
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@400;700&family=Bangers&family=Cinzel:wght@400;700;900&family=Dancing+Script:wght@400;700&family=Nunito:wght@400;700;900&family=Orbitron:wght@400;700;900&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700;900&family=Poppins:wght@400;700;900&family=Roboto:wght@400;700;900&display=swap"
    rel="stylesheet">
</head>

<body>
  <div id="root"></div>

  <!-- GIF Instructions Modal -->
  <div id="gif-instructions-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h3>üìπ High Quality GIF Capture (v2)</h3>
      </div>
      <div class="modal-body">
        <p>To get a perfect result, we need to capture the screen:</p>
        <div class="steps-list">
          <div class="step-item">
            <span class="step-number">1</span>
            <div id="gif-modal-step-1" class="step-text">Select the <strong>"Chrome Tab"</strong> tab.</div>
          </div>
          <div class="step-item">
            <span class="step-number">2</span>
            <div id="gif-modal-step-2" class="step-text">Choose <strong>this page</strong> from the list.</div>
          </div>
          <div class="step-item">
            <span class="step-number">3</span>
            <div id="gif-modal-step-3" class="step-text">Click <strong>"Share"</strong>.</div>
          </div>
        </div>
        <div class="gif-settings" style="margin-bottom: 20px; display: flex; gap: 15px;">
          <div class="setting-group" style="flex: 1;">
            <label id="gif-fps-label"
              style="display: block; color: #a0a0c0; font-size: 12px; margin-bottom: 5px; font-weight: 600;">FPS</label>
            <select id="gif-fps-select" class="gif-settings-select">
              <option value="15" id="gif-fps-normal">15 FPS (Normal)</option>
              <option value="24" id="gif-fps-cinema" selected>24 FPS (Cinema)</option>
              <option value="30" id="gif-fps-smooth">30 FPS (Smooth)</option>
              <option value="60" id="gif-fps-ultra">60 FPS (Ultra)</option>
            </select>
          </div>
          <div class="setting-group" style="flex: 1;">
            <label id="gif-quality-label"
              style="display: block; color: #a0a0c0; font-size: 12px; margin-bottom: 5px; font-weight: 600;">Quality
              (Height)</label>
            <select id="gif-scale-select" class="gif-settings-select">
              <option value="480" id="gif-quality-sd">480p (SD)</option>
              <option value="720" id="gif-quality-normal" selected>720p (HD)</option>
              <option value="1080" id="gif-quality-high">1080p (Full HD)</option>
              <option value="1440" id="gif-quality-qhd">1440p (QHD)</option>
              <option value="2160" id="gif-quality-ultra">4K (UHD)</option>
            </select>
          </div>
        </div>
        <div class="modal-note">
          <span class="note-icon">üí°</span>
          <span>The mouse will be automatically hidden and the card cropped.</span>
        </div>
        <div class="modal-warning">
          <span class="note-icon">‚ö†Ô∏è</span>
          <span>Using maximum settings (60 FPS / 4K) may take longer and use high CPU.</span>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancel-gif-btn" class="secondary-btn">Cancel</button>
        <button id="start-gif-btn" class="primary-btn">Start Capture</button>
      </div>
    </div>
  </div>

  <script type="text/babel">

    const { useState, useRef, useMemo, useCallback, useEffect, createContext, useContext } = React;
    const LANGUAGES = {
      en: { name: 'English', flag: 'üá¨üáß' }, fr: { name: 'Fran√ßais', flag: 'üá´üá∑' }, es: { name: 'Espa√±ol', flag: 'üá™üá∏' }, de: { name: 'Deutsch', flag: 'üá©üá™' }, ru: { name: '–†—É—Å—Å–∫–∏–π', flag: 'üá∑üá∫' }, ja: { name: 'Êó•Êú¨Ë™û', flag: 'üáØüáµ' }, zh: { name: '‰∏≠Êñá', flag: 'üá®üá≥' },
    };
    const TRANSLATIONS = {
      en: {
        gifModal: {
          title: "üìπ High Quality GIF Capture",
          body: "To get a perfect result, we need to capture the screen:",
          step1: "Select the <strong>\"Tab\"</strong> option.",
          step2: "Choose <strong>this page</strong> from the list.",
          step3: "Click <strong>\"Share\"</strong>.",
          note: "The mouse will be automatically hidden and the card cropped.",
          warning: "Using maximum settings (60 FPS / 4K) may take longer and use high CPU.",
          fpsLabel: "FPS",
          qualityLabel: "Quality (Height)",
          fpsNormal: "15 FPS (Normal)",
          fpsCinema: "24 FPS (Cinema)",
          fpsSmooth: "30 FPS (Smooth)",
          fpsUltra: "60 FPS (Ultra)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "Cancel",
          start: "Start Capture"
        },
        appTitle: 'Card Creator', appSubtitle: 'Create your own personalized collectible cards', hoverHint: '‚ú® Hover over the card to intensify the effect ‚ú®', elements: { Fire: 'Fire', Water: 'Water', Nature: 'Nature', Electric: 'Electric', Mystic: 'Mystic', Fighting: 'Fighting', Shadow: 'Shadow', Metal: 'Metal', Light: 'Light', Dragon: 'Dragon', Ice: 'Ice', Neutral: 'Neutral' }, effects: { none: { name: 'None', description: 'No effect' }, holographic: { name: 'Holographic', description: 'Classic rainbow effect' }, rainbow: { name: 'Rainbow', description: 'Animated multicolor gradient' }, gold: { name: 'Gold', description: 'Luxurious golden reflections' }, silver: { name: 'Silver', description: 'Metallic silver reflections' }, prismatic: { name: 'Prismatic', description: 'Refracting crystal effect' }, neon: { name: 'Neon', description: 'Vibrant neon glow' }, galaxy: { name: 'Galaxy', description: 'Starry cosmic effect' }, fire: { name: 'Flames', description: 'Animated flame effect' }, ice: { name: 'Frost', description: 'Sparkling ice effect' } }, stages: ['Base', 'Stage 1', 'Stage 2', 'Special', 'Legendary', 'Mythic', 'Ultra'], rarities: { common: 'Common', uncommon: 'Uncommon', rare: 'Rare', epic: 'Epic', legendary: 'Legendary', mythic: 'Mythic' }, sections: { image: 'Image', basicInfo: 'Basic Information', rarityEffects: 'Rarity & Effects', abilities: 'Abilities', stats: 'Statistics', appearance: 'Appearance' }, labels: { name: 'Name', hp: 'Hit Points', element: 'Element', stage: 'Stage', description: 'Description', author: 'Author', rarity: 'Rarity', effect: 'Effect', weakness: 'Weakness', resistance: 'Resistance', retreatCost: 'Retreat Cost', abilityName: 'Ability Name', damage: 'Damage', energyCost: 'Energy Cost', abilityDesc: 'Abilities Description', borderColor: 'Border Color', backgroundColor: 'Background Color', textColor: 'Text Color', font: 'Font', zoom: 'Zoom' }, buttons: { addAbility: '+ Add Ability', remove: 'Remove', change: 'Change', recenter: 'Recenter', download: 'Download', autoRotate: '3D Preview' }, checkboxes: { showHP: 'Show hit points', showWeakRes: 'Show weakness/resistance', showRetreat: 'Show retreat cost', showDescription: 'Show description', showTexture: 'Show texture pattern', showParticles: 'Show particles', showDamage: 'Show damage' }, imageEditor: { dropHint: 'Drag & drop an image here', orClick: 'or click to select', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Loading...', unsupportedFormat: 'Unsupported format. Use PNG,JPG,GIF or WEBP.', fileTooLarge: 'File too large. Maximum 15MB.' },
        appTitle: 'Card Creator', appSubtitle: 'Create your own personalized collectible cards', hoverHint: '‚ú® Hover over the card to intensify the effect ‚ú®', elements: { Fire: 'Fire', Water: 'Water', Nature: 'Nature', Electric: 'Electric', Mystic: 'Mystic', Fighting: 'Fighting', Shadow: 'Shadow', Metal: 'Metal', Light: 'Light', Dragon: 'Dragon', Ice: 'Ice', Neutral: 'Neutral' }, effects: { none: { name: 'None', description: 'No effect' }, holographic: { name: 'Holographic', description: 'Classic rainbow effect' }, rainbow: { name: 'Rainbow', description: 'Animated multicolor gradient' }, gold: { name: 'Gold', description: 'Luxurious golden reflections' }, silver: { name: 'Silver', description: 'Metallic silver reflections' }, prismatic: { name: 'Prismatic', description: 'Refracting crystal effect' }, neon: { name: 'Neon', description: 'Vibrant neon glow' }, galaxy: { name: 'Galaxy', description: 'Starry cosmic effect' }, fire: { name: 'Flames', description: 'Animated flame effect' }, ice: { name: 'Frost', description: 'Sparkling ice effect' } }, stages: ['Base', 'Stage 1', 'Stage 2', 'Special', 'Legendary', 'Mythic', 'Ultra'], rarities: { common: 'Common', uncommon: 'Uncommon', rare: 'Rare', epic: 'Epic', legendary: 'Legendary', mythic: 'Mythic' }, sections: { image: 'Image', basicInfo: 'Basic Information', rarityEffects: 'Effects', abilities: 'Abilities', stats: 'Statistics', appearance: 'Appearance', cardStyle: 'Card Style' }, labels: { name: 'Name', hp: 'Hit Points', element: 'Element', stage: 'Stage', description: 'Description', author: 'Author', rarity: 'Rarity', effect: 'Effect', weakness: 'Weakness', resistance: 'Resistance', retreatCost: 'Retreat Cost', abilityName: 'Ability Name', damage: 'Damage', energyCost: 'Energy Cost', abilityDesc: 'Description', borderColor: 'Border Color', backgroundColor: 'Card Background', textColor: 'Text Color', font: 'Font', zoom: 'Zoom' }, buttons: { addAbility: '+ Add Ability', remove: 'Remove', change: 'Change', recenter: 'Recenter', download: 'Download', autoRotate: '3D View' }, checkboxes: { showHP: 'Show hit points', showWeakRes: 'Show weakness/resistance', showRetreat: 'Show retreat cost', showDescription: 'Show description', showTexture: 'Show texture pattern', showParticles: 'Show particles', showDamage: 'Show damage' }, imageEditor: { dropHint: 'Drag & drop an image here', orClick: 'or click to select', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Loading...', unsupportedFormat: 'Unsupported format. Use PNG,JPG,GIF or WEBP.', fileTooLarge: 'File too large. Maximum 15MB.' },
        download: { title: 'üì• Download', pngTitle: 'Transparent PNG image', jpgTitle: 'JPG image with background', gifTitle: 'Animated GIF (3 seconds)', htmlTitle: 'Interactive HTML file', capturing: '‚è≥ Capturing...', encoding: '‚öôÔ∏è Encoding...' },
        card: { hp: 'HP', weakness: 'Weakness', resistance: 'Resistance', cost: 'Cost', illus: 'Illus.' }, defaults: { newAbility: 'New Ability' }, display: { title: 'Display Options' }, tabs: { info: 'Info', content: 'Content', visual: 'Visual', style: 'Style', colors: 'Colors' },
        imageEditor: { dropHint: 'Drag & drop an image here', orClick: 'or click to select', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Loading...', unsupportedFormat: 'Unsupported format. Use PNG,JPG,GIF or WEBP.', fileTooLarge: 'File too large. Maximum 15MB.', searchPlaceholder: 'Type...' },
        download: { title: 'üì• Download', pngTitle: 'Transparent PNG image', jpgTitle: 'JPG image with background', gifTitle: 'Animated GIF (3 seconds)', webpTitle: 'WebP Image', htmlTitle: 'Interactive HTML file', capturing: '‚è≥ Capturing...', encoding: '‚öôÔ∏è Encoding...' },
        labels: { name: 'Name', hp: 'Hit Points', element: 'Element', stage: 'Stage', description: 'Description', author: 'Author', rarity: 'Rarity', effect: 'Effect', weakness: 'Weakness', resistance: 'Resistance', retreatCost: 'Retreat Cost', abilityName: 'Ability Name', damage: 'Damage', energyCost: 'Energy Cost', abilityDesc: 'Abilities Description', borderColor: 'Border Color', backgroundColor: 'Card Background', abilityBackground: 'Ability Background', textColor: 'Text Color', font: 'Font', size: 'Size', weight: 'Weight', zoom: 'Zoom', presets: 'Presets', backgroundStyle: 'Background Style', solid: 'Solid', gradient: 'Gradient', cardInner: 'Card Inner', primaryColor: 'Primary Color', secondaryColor: 'Secondary Color', nameColor: 'Name Color', hpColor: 'HP Color', typeColor: 'Type Color', descColor: 'Description Color', statsColor: 'Stats Color', authorColor: 'Author Color' },
        common: { cancel: 'Cancel', close: 'Close' },
        prompts: { resetConfirm: 'Reset all card data?', saveHint: 'Your card (text + image) will be saved locally.', saveSuccess: 'Card saved successfully!', loadConfirm: 'Load this card? Unsaved changes will be lost.', deleteConfirm: 'Delete this saved card?', noSaves: 'No saved cards found.', quotaError: 'Storage full! Try deleting old cards.', saveError: 'Error saving card.', autoDeleteInfo: 'Saved cards are automatically deleted after 30 days.' },
        buttons: { addAbility: '+ Add Ability', remove: 'Remove', change: 'Change', recenter: 'Recenter', download: 'Download', autoRotate: '3D View', resetCard: 'üîÑ Reset Card', save: 'Save', load: 'Load', deleteAll: 'Delete All' },
        sections: { image: 'Image', basicInfo: 'Basic Information', rarityEffects: 'Effects', abilities: 'Abilities', stats: 'Statistics', appearance: 'Appearance', cardStyle: 'Card Style', textStyle: 'Text Style', particles: 'Particles', abilityStyle: 'Ability Style', reset: 'Reset' },
        labels: { name: 'Name', hp: 'Hit Points', element: 'Element', stage: 'Stage', description: 'Description', author: 'Author', rarity: 'Rarity', effect: 'Effect', weakness: 'Weakness', resistance: 'Resistance', retreatCost: 'Retreat Cost', abilityName: 'Ability Name', damage: 'Damage', energyCost: 'Energy Cost', abilityDesc: 'Abilities Description', borderColor: 'Border Color', backgroundColor: 'Card Background', abilityBackground: 'Ability Background', textColor: 'Text Color', font: 'Font', size: 'Size', weight: 'Weight', zoom: 'Zoom', presets: 'Presets', backgroundStyle: 'Background Style', solid: 'Solid', gradient: 'Gradient', cardInner: 'Card Inner', primaryColor: 'Primary Color', secondaryColor: 'Secondary Color', nameColor: 'Name Color', hpColor: 'HP Color', typeColor: 'Type Color', descColor: 'Description Color', statsColor: 'Stats Color', authorColor: 'Author Color', particleEmoji: 'Particle Emoji', animation: 'Animation' },
        textures: { none: 'None', grid: 'Grid', scales: 'Scales', cross: 'Cross', stars: 'Stars', hexagons: 'Hexagons', lines: 'Lines', dots: 'Dots', waves: 'Waves', circuit: 'Circuit' },
        animations: { fire: 'Rising', water: 'Bubbles', nature: 'Floating', electric: 'Sparks', mystic: 'Magic', fighting: 'Impact', shadow: 'Fade', metal: 'Gears', light: 'Radiate', dragon: 'Majestic', ice: 'Snow', neutral: 'Subtle' }
      },
      fr: {
        gifModal: {
          title: "üìπ Capture GIF Haute Qualit√©",
          body: "Pour obtenir un r√©sultat parfait, nous devons capturer l'√©cran :",
          step1: "S√©lectionnez l'option <strong>\"Onglet\"</strong>.",
          step2: "Choisissez <strong>cette page</strong> dans la liste.",
          step3: "Cliquez sur <strong>\"Partager\"</strong>.",
          note: "La souris sera automatiquement masqu√©e et la carte recadr√©e.",
          warning: "L'utilisation des param√®tres maximum (60 IPS / 4K) peut prendre plus de temps et utiliser beaucoup de CPU.",
          fpsLabel: "IPS",
          qualityLabel: "Qualit√© (Hauteur)",
          fpsNormal: "15 IPS (Normal)",
          fpsCinema: "24 IPS (Cin√©ma)",
          fpsSmooth: "30 IPS (Fluide)",
          fpsUltra: "60 IPS (Ultra)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "Annuler",
          start: "Lancer la capture"
        },
        appTitle: 'Card Creator', appSubtitle: 'Cr√©ez vos propres cartes √† collectionner personnalis√©es', hoverHint: '‚ú® Survolez la carte pour intensifier l\'effet ‚ú®', elements: { Fire: 'Feu', Water: 'Eau', Nature: 'Nature', Electric: '√âlectrique', Mystic: 'Mystique', Fighting: 'Combat', Shadow: 'Ombre', Metal: 'M√©tal', Light: 'Lumi√®re', Dragon: 'Dragon', Ice: 'Glace', Neutral: 'Neutre' }, effects: { none: { name: 'Aucun', description: 'Pas d\'effet' }, holographic: { name: 'Holographique', description: 'Effet arc-en-ciel classique' }, rainbow: { name: 'Arc-en-ciel', description: 'D√©grad√© multicolore anim√©' }, gold: { name: 'Dor√©', description: 'Reflets dor√©s luxueux' }, silver: { name: 'Argent√©', description: 'Reflets argent√©s m√©talliques' }, prismatic: { name: 'Prismatique', description: 'Effet cristal r√©fractant' }, neon: { name: 'N√©on', description: 'Lueur n√©on vibrante' }, galaxy: { name: 'Galaxie', description: 'Effet cosmique √©toil√©' }, fire: { name: 'Flammes', description: 'Effet de flammes anim√©es' }, ice: { name: 'Givr√©', description: 'Effet de glace scintillante' } }, stages: ['Base', '√âvolution 1', '√âvolution 2', 'Sp√©cial', 'L√©gendaire', 'Mythique', 'Ultra'], rarities: { common: 'Commune', uncommon: 'Peu commune', rare: 'Rare', epic: '√âpique', legendary: 'L√©gendaire', mythic: 'Mythique' }, sections: { image: 'Image', basicInfo: 'Informations de base', rarityEffects: 'Effets', abilities: 'Capacit√©s', stats: 'Statistiques', appearance: 'Apparence', cardStyle: 'Style de carte' }, labels: { name: 'Nom', hp: 'Points de vie', element: '√âl√©ment', stage: 'Stade', description: 'Description', author: 'Auteur', rarity: 'Raret√©', effect: 'Effet', weakness: 'Faiblesse', resistance: 'R√©sistance', retreatCost: 'Co√ªt de retraite', abilityName: 'Nom de la capacit√©', damage: 'D√©g√¢ts', energyCost: 'Co√ªt en √©nergie', abilityDesc: 'Description des Capacit√©s', borderColor: 'Couleur de bordure', backgroundColor: 'Couleur de fond', textColor: 'Couleur du texte', font: 'Police', zoom: 'Zoom' }, buttons: { addAbility: '+ Ajouter une capacit√©', remove: 'Supprimer', change: 'Changer', recenter: 'Recentrer', download: 'T√©l√©charger', autoRotate: 'Vue 3D' }, checkboxes: { showHP: 'Afficher les points de vie', showWeakRes: 'Afficher faiblesse/r√©sistance', showRetreat: 'Afficher le co√ªt de retraite', showDescription: 'Afficher la description', showTexture: 'Afficher le motif', showParticles: 'Afficher les particules', showDamage: 'Afficher les d√©g√¢ts' }, imageEditor: { dropHint: 'Glissez-d√©posez une image ici', orClick: 'ou cliquez pour s√©lectionner', formats: 'PNG,JPG,GIF,WEBP (max 15Mo)', loading: 'Chargement...', unsupportedFormat: 'Format non support√©. Utilisez PNG,JPG,GIF ou WEBP.', fileTooLarge: 'Fichier trop volumineux. Maximum 15Mo.' },
        download: { title: 'üì• T√©l√©charger', pngTitle: 'Image PNG transparente', jpgTitle: 'Image JPG avec fond', gifTitle: 'GIF anim√© (3 secondes)', htmlTitle: 'Fichier HTML interactif', capturing: '‚è≥ Capture...', encoding: '‚öôÔ∏è Encodage...' },
        card: { hp: 'PV', weakness: 'Faiblesse', resistance: 'R√©sistance', cost: 'Co√ªt', illus: 'Illus.' }, defaults: { newAbility: 'Nouvelle Capacit√©' }, display: { title: 'Options d\'affichage' }, tabs: { info: 'Infos', content: 'Contenu', visual: 'Visuel', style: 'Style', colors: 'Couleurs' },
        imageEditor: { dropHint: 'Glissez-d√©posez une image ici', orClick: 'ou cliquez pour s√©lectionner', formats: 'PNG,JPG,GIF,WEBP (max 15Mo)', loading: 'Chargement...', unsupportedFormat: 'Format non support√©. Utilisez PNG,JPG,GIF ou WEBP.', fileTooLarge: 'Fichier trop volumineux. Maximum 15Mo.', searchPlaceholder: 'Tapez...' },
        download: { title: 'üì• T√©l√©charger', pngTitle: 'Image PNG transparente', jpgTitle: 'Image JPG avec fond', gifTitle: 'GIF anim√© (3 secondes)', webpTitle: 'Image WebP', htmlTitle: 'Fichier HTML interactif', capturing: '‚è≥ Capture...', encoding: '‚öôÔ∏è Encodage...' },
        labels: { name: 'Nom', hp: 'Points de vie', element: '√âl√©ment', stage: 'Stade', description: 'Description', author: 'Auteur', effect: 'Effet', weakness: 'Faiblesse', resistance: 'R√©sistance', retreatCost: 'Co√ªt de retraite', abilityName: 'Nom de la capacit√©', damage: 'D√©g√¢ts', energyCost: 'Co√ªt en √©nergie', abilityDesc: 'Description', borderColor: 'Couleur de bordure', backgroundColor: 'Fond de carte', abilityBackground: 'Fond des capacit√©s', textColor: 'Couleur du texte', font: 'Police', size: 'Taille', weight: 'Graisse', zoom: 'Zoom', presets: 'Pr√©r√©glages', backgroundStyle: 'Style de fond', solid: 'Uni', gradient: 'D√©grad√©', cardInner: 'Int√©rieur de la carte', primaryColor: 'Couleur principale', secondaryColor: 'Couleur secondaire', nameColor: 'Couleur du nom', hpColor: 'Couleur des PV', typeColor: 'Couleur du type', descColor: 'Couleur de description', statsColor: 'Couleur des stats', authorColor: 'Couleur de l\'auteur' },
        common: { cancel: 'Annuler', close: 'Fermer' },
        prompts: { resetConfirm: 'R√©initialiser toutes les donn√©es de la carte ?', saveHint: 'Votre carte (texte + image) sera sauvegard√©e localement.', saveSuccess: 'Carte sauvegard√©e avec succ√®s !', loadConfirm: 'Charger cette carte ? Les modifications non sauvegard√©es seront perdues.', deleteConfirm: 'Supprimer cette carte ?', noSaves: 'Aucune carte sauvegard√©e.', quotaError: 'Espace insuffisant ! Supprimez des anciennes cartes.', saveError: 'Erreur lors de la sauvegarde.', autoDeleteInfo: 'Les cartes sont supprim√©es apr√®s 30 jours.' },
        buttons: { addAbility: '+ Ajouter', remove: 'Supprimer', change: 'Changer', recenter: 'Recentrer', download: 'T√©l√©charger', autoRotate: 'Aper√ßu 3D', resetCard: 'üîÑ R√©initialiser', save: 'Sauvegarder', load: 'Charger', deleteAll: 'Tout supprimer' },
        sections: { image: 'Image', basicInfo: 'Informations de base', rarityEffects: 'Effets', abilities: 'Capacit√©s', stats: 'Statistiques', appearance: 'Apparence', cardStyle: 'Style de carte', textStyle: 'Style du texte', particles: 'Particules', abilityStyle: 'Style des capacit√©s', reset: 'R√©initialiser' },
        labels: { name: 'Nom', hp: 'Points de vie', element: '√âl√©ment', stage: 'Stade', description: 'Description', author: 'Auteur', effect: 'Effet', weakness: 'Faiblesse', resistance: 'R√©sistance', retreatCost: 'Co√ªt de retraite', abilityName: 'Nom de la capacit√©', damage: 'D√©g√¢ts', energyCost: 'Co√ªt en √©nergie', abilityDesc: 'Description', borderColor: 'Couleur de bordure', backgroundColor: 'Fond de carte', abilityBackground: 'Fond des capacit√©s', textColor: 'Couleur du texte', font: 'Police', size: 'Taille', weight: 'Graisse', zoom: 'Zoom', presets: 'Pr√©r√©glages', backgroundStyle: 'Style de fond', solid: 'Uni', gradient: 'D√©grad√©', cardInner: 'Int√©rieur de la carte', primaryColor: 'Couleur principale', secondaryColor: 'Couleur secondaire', nameColor: 'Couleur du nom', hpColor: 'Couleur des PV', typeColor: 'Couleur du type', descColor: 'Couleur de description', statsColor: 'Couleur des stats', authorColor: 'Couleur de l\'auteur', particleEmoji: 'Emoji de particule', animation: 'Animation' },
        textures: { none: 'Aucun', grid: 'Grille', scales: '√âcailles', cross: 'Croix', stars: '√âtoiles', hexagons: 'Hexagones', lines: 'Lignes', dots: 'Points', waves: 'Vagues', circuit: 'Circuit' },
        animations: { fire: 'Montant', water: 'Bulles', nature: 'Flottant', electric: '√âtincelles', mystic: 'Magie', fighting: 'Impact', shadow: 'Fondu', metal: 'Engrenages', light: 'Rayonnement', dragon: 'Majestueux', ice: 'Neige', neutral: 'Subtil' }
      },
      es: {
        gifModal: {
          title: "üìπ Captura GIF de Alta Calidad",
          body: "Para obtener un resultado perfecto, necesitamos capturar la pantalla:",
          step1: "Selecciona la opci√≥n <strong>\"Pesta√±a\"</strong>.",
          step2: "Elige <strong>esta p√°gina</strong> de la lista.",
          step3: "Haz clic en <strong>\"Compartir\"</strong>.",
          note: "El rat√≥n se ocultar√° autom√°ticamente y la carta se recortar√°.",
          warning: "El uso de la configuraci√≥n m√°xima (60 FPS / 4K) puede tardar m√°s y consumir mucha CPU.",
          fpsLabel: "FPS",
          qualityLabel: "Calidad (Altura)",
          fpsNormal: "15 FPS (Normal)",
          fpsCinema: "24 FPS (Cine)",
          fpsSmooth: "30 FPS (Fluido)",
          fpsUltra: "60 FPS (Ultra)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "Cancelar",
          start: "Iniciar Captura"
        },
        appTitle: 'Card Creator', appSubtitle: 'Crea tus propias cartas coleccionables personalizadas', hoverHint: '‚ú® Pasa el cursor sobre la carta para intensificar el efecto ‚ú®', elements: { Fire: 'Fuego', Water: 'Agua', Nature: 'Naturaleza', Electric: 'El√©ctrico', Mystic: 'M√≠stico', Fighting: 'Lucha', Shadow: 'Sombra', Metal: 'Metal', Light: 'Luz', Dragon: 'Drag√≥n', Ice: 'Hielo', Neutral: 'Neutral' }, effects: { none: { name: 'Ninguno', description: 'Sin efecto' }, holographic: { name: 'Hologr√°fico', description: 'Efecto arco√≠ris cl√°sico' }, rainbow: { name: 'Arco√≠ris', description: 'Degradado multicolor animado' }, gold: { name: 'Dorado', description: 'Reflejos dorados lujosos' }, silver: { name: 'Plateado', description: 'Reflejos met√°licos plateados' }, prismatic: { name: 'Prism√°tico', description: 'Efecto cristal refractante' }, neon: { name: 'Ne√≥n', description: 'Brillo ne√≥n vibrante' }, galaxy: { name: 'Galaxia', description: 'Efecto c√≥smico estrellado' }, fire: { name: 'Llamas', description: 'Efecto de llamas animadas' }, ice: { name: 'Escarcha', description: 'Efecto de hielo brillante' } }, stages: ['Base', 'Fase 1', 'Fase 2', 'Especial', 'Legendario', 'M√≠tico', 'Ultra'], rarities: { common: 'Com√∫n', uncommon: 'Poco com√∫n', rare: 'Rara', epic: '√âpica', legendary: 'Legendaria', mythic: 'M√≠tica' }, sections: { image: 'Imagen', basicInfo: 'Informaci√≥n b√°sica', rarityEffects: 'Rareza y Efectos', abilities: 'Habilidades', stats: 'Estad√≠sticas', appearance: 'Apariencia' }, labels: { name: 'Nombre', hp: 'Puntos de vida', element: 'Elemento', stage: 'Fase', description: 'Descripci√≥n', author: 'Autor', rarity: 'Rareza', effect: 'Efecto', weakness: 'Debilidad', resistance: 'Resistencia', retreatCost: 'Coste de retirada', abilityName: 'Nombre de habilidad', damage: 'Da√±o', energyCost: 'Coste de energ√≠a', abilityDesc: 'Descripci√≥n', borderColor: 'Color del borde', backgroundColor: 'Color de fondo', textColor: 'Color del texto', font: 'Fuente', zoom: 'Zoom' }, buttons: { addAbility: '+ A√±adir habilidad', remove: 'Eliminar', change: 'Cambiar', recenter: 'Recentrar', download: 'Descargar', autoRotate: 'Vista previa 3D' }, checkboxes: { showHP: 'Mostrar puntos de vida', showWeakRes: 'Mostrar debilidad/resistencia', showRetreat: 'Mostrar coste de retirada', showDescription: 'Mostrar descripci√≥n', showTexture: 'Mostrar patr√≥n', showParticles: 'Mostrar part√≠culas', showDamage: 'Mostrar da√±o' }, imageEditor: { dropHint: 'Arrastra y suelta una imagen aqu√≠', orClick: 'o haz clic para seleccionar', formats: 'PNG,JPG,GIF,WEBP (m√°x 15MB)', loading: 'Cargando...', unsupportedFormat: 'Formato no soportado. Use PNG,JPG,GIF o WEBP.', fileTooLarge: 'Archivo demasiado grande. M√°ximo 15MB.' },
        download: { title: 'üì• Descargar', pngTitle: 'Imagen PNG transparente', jpgTitle: 'Imagen JPG con fondo', gifTitle: 'GIF animado (3 segundos)', htmlTitle: 'Archivo HTML interactivo', capturing: '‚è≥ Capturando...', encoding: '‚öôÔ∏è Codificando...' },
        card: { hp: 'PS', weakness: 'Debilidad', resistance: 'Resistencia', cost: 'Coste', illus: 'Illus.' }, defaults: { newAbility: 'Nueva Habilidad' }, display: { title: 'Opciones de visualizaci√≥n' }, tabs: { info: 'Info', content: 'Contenido', visual: 'Visual', style: 'Estilo', colors: 'Colores' },
        imageEditor: { dropHint: 'Arrastra y suelta una imagen aqu√≠', orClick: 'o haz clic para seleccionar', formats: 'PNG,JPG,GIF,WEBP (m√°x 15MB)', loading: 'Cargando...', unsupportedFormat: 'Formato no soportado. Use PNG,JPG,GIF o WEBP.', fileTooLarge: 'Archivo demasiado grande. M√°ximo 15MB.', searchPlaceholder: 'Escriba...' },
        download: { title: 'üì• Descargar', pngTitle: 'Imagen PNG transparente', jpgTitle: 'Imagen JPG con fondo', gifTitle: 'GIF animado (3 segundos)', webpTitle: 'Imagen WebP', htmlTitle: 'Archivo HTML interactivo', capturing: '‚è≥ Capturando...', encoding: '‚öôÔ∏è Codificando...' },
        labels: { name: 'Nombre', hp: 'Puntos de vida', element: 'Elemento', stage: 'Fase', description: 'Descripci√≥n', author: 'Autor', effect: 'Efecto', weakness: 'Debilidad', resistance: 'Resistencia', retreatCost: 'Coste de retirada', abilityName: 'Nombre de habilidad', damage: 'Da√±o', energyCost: 'Coste de energ√≠a', abilityDesc: 'Descripci√≥n', borderColor: 'Color del borde', backgroundColor: 'Fondo de carta', abilityBackground: 'Fondo de habilidad', textColor: 'Color del texto', font: 'Fuente', size: 'Tama√±o', weight: 'Peso', zoom: 'Zoom', presets: 'Preajustes', backgroundStyle: 'Estilo de fondo', solid: 'S√≥lido', gradient: 'Degradado', cardInner: 'Interior de la carta', primaryColor: 'Color primario', secondaryColor: 'Color secundario', nameColor: 'Color del nombre', hpColor: 'Color de PV', typeColor: 'Color del tipo', descColor: 'Color de descripci√≥n', statsColor: 'Color de estad√≠sticas', authorColor: 'Color del autor' },
        prompts: { resetConfirm: '¬øRestablecer todos los datos de la carta?', autoDeleteInfo: 'Las cartas se borran tras 30 d√≠as.' },
        buttons: { addAbility: '+ A√±adir', remove: 'Eliminar', change: 'Cambiar', recenter: 'Recentrar', download: 'Descargar', autoRotate: 'Vista 3D', resetCard: 'üîÑ Reiniciar', save: 'Guardar', load: 'Cargar', deleteAll: 'Borrar todo' },
        sections: { image: 'Imagen', basicInfo: 'Informaci√≥n b√°sica', rarityEffects: 'Efectos', abilities: 'Habilidades', stats: 'Estad√≠sticas', appearance: 'Apariencia', cardStyle: 'Estilo de carta', textStyle: 'Estilo de texto', particles: 'Part√≠culas', abilityStyle: 'Estilo de habilidad', reset: 'Reiniciar' },
        labels: { name: 'Nombre', hp: 'Puntos de vida', element: 'Elemento', stage: 'Fase', description: 'Descripci√≥n', author: 'Autor', effect: 'Efecto', weakness: 'Debilidad', resistance: 'Resistencia', retreatCost: 'Coste de retirada', abilityName: 'Nombre de habilidad', damage: 'Da√±o', energyCost: 'Coste de energ√≠a', abilityDesc: 'Descripci√≥n', borderColor: 'Color del borde', backgroundColor: 'Fondo de carta', abilityBackground: 'Fondo de habilidad', textColor: 'Color del texto', font: 'Fuente', size: 'Tama√±o', weight: 'Peso', zoom: 'Zoom', presets: 'Preajustes', backgroundStyle: 'Estilo de fondo', solid: 'S√≥lido', gradient: 'Degradado', cardInner: 'Interior de la carta', primaryColor: 'Color primario', secondaryColor: 'Color secundario', nameColor: 'Color del nombre', hpColor: 'Color de PV', typeColor: 'Color del tipo', descColor: 'Color de descripci√≥n', statsColor: 'Color de estad√≠sticas', authorColor: 'Color del autor', particleEmoji: 'Emoji de part√≠cula', animation: 'Animaci√≥n' },
        textures: { none: 'Ninguno', grid: 'Cuadr√≠cula', scales: 'Escamas', cross: 'Cruz', stars: 'Estrellas', hexagons: 'Hex√°gonos', lines: 'L√≠neas', dots: 'Puntos', waves: 'Olas', circuit: 'Circuito' },
        animations: { fire: 'Ascendente', water: 'Burbujas', nature: 'Flotante', electric: 'Chispas', mystic: 'Magia', fighting: 'Impacto', shadow: 'Desvanecer', metal: 'Engranajes', light: 'Resplandor', dragon: 'Majestuoso', ice: 'Nieve', neutral: 'Sutil' },
        common: { cancel: 'Cancelar', close: 'Cerrar' }
      },
      de: {
        gifModal: {
          title: "üìπ Hochwertige GIF-Aufnahme",
          body: "F√ºr ein perfektes Ergebnis m√ºssen wir den Bildschirm aufnehmen:",
          step1: "W√§hlen Sie die Option <strong>\"Tab\"</strong>.",
          step2: "W√§hlen Sie <strong>diese Seite</strong> aus der Liste.",
          step3: "Klicken Sie auf <strong>\"Teilen\"</strong>.",
          note: "Die Maus wird automatisch ausgeblendet und die Karte zugeschnitten.",
          warning: "Die Verwendung der maximalen Einstellungen (60 FPS / 4K) kann l√§nger dauern und eine hohe CPU-Auslastung verursachen.",
          fpsLabel: "FPS",
          qualityLabel: "Qualit√§t (H√∂he)",
          fpsNormal: "15 FPS (Normal)",
          fpsCinema: "24 FPS (Kino)",
          fpsSmooth: "30 FPS (Fl√ºssig)",
          fpsUltra: "60 FPS (Ultra)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "Abbrechen",
          start: "Aufnahme starten"
        },
        appTitle: 'Card Creator', appSubtitle: 'Erstellen Sie Ihre eigenen personalisierten Sammelkarten', hoverHint: '‚ú® Fahren Sie mit der Maus √ºber die Karte,um den Effekt zu verst√§rken ‚ú®', elements: { Fire: 'Feuer', Water: 'Wasser', Nature: 'Natur', Electric: 'Elektro', Mystic: 'Mystik', Fighting: 'Kampf', Shadow: 'Schatten', Metal: 'Metall', Light: 'Licht', Dragon: 'Drache', Ice: 'Eis', Neutral: 'Neutral' }, effects: { none: { name: 'Keiner', description: 'Kein Effekt' }, holographic: { name: 'Holografisch', description: 'Klassischer Regenbogeneffekt' }, rainbow: { name: 'Regenbogen', description: 'Animierter mehrfarbiger Verlauf' }, gold: { name: 'Gold', description: 'Luxuri√∂se goldene Reflexionen' }, silver: { name: 'Silber', description: 'Metallische Silberreflexionen' }, prismatic: { name: 'Prismatisch', description: 'Brechender Kristalleffekt' }, neon: { name: 'Neon', description: 'Lebhaftes Neonleuchten' }, galaxy: { name: 'Galaxie', description: 'Sternenkosmischer Effekt' }, fire: { name: 'Flammen', description: 'Animierter Flammeneffekt' }, ice: { name: 'Frost', description: 'Funkelnder Eiseffekt' } }, stages: ['Basis', 'Phase 1', 'Phase 2', 'Spezial', 'Legend√§r', 'Mythisch', 'Ultra'], rarities: { common: 'Gew√∂hnlich', uncommon: 'Ungew√∂hnlich', rare: 'Selten', epic: 'Episch', legendary: 'Legend√§r', mythic: 'Mythisch' }, sections: { image: 'Bild', basicInfo: 'Grundinformationen', rarityEffects: 'Seltenheit & Effekte', abilities: 'F√§higkeiten', stats: 'Statistiken', appearance: 'Aussehen' }, labels: { name: 'Name', hp: 'Lebenspunkte', element: 'Element', stage: 'Phase', description: 'Beschreibung', author: 'Autor', rarity: 'Seltenheit', effect: 'Effekt', weakness: 'Schw√§che', resistance: 'Resistenz', retreatCost: 'R√ºckzugskosten', abilityName: 'F√§higkeitsname', damage: 'Schaden', energyCost: 'Energiekosten', abilityDesc: 'F√§higkeitenbeschreibung', borderColor: 'Rahmenfarbe', backgroundColor: 'Hintergrundfarbe', textColor: 'Textfarbe', font: 'Schriftart', zoom: 'Zoom' }, buttons: { addAbility: '+ F√§higkeit hinzuf√ºgen', remove: 'Entfernen', change: '√Ñndern', recenter: 'Zentrieren', download: 'Herunterladen', autoRotate: '3D-Vorschau' }, checkboxes: { showHP: 'Lebenspunkte anzeigen', showWeakRes: 'Schw√§che/Resistenz anzeigen', showRetreat: 'R√ºckzugskosten anzeigen', showDescription: 'Beschreibung anzeigen', showTexture: 'Muster anzeigen', showParticles: 'Partikel anzeigen', showDamage: 'Schaden anzeigen' }, imageEditor: { dropHint: 'Bild hier ablegen', orClick: 'oder klicken zum Ausw√§hlen', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Laden...', unsupportedFormat: 'Nicht unterst√ºtztes Format. Verwenden Sie PNG,JPG,GIF oder WEBP.', fileTooLarge: 'Datei zu gro√ü. Maximal 15MB.' },
        download: { title: 'üì• Herunterladen', pngTitle: 'Transparentes PNG-Bild', jpgTitle: 'JPG-Bild mit Hintergrund', gifTitle: 'Animiertes GIF (3 Sekunden)', htmlTitle: 'Interaktive HTML-Datei', capturing: '‚è≥ Aufnahme...', encoding: '‚öôÔ∏è Kodierung...' },
        card: { hp: 'KP', weakness: 'Schw√§che', resistance: 'Resistenz', cost: 'Kosten', illus: 'Illus.' }, defaults: { newAbility: 'Neue F√§higkeit' }, display: { title: 'Anzeigeoptionen' }, tabs: { info: 'Info', content: 'Inhalt', visual: 'Visuell', style: 'Stil', colors: 'Farben' },
        imageEditor: { dropHint: 'Bild hier ablegen', orClick: 'oder klicken zum Ausw√§hlen', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Laden...', unsupportedFormat: 'Nicht unterst√ºtztes Format. Verwenden Sie PNG,JPG,GIF oder WEBP.', fileTooLarge: 'Datei zu gro√ü. Maximal 15MB.', searchPlaceholder: 'Tippen...' },
        download: { title: 'üì• Herunterladen', pngTitle: 'Transparentes PNG-Bild', jpgTitle: 'JPG-Bild mit Hintergrund', gifTitle: 'Animiertes GIF (3 Sekunden)', webpTitle: 'WebP-Bild', htmlTitle: 'Interaktive HTML-Datei', capturing: '‚è≥ Aufnahme...', encoding: '‚öôÔ∏è Kodierung...' },
        labels: { name: 'Name', hp: 'Lebenspunkte', element: 'Element', stage: 'Phase', description: 'Beschreibung', author: 'Autor', effect: 'Effekt', weakness: 'Schw√§che', resistance: 'Resistenz', retreatCost: 'R√ºckzugskosten', abilityName: 'F√§higkeitsname', damage: 'Schaden', energyCost: 'Energiekosten', abilityDesc: 'Beschreibung', borderColor: 'Rahmenfarbe', backgroundColor: 'Kartenhintergrund', abilityBackground: 'F√§higkeitshintergrund', textColor: 'Textfarbe', font: 'Schriftart', size: 'Gr√∂√üe', weight: 'Dicke', zoom: 'Zoom', presets: 'Voreinstellungen', backgroundStyle: 'Hintergrundstil', solid: 'Einfarbig', gradient: 'Verlauf', cardInner: 'Karteninneres', primaryColor: 'Prim√§rfarbe', secondaryColor: 'Sekund√§rfarbe', nameColor: 'Namensfarbe', hpColor: 'LP-Farbe', typeColor: 'Typfarbe', descColor: 'Beschreibungsfarbe', statsColor: 'Statistikfarbe', authorColor: 'Autorenfarbe' },
        prompts: { resetConfirm: 'Alle Kartendaten zur√ºcksetzen?', autoDeleteInfo: 'Karten werden nach 30 Tagen gel√∂scht.' },
        buttons: { addAbility: '+ Hinzuf√ºgen', remove: 'Entfernen', change: '√Ñndern', recenter: 'Zentrieren', download: 'Herunterladen', autoRotate: '3D-Ansicht', resetCard: 'üîÑ Zur√ºcksetzen', save: 'Speichern', load: 'Laden', deleteAll: 'Alle l√∂schen' },
        sections: { image: 'Bild', basicInfo: 'Grundinformationen', rarityEffects: 'Effekte', abilities: 'F√§higkeiten', stats: 'Statistiken', appearance: 'Aussehen', cardStyle: 'Kartenstil', textStyle: 'Textstil', particles: 'Partikel', abilityStyle: 'F√§higkeiten-Stil', reset: 'Zur√ºcksetzen' },
        labels: { name: 'Name', hp: 'Lebenspunkte', element: 'Element', stage: 'Phase', description: 'Beschreibung', author: 'Autor', effect: 'Effekt', weakness: 'Schw√§che', resistance: 'Resistenz', retreatCost: 'R√ºckzugskosten', abilityName: 'F√§higkeitsname', damage: 'Schaden', energyCost: 'Energiekosten', abilityDesc: 'Beschreibung', borderColor: 'Rahmenfarbe', backgroundColor: 'Kartenhintergrund', abilityBackground: 'F√§higkeitshintergrund', textColor: 'Textfarbe', font: 'Schriftart', size: 'Gr√∂√üe', weight: 'Dicke', zoom: 'Zoom', presets: 'Voreinstellungen', backgroundStyle: 'Hintergrundstil', solid: 'Einfarbig', gradient: 'Verlauf', cardInner: 'Karteninneres', primaryColor: 'Prim√§rfarbe', secondaryColor: 'Sekund√§rfarbe', nameColor: 'Namensfarbe', hpColor: 'LP-Farbe', typeColor: 'Typfarbe', descColor: 'Beschreibungsfarbe', statsColor: 'Statistikfarbe', authorColor: 'Autorenfarbe', particleEmoji: 'Partikel-Emoji', animation: 'Animation' },
        textures: { none: 'Keine', grid: 'Gitter', scales: 'Schuppen', cross: 'Kreuz', stars: 'Sterne', hexagons: 'Sechsecke', lines: 'Linien', dots: 'Punkte', waves: 'Wellen', circuit: 'Schaltung' },
        animations: { fire: 'Aufsteigend', water: 'Blasen', nature: 'Schwebend', electric: 'Funken', mystic: 'Magie', fighting: 'Einschlag', shadow: 'Verblassen', metal: 'Zahnr√§der', light: 'Strahlen', dragon: 'Majest√§tisch', ice: 'Schnee', neutral: 'Subtil' },
        common: { cancel: 'Abbrechen', close: 'Schlie√üen' }
      },
      ru: {
        gifModal: {
          title: "üìπ –í—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–∞—è GIF-—Å—ä–µ–º–∫–∞",
          body: "–î–ª—è –∏–¥–µ–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –Ω–∞–º –Ω—É–∂–Ω–æ –∑–∞—Ö–≤–∞—Ç–∏—Ç—å —ç–∫—Ä–∞–Ω:",
          step1: "–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é <strong>\"–í–∫–ª–∞–¥–∫–∞\"</strong>.",
          step2: "–í—ã–±–µ—Ä–∏—Ç–µ <strong>—ç—Ç—É —Å—Ç—Ä–∞–Ω–∏—Ü—É</strong> –∏–∑ —Å–ø–∏—Å–∫–∞.",
          step3: "–ù–∞–∂–º–∏—Ç–µ <strong>\"–ü–æ–¥–µ–ª–∏—Ç—å—Å—è\"</strong>.",
          note: "–ú—ã—à—å –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫—Ä—ã—Ç–∞, –∞ –∫–∞—Ä—Ç–∞ –æ–±—Ä–µ–∑–∞–Ω–∞.",
          warning: "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ (60 FPS / 4K) –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–Ω–æ–≥–æ —Ä–µ—Å—É—Ä—Å–æ–≤ –¶–ü.",
          fpsLabel: "FPS",
          qualityLabel: "–ö–∞—á–µ—Å—Ç–≤–æ (–í—ã—Å–æ—Ç–∞)",
          fpsNormal: "15 FPS (–ù–æ—Ä–º–∞–ª—å–Ω–æ)",
          fpsCinema: "24 FPS (–ö–∏–Ω–æ)",
          fpsSmooth: "30 FPS (–ü–ª–∞–≤–Ωo)",
          fpsUltra: "60 FPS (–£–ª—å—Ç—Ä–∞)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "–û—Ç–º–µ–Ω–∞",
          start: "–ù–∞—á–∞—Ç—å –∑–∞—Ö–≤–∞—Ç"
        },
        appTitle: 'Card Creator', appSubtitle: '–°–æ–∑–¥–∞–≤–∞–π—Ç–µ —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã', hoverHint: '‚ú® –ù–∞–≤–µ–¥–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É, —á—Ç–æ–±—ã —É—Å–∏–ª–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç ‚ú®', elements: { Fire: '–û–≥–æ–Ω—å', Water: '–í–æ–¥–∞', Nature: '–ü—Ä–∏—Ä–æ–¥–∞', Electric: '–≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ', Mystic: '–ú–∏—Å—Ç–∏–∫–∞', Fighting: '–ë–æ–µ–≤–æ–π', Shadow: '–¢–µ–Ω—å', Metal: '–ú–µ—Ç–∞–ª–ª', Light: '–°–≤–µ—Ç', Dragon: '–î—Ä–∞–∫–æ–Ω', Ice: '–õ—ë–¥', Neutral: '–ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π' }, effects: { none: { name: '–ù–µ—Ç', description: '–ë–µ–∑ —ç—Ñ—Ñ–µ–∫—Ç–∞' }, holographic: { name: '–ì–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π', description: '–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π —Ä–∞–¥—É–∂–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç' }, rainbow: { name: '–†–∞–¥—É–≥–∞', description: '–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–Ω–æ–≥–æ—Ü–≤–µ—Ç–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç' }, gold: { name: '–ó–æ–ª–æ—Ç–æ', description: '–†–æ—Å–∫–æ—à–Ω—ã–µ –∑–æ–ª–æ—Ç—ã–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è' }, silver: { name: '–°–µ—Ä–µ–±—Ä–æ', description: '–ú–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–µ —Å–µ—Ä–µ–±—Ä—è–Ω—ã–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è' }, prismatic: { name: '–ü—Ä–∏–∑–º–∞—Ç–∏—á–µ—Å–∫–∏–π', description: '–≠—Ñ—Ñ–µ–∫—Ç –ø—Ä–µ–ª–æ–º–ª—è—é—â–µ–≥–æ –∫—Ä–∏—Å—Ç–∞–ª–ª–∞' }, neon: { name: '–ù–µ–æ–Ω', description: '–Ø—Ä–∫–æ–µ –Ω–µ–æ–Ω–æ–≤–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ' }, galaxy: { name: '–ì–∞–ª–∞–∫—Ç–∏–∫–∞', description: '–ó–≤—ë–∑–¥–Ω—ã–π –∫–æ—Å–º–∏—á–µ—Å–∫–∏–π —ç—Ñ—Ñ–µ–∫—Ç' }, fire: { name: '–ü–ª–∞–º—è', description: '–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –æ–≥–Ω—è' }, ice: { name: '–õ—ë–¥', description: '–°–≤–µ—Ä–∫–∞—é—â–∏–π –ª–µ–¥—è–Ω–æ–π —ç—Ñ—Ñ–µ–∫—Ç' } }, stages: ['–ë–∞–∑–æ–≤—ã–π', '–°—Ç–∞–¥–∏—è 1', '–°—Ç–∞–¥–∏—è 2', '–û—Å–æ–±—ã–π', '–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω—ã–π', '–ú–∏—Ñ–∏—á–µ—Å–∫–∏–π', '–£–ª—å—Ç—Ä–∞'], rarities: { common: '–û–±—ã—á–Ω–∞—è', uncommon: '–ù–µ–æ–±—ã—á–Ω–∞—è', rare: '–†–µ–¥–∫–∞—è', epic: '–≠–ø–∏—á–µ—Å–∫–∞—è', legendary: '–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–∞—è', mythic: '–ú–∏—Ñ–∏—á–µ—Å–∫–∞—è' }, sections: { image: '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', basicInfo: '–û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', rarityEffects: '–†–µ–¥–∫–æ—Å—Ç—å –∏ –≠—Ñ—Ñ–µ–∫—Ç—ã', abilities: '–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏', stats: '–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏', appearance: '–í–Ω–µ—à–Ω–∏–π –≤–∏–¥' }, labels: { name: '–ò–º—è', hp: '–û—á–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è', element: '–≠–ª–µ–º–µ–Ω—Ç', stage: '–°—Ç–∞–¥–∏—è', description: '–û–ø–∏—Å–∞–Ω–∏–µ', author: '–ê–≤—Ç–æ—Ä', rarity: '–†–µ–¥–∫–æ—Å—Ç—å', effect: '–≠—Ñ—Ñ–µ–∫—Ç', weakness: '–°–ª–∞–±–æ—Å—Ç—å', resistance: '–°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ', retreatCost: '–°—Ç–æ–∏–º–æ—Å—Ç—å –æ—Ç—Å—Ç—É–ø–ª–µ–Ω–∏—è', abilityName: '–ù–∞–∑–≤–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏', damage: '–£—Ä–æ–Ω', energyCost: '–°—Ç–æ–∏–º–æ—Å—Ç—å —ç–Ω–µ—Ä–≥–∏–∏', abilityDesc: '–û–ø–∏—Å–∞–Ω–∏–µ –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π', borderColor: '–¶–≤–µ—Ç —Ä–∞–º–∫–∏', backgroundColor: '–¶–≤–µ—Ç —Ñ–æ–Ω–∞', textColor: '–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞', font: '–®—Ä–∏—Ñ—Ç', zoom: '–ú–∞—Å—à—Ç–∞–±' }, buttons: { addAbility: '+ –î–æ–±–∞–≤–∏—Ç—å —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å', remove: '–£–¥–∞–ª–∏—Ç—å', change: '–ò–∑–º–µ–Ω–∏—Ç—å', recenter: '–¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å', download: '–°–∫–∞—á–∞—Ç—å', autoRotate: '3D –ø—Ä–æ—Å–º–æ—Ç—Ä' }, checkboxes: { showHP: '–ü–æ–∫–∞–∑–∞—Ç—å –æ—á–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è', showWeakRes: '–ü–æ–∫–∞–∑–∞—Ç—å —Å–ª–∞–±–æ—Å—Ç—å/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ', showRetreat: '–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å –æ—Ç—Å—Ç—É–ø–ª–µ–Ω–∏—è', showDescription: '–ü–æ–∫–∞–∑–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ', showTexture: '–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—Å—Ç—É—Ä—É', showParticles: '–ü–æ–∫–∞–∑–∞—Ç—å —á–∞—Å—Ç–∏—Ü—ã', showDamage: '–ü–æ–∫–∞–∑–∞—Ç—å —É—Ä–æ–Ω' }, imageEditor: { dropHint: '–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞', orClick: '–∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞', formats: 'PNG,JPG,GIF,WEBP (–º–∞–∫—Å 15–ú–ë)', loading: '–ó–∞–≥—Ä—É–∑–∫–∞...', unsupportedFormat: '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PNG,JPG,GIF –∏–ª–∏ WEBP.', fileTooLarge: '–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π. –ú–∞–∫—Å–∏–º—É–º 15–ú–ë.' },
        download: { title: 'üì• –°–∫–∞—á–∞—Ç—å', pngTitle: '–ü—Ä–æ–∑—Ä–∞—á–Ω–æ–µ PNG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', jpgTitle: 'JPG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å —Ñ–æ–Ω–æ–º', gifTitle: '–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π GIF (3 —Å–µ–∫—É–Ω–¥—ã)', htmlTitle: '–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π HTML —Ñ–∞–π–ª', capturing: '‚è≥ –ó–∞—Ö–≤–∞—Ç...', encoding: '‚öôÔ∏è –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ...' },
        card: { hp: '–û–ó', weakness: '–°–ª–∞–±–æ—Å—Ç—å', resistance: '–°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ', cost: '–°—Ç–æ–∏–º–æ—Å—Ç—å', illus: '–•—É–¥.' }, defaults: { newAbility: '–ù–æ–≤–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å' }, display: { title: '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è' }, tabs: { info: '–ò–Ω—Ñ–æ', content: '–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ', visual: '–í–∏–∑—É–∞–ª', style: '–°—Ç–∏–ª—å', colors: '–¶–≤–µ—Ç–∞' },
        imageEditor: { dropHint: '–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞', orClick: '–∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –≤—ã–±–æ—Ä–∞', formats: 'PNG,JPG,GIF,WEBP (–º–∞–∫—Å 15–ú–ë)', loading: '–ó–∞–≥—Ä—É–∑–∫–∞...', unsupportedFormat: '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PNG,JPG,GIF –∏–ª–∏ WEBP.', fileTooLarge: '–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π. –ú–∞–∫—Å–∏–º—É–º 15–ú–ë.', searchPlaceholder: '–í–≤–µ–¥–∏—Ç–µ...' },
        download: { title: 'üì• –°–∫–∞—á–∞—Ç—å', pngTitle: '–ü—Ä–æ–∑—Ä–∞—á–Ω–æ–µ PNG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', jpgTitle: 'JPG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å —Ñ–æ–Ω–æ–º', gifTitle: '–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π GIF (3 —Å–µ–∫—É–Ω–¥—ã)', webpTitle: 'WebP –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', htmlTitle: '–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π HTML —Ñ–∞–π–ª', capturing: '‚è≥ –ó–∞—Ö–≤–∞—Ç...', encoding: '‚öôÔ∏è –ö–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ...' },
        labels: { name: '–ò–º—è', hp: '–û—á–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è', element: '–≠–ª–µ–º–µ–Ω—Ç', stage: '–°—Ç–∞–¥–∏—è', description: '–û–ø–∏—Å–∞–Ω–∏–µ', author: '–ê–≤—Ç–æ—Ä', effect: '–≠—Ñ—Ñ–µ–∫—Ç', weakness: '–°–ª–∞–±–æ—Å—Ç—å', resistance: '–°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ', retreatCost: '–°—Ç–æ–∏–º–æ—Å—Ç—å –æ—Ç—Å—Ç—É–ø–ª–µ–Ω–∏—è', abilityName: '–ù–∞–∑–≤–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏', damage: '–£—Ä–æ–Ω', energyCost: '–°—Ç–æ–∏–º–æ—Å—Ç—å —ç–Ω–µ—Ä–≥–∏–∏', abilityDesc: '–û–ø–∏—Å–∞–Ω–∏–µ', borderColor: '–¶–≤–µ—Ç —Ä–∞–º–∫–∏', backgroundColor: '–§–æ–Ω –∫–∞—Ä—Ç—ã', abilityBackground: '–§–æ–Ω —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏', textColor: '–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞', font: '–®—Ä–∏—Ñ—Ç', size: '–†–∞–∑–º–µ—Ä', weight: '–í–µ—Å', zoom: '–ú–∞—Å—à—Ç–∞–±', presets: '–ü—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏', backgroundStyle: '–°—Ç–∏–ª—å —Ñ–æ–Ω–∞', solid: '–°–ø–ª–æ—à–Ω–æ–π', gradient: '–ì—Ä–∞–¥–∏–µ–Ω—Ç', cardInner: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —á–∞—Å—Ç—å –∫–∞—Ä—Ç—ã', primaryColor: '–û—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç', secondaryColor: '–í—Ç–æ—Ä–∏—á–Ω—ã–π —Ü–≤–µ—Ç', nameColor: '–¶–≤–µ—Ç –∏–º–µ–Ω–∏', hpColor: '–¶–≤–µ—Ç –û–ó', typeColor: '–¶–≤–µ—Ç —Ç–∏–ø–∞', descColor: '–¶–≤–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è', statsColor: '–¶–≤–µ—Ç —Ö–∞—Ä-–∫', authorColor: '–¶–≤–µ—Ç –∞–≤—Ç–æ—Ä–∞' },
        prompts: { resetConfirm: '–°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã?', autoDeleteInfo: '–ö–∞—Ä—Ç—ã —É–¥–∞–ª—è—é—Ç—Å—è —á–µ—Ä–µ–∑ 30 –¥–Ω–µ–π.' },
        buttons: { addAbility: '+ –î–æ–±–∞–≤–∏—Ç—å', remove: '–£–¥–∞–ª–∏—Ç—å', change: '–ò–∑–º–µ–Ω–∏—Ç—å', recenter: '–¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å', download: '–°–∫–∞—á–∞—Ç—å', autoRotate: '3D-–≤–∏–¥', resetCard: 'üîÑ –°–±—Ä–æ—Å', save: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å', load: '–ó–∞–≥—Ä—É–∑–∏—Ç—å', deleteAll: '–£–¥–∞–ª–∏—Ç—å –≤—Å–µ' },
        sections: { image: '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', basicInfo: '–û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', rarityEffects: '–≠—Ñ—Ñ–µ–∫—Ç—ã', abilities: '–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏', stats: '–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏', appearance: '–í–Ω–µ—à–Ω–∏–π –≤–∏–¥', cardStyle: '–°—Ç–∏–ª—å –∫–∞—Ä—Ç—ã', textStyle: '–°—Ç–∏–ª—å —Ç–µ–∫—Å—Ç–∞', particles: '–ß–∞—Å—Ç–∏—Ü—ã', abilityStyle: '–°—Ç–∏–ª—å —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π', reset: '–°–±—Ä–æ—Å' },
        labels: { name: '–ò–º—è', hp: '–û—á–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è', element: '–≠–ª–µ–º–µ–Ω—Ç', stage: '–°—Ç–∞–¥–∏—è', description: '–û–ø–∏—Å–∞–Ω–∏–µ', author: '–ê–≤—Ç–æ—Ä', effect: '–≠—Ñ—Ñ–µ–∫—Ç', weakness: '–°–ª–∞–±–æ—Å—Ç—å', resistance: '–°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ', retreatCost: '–°—Ç–æ–∏–º–æ—Å—Ç—å –æ—Ç—Å—Ç—É–ø–ª–µ–Ω–∏—è', abilityName: '–ù–∞–∑–≤–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏', damage: '–£—Ä–æ–Ω', energyCost: '–°—Ç–æ–∏–º–æ—Å—Ç—å —ç–Ω–µ—Ä–≥–∏–∏', abilityDesc: '–û–ø–∏—Å–∞–Ω–∏–µ', borderColor: '–¶–≤–µ—Ç —Ä–∞–º–∫–∏', backgroundColor: '–§–æ–Ω –∫–∞—Ä—Ç—ã', abilityBackground: '–§–æ–Ω —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏', textColor: '–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞', font: '–®—Ä–∏—Ñ—Ç', size: '–†–∞–∑–º–µ—Ä', weight: '–í–µ—Å', zoom: '–ú–∞—Å—à—Ç–∞–±', presets: '–ü—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–∫–∏', backgroundStyle: '–°—Ç–∏–ª—å —Ñ–æ–Ω–∞', solid: '–°–ø–ª–æ—à–Ω–æ–π', gradient: '–ì—Ä–∞–¥–∏–µ–Ω—Ç', cardInner: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —á–∞—Å—Ç—å –∫–∞—Ä—Ç—ã', primaryColor: '–û—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç', secondaryColor: '–í—Ç–æ—Ä–∏—á–Ω—ã–π —Ü–≤–µ—Ç', nameColor: '–¶–≤–µ—Ç –∏–º–µ–Ω–∏', hpColor: '–¶–≤–µ—Ç –û–ó', typeColor: '–¶–≤–µ—Ç —Ç–∏–ø–∞', descColor: '–¶–≤–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è', statsColor: '–¶–≤–µ—Ç —Ö–∞—Ä-–∫', authorColor: '–¶–≤–µ—Ç –∞–≤—Ç–æ—Ä–∞', particleEmoji: '–≠–º–æ–¥–∑–∏ —á–∞—Å—Ç–∏—Ü', animation: '–ê–Ω–∏–º–∞—Ü–∏—è' },
        textures: { none: '–ù–µ—Ç', grid: '–°–µ—Ç–∫–∞', scales: '–ß–µ—à—É—è', cross: '–ö—Ä–µ—Å—Ç', stars: '–ó–≤–µ–∑–¥—ã', hexagons: '–®–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫–∏', lines: '–õ–∏–Ω–∏–∏', dots: '–¢–æ—á–∫–∏', waves: '–í–æ–ª–Ω—ã', circuit: '–°—Ö–µ–º–∞' },
        animations: { fire: '–í–æ—Å—Ö–æ–¥—è—â–∏–π', water: '–ü—É–∑—ã—Ä–∏', nature: '–ü–∞—Ä—è—â–∏–π', electric: '–ò—Å–∫—Ä—ã', mystic: '–ú–∞–≥–∏—è', fighting: '–£–¥–∞—Ä', shadow: '–ó–∞—Ç—É—Ö–∞–Ω–∏–µ', metal: '–®–µ—Å—Ç–µ—Ä–µ–Ω–∫–∏', light: '–°–∏—è–Ω–∏–µ', dragon: '–í–µ–ª–∏—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π', ice: '–°–Ω–µ–≥', neutral: '–¢–æ–Ω–∫–∏–π' },
        common: { cancel: '–û—Ç–º–µ–Ω–∞', close: '–ó–∞–∫—Ä—ã—Ç—å' }
      },
      ja: {
        gifModal: {
          title: "üìπ È´òÂìÅË≥™GIF„Ç≠„É£„Éó„ÉÅ„É£",
          body: "ÂÆåÁíß„Å™ÁµêÊûú„ÇíÂæó„Çã„Åü„ÇÅ„Å´„ÄÅÁîªÈù¢„Çí„Ç≠„É£„Éó„ÉÅ„É£„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„ÅôÔºö",
          step1: "<strong>„Äå„Çø„Éñ„Äç</strong>„Ç™„Éó„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ",
          step2: "„É™„Çπ„Éà„Åã„Çâ<strong>„Åì„ÅÆ„Éö„Éº„Ç∏</strong>„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ",
          step3: "<strong>„ÄåÂÖ±Êúâ„Äç</strong>„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åæ„Åô„ÄÇ",
          note: "„Éû„Ç¶„Çπ„ÅØËá™ÂãïÁöÑ„Å´ÈùûË°®Á§∫„Å´„Å™„Çä„ÄÅ„Ç´„Éº„Éâ„ÅØÂàá„ÇäÂèñ„Çâ„Çå„Åæ„Åô„ÄÇ",
          warning: "ÊúÄÂ§ßË®≠ÂÆöÔºà60 FPS / 4KÔºâ„Çí‰ΩøÁî®„Åô„Çã„Å®„ÄÅÊôÇÈñì„Åå„Åã„Åã„Çä„ÄÅCPU‰ΩøÁî®Áéá„ÅåÈ´ò„Åè„Å™„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
          fpsLabel: "FPS",
          qualityLabel: "ÂìÅË≥™ (È´ò„Åï)",
          fpsNormal: "15 FPS (ÈÄöÂ∏∏)",
          fpsCinema: "24 FPS („Ç∑„Éç„Éû)",
          fpsSmooth: "30 FPS („Çπ„É†„Éº„Ç∫)",
          fpsUltra: "60 FPS („Ç¶„É´„Éà„É©)",
          qualitySD: "480p (Ê®ôÊ∫ñ)",
          qualityNormal: "720p (È´òÁîªË≥™)",
          qualityHigh: "1080p („Éï„É´HD)",
          qualityQHD: "1440p (2K)",
          qualityUltra: "4K (Ë∂ÖÈ´òÁîªË≥™)",
          cancel: "„Ç≠„É£„É≥„Çª„É´",
          start: "„Ç≠„É£„Éó„ÉÅ„É£ÈñãÂßã"
        },
        appTitle: 'Card Creator', appSubtitle: '„Ç™„É™„Ç∏„Éä„É´„ÅÆ„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥„Ç´„Éº„Éâ„Çí‰ΩúÊàê„Åó„Çà„ÅÜ', hoverHint: '‚ú® „Ç´„Éº„Éâ„Å´„Éû„Ç¶„Çπ„Çí‰πó„Åõ„Çã„Å®„Ç®„Éï„Çß„ÇØ„Éà„ÅåÂº∑„Åè„Å™„Çä„Åæ„Åô ‚ú®', elements: { Fire: 'ÁÇé', Water: 'Ê∞¥', Nature: 'Ëá™ÁÑ∂', Electric: 'ÈõªÊ∞ó', Mystic: 'Á•ûÁßò', Fighting: 'Ê†ºÈóò', Shadow: 'Èóá', Metal: 'Èãº', Light: 'ÂÖâ', Dragon: '„Éâ„É©„Ç¥„É≥', Ice: 'Ê∞∑', Neutral: 'ÁÑ°' }, effects: { none: { name: '„Å™„Åó', description: '„Ç®„Éï„Çß„ÇØ„Éà„Å™„Åó' }, holographic: { name: '„Éõ„É≠„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ', description: '„ÇØ„É©„Ç∑„ÉÉ„ÇØ„Å™ËôπËâ≤„Ç®„Éï„Çß„ÇØ„Éà' }, rainbow: { name: '„É¨„Ç§„É≥„Éú„Éº', description: '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Ç´„É©„Éº„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥' }, gold: { name: '„Ç¥„Éº„É´„Éâ', description: 'Ë±™ËèØ„Å™ÈáëËâ≤„ÅÆÂèçÂ∞Ñ' }, silver: { name: '„Ç∑„É´„Éê„Éº', description: '„É°„Çø„É™„ÉÉ„ÇØ„Å™ÈäÄËâ≤„ÅÆÂèçÂ∞Ñ' }, prismatic: { name: '„Éó„É™„Ç∫„Éû„ÉÜ„Ç£„ÉÉ„ÇØ', description: 'Â±àÊäò„Åô„Çã„ÇØ„É™„Çπ„Çø„É´„Ç®„Éï„Çß„ÇØ„Éà' }, neon: { name: '„Éç„Ç™„É≥', description: 'ÈÆÆ„ÇÑ„Åã„Å™„Éç„Ç™„É≥„ÅÆËºù„Åç' }, galaxy: { name: '„ÇÆ„É£„É©„ÇØ„Ç∑„Éº', description: 'ÊòüÁ©∫„ÅÆÂÆáÂÆô„Ç®„Éï„Çß„ÇØ„Éà' }, fire: { name: '„Éï„É¨„Ç§„É†', description: '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁÇé„Ç®„Éï„Çß„ÇØ„Éà' }, ice: { name: '„Éï„É≠„Çπ„Éà', description: '„Åç„Çâ„ÇÅ„ÅèÊ∞∑„Ç®„Éï„Çß„ÇØ„Éà' } }, stages: ['„Éô„Éº„Ç∑„ÉÉ„ÇØ', '„Çπ„ÉÜ„Éº„Ç∏1', '„Çπ„ÉÜ„Éº„Ç∏2', '„Çπ„Éö„Ç∑„É£„É´', '„É¨„Ç∏„Çß„É≥„ÉÄ„É™„Éº', '„Éü„Ç∑„ÉÉ„ÇØ', '„Ç¶„É´„Éà„É©'], rarities: { common: '„Ç≥„É¢„É≥', uncommon: '„Ç¢„É≥„Ç≥„É¢„É≥', rare: '„É¨„Ç¢', epic: '„Ç®„Éî„ÉÉ„ÇØ', legendary: '„É¨„Ç∏„Çß„É≥„ÉÄ„É™„Éº', mythic: '„Éü„Ç∑„ÉÉ„ÇØ' }, sections: { image: 'ÁîªÂÉè', basicInfo: 'Âü∫Êú¨ÊÉÖÂ†±', rarityEffects: '„É¨„Ç¢„É™„ÉÜ„Ç£ÔºÜ„Ç®„Éï„Çß„ÇØ„Éà', abilities: 'ÊäÄ', stats: '„Çπ„ÉÜ„Éº„Çø„Çπ', appearance: 'Â§ñË¶≥' }, labels: { name: 'ÂêçÂâç', hp: 'HP', element: '„Çø„Ç§„Éó', stage: '„Çπ„ÉÜ„Éº„Ç∏', description: 'Ë™¨Êòé', author: '‰ΩúËÄÖ', rarity: '„É¨„Ç¢„É™„ÉÜ„Ç£', effect: '„Ç®„Éï„Çß„ÇØ„Éà', weakness: 'Âº±ÁÇπ', resistance: 'ÊäµÊäóÂäõ', retreatCost: '„Å´„Åí„Çã„Ç≥„Çπ„Éà', abilityName: 'ÊäÄÂêç', damage: '„ÉÄ„É°„Éº„Ç∏', „Ç®„Éç„É´„ÇÆ„Éº„Ç≥„Çπ„Éà: '„Ç®„Éç„É´„ÇÆ„Éº„Ç≥„Çπ„Éà', abilityDesc: 'ÊäÄ„ÅÆË™¨Êòé', borderColor: 'Êû†„ÅÆËâ≤', backgroundColor: 'ËÉåÊôØËâ≤', textColor: 'ÊñáÂ≠óËâ≤', font: '„Éï„Ç©„É≥„Éà', zoom: '„Ç∫„Éº„É†' }, buttons: { addAbility: '+ ÊäÄ„ÇíËøΩÂä†', remove: 'ÂâäÈô§', change: 'Â§âÊõ¥', recenter: '‰∏≠Â§Æ„Å´Êàª„Åô', download: '„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ', autoRotate: '3D„Éó„É¨„Éì„É•„Éº' }, checkboxes: { showHP: 'HP„ÇíË°®Á§∫', showWeakRes: 'Âº±ÁÇπ/ÊäµÊäóÂäõ„ÇíË°®Á§∫', showRetreat: '„Å´„Åí„Çã„Ç≥„Çπ„Éà„ÇíË°®Á§∫', showDescription: 'Ë™¨Êòé„ÇíË°®Á§∫', showTexture: '„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíË°®Á§∫', showParticles: '„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÇíË°®Á§∫', showDamage: '„ÉÄ„É°„Éº„Ç∏„ÇíË°®Á§∫' }, imageEditor: { dropHint: '„Åì„Åì„Å´ÁîªÂÉè„Çí„Éâ„É≠„ÉÉ„Éó', orClick: '„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû', formats: 'PNG,JPG,GIF,WEBP (ÊúÄÂ§ß15MB)', loading: 'Ë™≠„ÅøËæº„Åø‰∏≠...', unsupportedFormat: '„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂΩ¢Âºè„Åß„Åô„ÄÇPNG„ÄÅJPG„ÄÅGIF„ÄÅWEBP„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', fileTooLarge: '„Éï„Ç°„Ç§„É´„ÅåÂ§ß„Åç„Åô„Åé„Åæ„Åô„ÄÇÊúÄÂ§ß15MB„Åß„Åô„ÄÇ' },
        download: { title: 'üì• „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ', pngTitle: 'ÈÄèÈÅéPNGÁîªÂÉè', jpgTitle: 'ËÉåÊôØ‰ªò„ÅçJPGÁîªÂÉè', gifTitle: '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥GIFÔºà3ÁßíÔºâ', htmlTitle: '„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñHTML„Éï„Ç°„Ç§„É´', capturing: '‚è≥ „Ç≠„É£„Éó„ÉÅ„É£‰∏≠...', encoding: '‚öôÔ∏è „Ç®„É≥„Ç≥„Éº„Éâ‰∏≠...' },
        card: { hp: 'HP', weakness: 'Âº±ÁÇπ', resistance: 'ÊäµÊäóÂäõ', cost: '„Ç≥„Çπ„Éà', illus: '„Ç§„É©„Çπ„Éà' }, defaults: { newAbility: 'Êñ∞„Åó„ÅÑÊäÄ' }, display: { title: 'Ë°®Á§∫„Ç™„Éó„Ç∑„Éß„É≥' }, tabs: { info: 'ÊÉÖÂ†±', content: '„Ç≥„É≥„ÉÜ„É≥„ÉÑ', visual: '„Éì„Ç∏„É•„Ç¢„É´', style: '„Çπ„Çø„Ç§„É´', colors: 'Ëâ≤' },
        imageEditor: { dropHint: '„Åì„Åì„Å´ÁîªÂÉè„Çí„Éâ„É≠„ÉÉ„Éó', orClick: '„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû', formats: 'PNG,JPG,GIF,WEBP (ÊúÄÂ§ß15MB)', loading: 'Ë™≠„ÅøËæº„Åø‰∏≠...', unsupportedFormat: '„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂΩ¢Âºè„Åß„Åô„ÄÇPNG„ÄÅJPG„ÄÅGIF„ÄÅWEBP„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', fileTooLarge: '„Éï„Ç°„Ç§„É´„ÅåÂ§ß„Åç„Åô„Åé„Åæ„Åô„ÄÇÊúÄÂ§ß15MB„Åß„Åô„ÄÇ', searchPlaceholder: 'ÂÖ•Âäõ...' },
        download: { title: 'üì• „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ', pngTitle: 'ÈÄèÈÅéPNGÁîªÂÉè', jpgTitle: 'ËÉåÊôØ‰ªò„ÅçJPGÁîªÂÉè', gifTitle: '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥GIFÔºà3ÁßíÔºâ', webpTitle: 'WebPÁîªÂÉè', htmlTitle: '„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñHTML„Éï„Ç°„Ç§„É´', capturing: '‚è≥ „Ç≠„É£„Éó„ÉÅ„É£‰∏≠...', encoding: '‚öôÔ∏è „Ç®„É≥„Ç≥„Éº„Éâ‰∏≠...' },
        labels: { name: 'ÂêçÂâç', hp: 'HP', element: '„Çø„Ç§„Éó', stage: '„Çπ„ÉÜ„Éº„Ç∏', description: 'Ë™¨Êòé', author: '‰ΩúËÄÖ', effect: '„Ç®„Éï„Çß„ÇØ„Éà', weakness: 'Âº±ÁÇπ', resistance: 'ÊäµÊäóÂäõ', retreatCost: '„Å´„Åí„Çã„Ç≥„Çπ„Éà', abilityName: 'ÊäÄÂêç', damage: '„ÉÄ„É°„Éº„Ç∏', energyCost: '„Ç®„Éç„É´„ÇÆ„Éº„Ç≥„Çπ„Éà', abilityDesc: 'Ë™¨Êòé', borderColor: 'Êû†„ÅÆËâ≤', backgroundColor: '„Ç´„Éº„Éâ„ÅÆËÉåÊôØ', abilityBackground: 'ÊäÄ„ÅÆËÉåÊôØ', textColor: 'ÊñáÂ≠óËâ≤', font: '„Éï„Ç©„É≥„Éà', size: '„Çµ„Ç§„Ç∫', weight: 'Â§™„Åï', zoom: '„Ç∫„Éº„É†', presets: '„Éó„É™„Çª„ÉÉ„Éà', backgroundStyle: 'ËÉåÊôØ„Çπ„Çø„Ç§„É´', solid: 'ÂçòËâ≤', gradient: '„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥', cardInner: '„Ç´„Éº„ÉâÂÜÖÂÅ¥', primaryColor: '„É°„Ç§„É≥„Ç´„É©„Éº', secondaryColor: '„Çµ„Éñ„Ç´„É©„Éº', nameColor: 'ÂêçÂâç„ÅÆËâ≤', hpColor: 'HP„ÅÆËâ≤', typeColor: '„Çø„Ç§„Éó„ÅÆËâ≤', descColor: 'Ë™¨Êòé„ÅÆËâ≤', statsColor: '„Çπ„ÉÜ„Éº„Çø„Çπ„ÅÆËâ≤', authorColor: '‰ΩúËÄÖ„ÅÆËâ≤' },
        prompts: { resetConfirm: '„Åô„Åπ„Å¶„ÅÆ„Ç´„Éº„Éâ„Éá„Éº„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü', autoDeleteInfo: '‰øùÂ≠ò„Åï„Çå„Åü„Ç´„Éº„Éâ„ÅØ30Êó•Âæå„Å´ÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ' },
        buttons: { addAbility: '+ ËøΩÂä†', remove: 'ÂâäÈô§', change: 'Â§âÊõ¥', recenter: '‰∏≠Â§ÆÊèÉ„Åà', download: '„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ', autoRotate: '3D„Éì„É•„Éº', resetCard: 'üîÑ „É™„Çª„ÉÉ„Éà', save: '‰øùÂ≠ò', load: 'Ë™≠„ÅøËæº„Åø', deleteAll: '„Åô„Åπ„Å¶ÂâäÈô§' },
        sections: { image: 'ÁîªÂÉè', basicInfo: 'Âü∫Êú¨ÊÉÖÂ†±', rarityEffects: '„Ç®„Éï„Çß„ÇØ„Éà', abilities: 'ÊäÄ', stats: '„Çπ„ÉÜ„Éº„Çø„Çπ', appearance: 'Â§ñË¶≥', cardStyle: '„Ç´„Éº„Éâ„Çπ„Çø„Ç§„É´', textStyle: '„ÉÜ„Ç≠„Çπ„Éà„Çπ„Çø„Ç§„É´', particles: '„Éë„Éº„ÉÜ„Ç£„ÇØ„É´', abilityStyle: 'ÊäÄ„ÅÆ„Çπ„Çø„Ç§„É´', reset: '„É™„Çª„ÉÉ„Éà' },
        labels: { name: 'ÂêçÂâç', hp: 'HP', element: '„Çø„Ç§„Éó', stage: '„Çπ„ÉÜ„Éº„Ç∏', description: 'Ë™¨Êòé', author: '‰ΩúËÄÖ', effect: '„Ç®„Éï„Çß„ÇØ„Éà', weakness: 'Âº±ÁÇπ', resistance: 'ÊäµÊäóÂäõ', retreatCost: '„Å´„Åí„Çã„Ç≥„Çπ„Éà', abilityName: 'ÊäÄÂêç', damage: '„ÉÄ„É°„Éº„Ç∏', energyCost: '„Ç®„Éç„É´„ÇÆ„Éº„Ç≥„Çπ„Éà', abilityDesc: 'Ë™¨Êòé', borderColor: 'Êû†„ÅÆËâ≤', backgroundColor: '„Ç´„Éº„Éâ„ÅÆËÉåÊôØ', abilityBackground: 'ÊäÄ„ÅÆËÉåÊôØ', textColor: 'ÊñáÂ≠óËâ≤', font: '„Éï„Ç©„É≥„Éà', size: '„Çµ„Ç§„Ç∫', weight: 'Â§™„Åï', zoom: '„Ç∫„Éº„É†', presets: '„Éó„É™„Çª„ÉÉ„Éà', backgroundStyle: 'ËÉåÊôØ„Çπ„Çø„Ç§„É´', solid: 'ÂçòËâ≤', gradient: '„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥', cardInner: '„Ç´„Éº„ÉâÂÜÖÂÅ¥', primaryColor: '„É°„Ç§„É≥„Ç´„É©„Éº', secondaryColor: '„Çµ„Éñ„Ç´„É©„Éº', nameColor: 'ÂêçÂâç„ÅÆËâ≤', hpColor: 'HP„ÅÆËâ≤', typeColor: '„Çø„Ç§„Éó„ÅÆËâ≤', descColor: 'Ë™¨Êòé„ÅÆËâ≤', statsColor: '„Çπ„ÉÜ„Éº„Çø„Çπ„ÅÆËâ≤', authorColor: '‰ΩúËÄÖ„ÅÆËâ≤', particleEmoji: '„Éë„Éº„ÉÜ„Ç£„ÇØ„É´ÁµµÊñáÂ≠ó', animation: '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥' },
        textures: { none: '„Å™„Åó', grid: '„Ç∞„É™„ÉÉ„Éâ', scales: 'È±ó', cross: '„ÇØ„É≠„Çπ', stars: 'Êòü', hexagons: '„Éò„Ç≠„Çµ„Ç¥„É≥', lines: '„É©„Ç§„É≥', dots: '„Éâ„ÉÉ„Éà', waves: '„Ç¶„Çß„Éº„Éñ', circuit: 'ÂõûË∑Ø' },
        animations: { fire: '‰∏äÊòá', water: 'Ê≥°', nature: 'ÊµÆÈÅä', electric: 'ÁÅ´Ëä±', mystic: 'È≠îÊ≥ï', fighting: 'Ë°ùÊíÉ', shadow: '„Éï„Çß„Éº„Éâ', metal: 'Ê≠ØËªä', light: 'ÊîæÂ∞Ñ', dragon: 'Â®ÅÂé≥', ice: 'Èõ™', neutral: 'ÂæÆÁ¥∞' },
        common: { cancel: '„Ç≠„É£„É≥„Çª„É´', close: 'Èñâ„Åò„Çã' }
      },
      zh: {
        gifModal: {
          title: "üìπ È´òË¥®ÈáèGIFÊçïËé∑",
          body: "‰∏∫‰∫ÜËé∑ÂæóÂÆåÁæéÁöÑÊïàÊûúÔºåÊàë‰ª¨ÈúÄË¶ÅÊçïËé∑Â±èÂπïÔºö",
          step1: "ÈÄâÊã© <strong>‚ÄúÊ†áÁ≠æÈ°µ‚Äù</strong> ÈÄâÈ°π„ÄÇ",
          step2: "‰ªéÂàóË°®‰∏≠ÈÄâÊã© <strong>Ê≠§È°µÈù¢</strong>„ÄÇ",
          step3: "ÁÇπÂáª <strong>‚ÄúÂàÜ‰∫´‚Äù</strong>„ÄÇ",
          note: "Èº†Ê†áÂ∞ÜËá™Âä®ÈöêËóèÔºåÂç°ÁâáÂ∞ÜË¢´Ë£ÅÂâ™„ÄÇ",
          warning: "‰ΩøÁî®ÊúÄÂ§ßËÆæÁΩÆÔºà60 FPS / 4KÔºâÂèØËÉΩÈúÄË¶ÅÊõ¥ÈïøÊó∂Èó¥Âπ∂Âç†Áî®Â§ßÈáèCPU„ÄÇ",
          fpsLabel: "FPS",
          qualityLabel: "Ë¥®Èáè (È´òÂ∫¶)",
          fpsNormal: "15 FPS (Ê≠£Â∏∏)",
          fpsCinema: "24 FPS (ÁîµÂΩ±)",
          fpsSmooth: "30 FPS (ÊµÅÁïÖ)",
          fpsUltra: "60 FPS (Ë∂ÖÈ´ò)",
          qualitySD: "480p (Ê†áÊ∏Ö)",
          qualityNormal: "720p (È´òÊ∏Ö)",
          qualityHigh: "1080p (ÂÖ®È´òÊ∏Ö)",
          qualityQHD: "1440p (2KË∂ÖÊ∏Ö)",
          qualityUltra: "4K (Ë∂ÖÈ´òÊ∏Ö)",
          cancel: "ÂèñÊ∂à",
          start: "ÂºÄÂßãÊçïËé∑"
        },
        appTitle: 'Card Creator', appSubtitle: 'ÂàõÂª∫ÊÇ®Ëá™Â∑±ÁöÑ‰∏™ÊÄßÂåñÊî∂ËóèÂç°', hoverHint: '‚ú® Â∞ÜÈº†Ê†áÊÇ¨ÂÅúÂú®Âç°Áâá‰∏ä‰ª•Â¢ûÂº∫ÊïàÊûú ‚ú®', elements: { Fire: 'ÁÅ´', Water: 'Ê∞¥', Nature: 'Ëá™ÁÑ∂', Electric: 'Áîµ', Mystic: 'Á•ûÁßò', Fighting: 'Ê†ºÊñó', Shadow: 'Êöó', Metal: 'Èí¢', Light: 'ÂÖâ', Dragon: 'Èæô', Ice: 'ÂÜ∞', Neutral: 'Êó†' }, effects: { none: { name: 'Êó†', description: 'Êó†ÊïàÊûú' }, holographic: { name: 'ÂÖ®ÊÅØ', description: 'ÁªèÂÖ∏ÂΩ©ËôπÊïàÊûú' }, rainbow: { name: 'ÂΩ©Ëôπ', description: 'Âä®ÁîªÂ§öËâ≤Ê∏êÂèò' }, gold: { name: 'ÈáëËâ≤', description: 'Â•¢ÂçéÈáëËâ≤ÂèçÂ∞Ñ' }, silver: { name: 'Èì∂Ëâ≤', description: 'ÈáëÂ±ûÈì∂Ëâ≤ÂèçÂ∞Ñ' }, prismatic: { name: 'Ê£±Èïú', description: 'ÊäòÂ∞ÑÊ∞¥Êô∂ÊïàÊûú' }, neon: { name: 'ÈúìËôπ', description: 'È≤úËâ≥ÈúìËôπÂÖâËäí' }, galaxy: { name: 'ÊòüÁ≥ª', description: 'ÊòüÁ©∫ÂÆáÂÆôÊïàÊûú' }, fire: { name: 'ÁÅ´ÁÑ∞', description: 'Âä®ÁîªÁÅ´ÁÑ∞ÊïàÊûú' }, ice: { name: 'ÂÜ∞Èúú', description: 'Èó™ÁÉÅÂÜ∞Êô∂ÊïàÊûú' } }, stages: ['Âü∫Á°Ä', 'Èò∂ÊÆµ1', 'Èò∂ÊÆµ2', 'ÁâπÊÆä', '‰º†ËØ¥', 'Á•ûËØù', 'Á©∂ÊûÅ'], rarities: { common: 'ÊôÆÈÄö', uncommon: 'Á®ÄÊúâ', rare: 'ÁèçË¥µ', epic: 'Âè≤ËØó', legendary: '‰º†ËØ¥', mythic: 'Á•ûËØù' }, sections: { image: 'ÂõæÁâá', basicInfo: 'Âü∫Êú¨‰ø°ÊÅØ', rarityEffects: 'Á®ÄÊúâÂ∫¶ÂíåÊïàÊûú', abilities: 'ÊäÄËÉΩ', stats: 'Â±ûÊÄß', appearance: 'Â§ñËßÇ' }, labels: { name: 'ÂêçÁß∞', hp: 'ÁîüÂëΩÂÄº', element: 'Â±ûÊÄß', stage: 'Èò∂ÊÆµ', description: 'ÊèèËø∞', author: '‰ΩúËÄÖ', rarity: 'Á®ÄÊúâÂ∫¶', effect: 'ÊïàÊûú', weakness: 'Âº±ÁÇπ', resistance: 'ÊäóÊÄß', retreatCost: 'Êí§ÈÄÄÊ∂àËÄó', abilityName: 'ÊäÄËÉΩÂêçÁß∞', damage: '‰º§ÂÆ≥', energyCost: 'ËÉΩÈáèÊ∂àËÄó', abilityDesc: 'ÊäÄËÉΩÊèèËø∞', borderColor: 'ËæπÊ°ÜÈ¢úËâ≤', backgroundColor: 'ËÉåÊôØÈ¢úËâ≤', textColor: 'ÊñáÂ≠óÈ¢úËâ≤', font: 'Â≠ó‰Ωì', zoom: 'Áº©Êîæ' }, buttons: { addAbility: '+ Ê∑ªÂä†ÊäÄËÉΩ', remove: 'Âà†Èô§', change: 'Êõ¥Êîπ', recenter: 'Â±Ö‰∏≠', download: '‰∏ãËΩΩ', autoRotate: '3DÈ¢ÑËßà' }, checkboxes: { showHP: 'ÊòæÁ§∫ÁîüÂëΩÂÄº', showWeakRes: 'ÊòæÁ§∫Âº±ÁÇπ/ÊäóÊÄß', showRetreat: 'ÊòæÁ§∫Êí§ÈÄÄÊ∂àËÄó', showDescription: 'ÊòæÁ§∫ÊèèËø∞', showTexture: 'ÊòæÁ§∫Á∫πÁêÜ', showParticles: 'ÊòæÁ§∫Á≤íÂ≠ê', showDamage: 'ÊòæÁ§∫‰º§ÂÆ≥' }, imageEditor: { dropHint: 'Â∞ÜÂõæÁâáÊãñÊîæÂà∞ËøôÈáå', orClick: 'ÊàñÁÇπÂáªÈÄâÊã©', formats: 'PNG,JPG,GIF,WEBP (ÊúÄÂ§ß15MB)', loading: 'Âä†ËΩΩ‰∏≠...', unsupportedFormat: '‰∏çÊîØÊåÅÁöÑÊ†ºÂºè„ÄÇËØ∑‰ΩøÁî®PNG„ÄÅJPG„ÄÅGIFÊàñWEBP„ÄÇ', fileTooLarge: 'Êñá‰ª∂Â§™Â§ß„ÄÇÊúÄÂ§ß15MB„ÄÇ' },
        download: { title: 'üì• ‰∏ãËΩΩ', pngTitle: 'ÈÄèÊòéPNGÂõæÁâá', jpgTitle: 'Â∏¶ËÉåÊôØÁöÑJPGÂõæÁâá', gifTitle: 'Âä®ÁîªGIFÔºà3ÁßíÔºâ', htmlTitle: '‰∫§‰∫íÂºèHTMLÊñá‰ª∂', capturing: '‚è≥ ÊçïËé∑‰∏≠...', encoding: '‚öôÔ∏è ÁºñÁ†Å‰∏≠...' },
        card: { hp: 'HP', weakness: 'Âº±ÁÇπ', resistance: 'ÊäóÊÄß', cost: 'Ê∂àËÄó', illus: 'ÁîªÂ∏à' }, defaults: { newAbility: 'Êñ∞ÊäÄËÉΩ' }, display: { title: 'ÊòæÁ§∫ÈÄâÈ°π' }, tabs: { info: '‰ø°ÊÅØ', content: 'ÂÜÖÂÆπ', visual: 'ËßÜËßâ', style: 'Ê†∑Âºè', colors: 'È¢úËâ≤' },
        imageEditor: { dropHint: 'Â∞ÜÂõæÁâáÊãñÊîæÂà∞ËøôÈáå', orClick: 'ÊàñÁÇπÂáªÈÄâÊã©', formats: 'PNG,JPG,GIF,WEBP (ÊúÄÂ§ß15MB)', loading: 'Âä†ËΩΩ‰∏≠...', unsupportedFormat: '‰∏çÊîØÊåÅÁöÑÊ†ºÂºè„ÄÇËØ∑‰ΩøÁî®PNG„ÄÅJPG,GIFÊàñWEBP„ÄÇ', fileTooLarge: 'Êñá‰ª∂Â§™Â§ß„ÄÇÊúÄÂ§ß15MB„ÄÇ', searchPlaceholder: 'ËæìÂÖ•...' },
        download: { title: 'üì• ‰∏ãËΩΩ', pngTitle: 'ÈÄèÊòéPNGÂõæÁâá', jpgTitle: 'Â∏¶ËÉåÊôØÁöÑJPGÂõæÁâá', gifTitle: 'Âä®ÁîªGIFÔºà3ÁßíÔºâ', webpTitle: 'WebPÂõæÁâá', htmlTitle: '‰∫§‰∫íÂºèHTMLÊñá‰ª∂', capturing: '‚è≥ ÊçïËé∑‰∏≠...', encoding: '‚öôÔ∏è ÁºñÁ†Å‰∏≠...' },
        labels: { name: 'ÂêçÁß∞', hp: 'ÁîüÂëΩÂÄº', element: 'Â±ûÊÄß', stage: 'Èò∂ÊÆµ', description: 'ÊèèËø∞', author: '‰ΩúËÄÖ', effect: 'ÊïàÊûú', weakness: 'Âº±ÁÇπ', resistance: 'ÊäóÊÄß', retreatCost: 'Êí§ÈÄÄÊ∂àËÄó', abilityName: 'ÊäÄËÉΩÂêçÁß∞', damage: '‰º§ÂÆ≥', energyCost: 'ËÉΩÈáèÊ∂àËÄó', abilityDesc: 'ÊèèËø∞', borderColor: 'ËæπÊ°ÜÈ¢úËâ≤', backgroundColor: 'Âç°ÁâáËÉåÊôØ', abilityBackground: 'ÊäÄËÉΩËÉåÊôØ', textColor: 'ÊñáÂ≠óÈ¢úËâ≤', font: 'Â≠ó‰Ωì', size: 'Â§ßÂ∞è', weight: 'Á≤óÁªÜ', zoom: 'Áº©Êîæ', backgroundStyle: 'ËÉåÊôØÊ†∑Âºè', solid: 'Á∫ØËâ≤', gradient: 'Ê∏êÂèò', cardInner: 'Âç°ÁâáÂÜÖÈÉ®', primaryColor: '‰∏ªËâ≤', secondaryColor: 'ÂâØËâ≤', presets: 'È¢ÑËÆæ', nameColor: 'ÂêçÁß∞È¢úËâ≤', hpColor: 'ÁîüÂëΩÂÄºÈ¢úËâ≤', typeColor: 'Â±ûÊÄßÈ¢úËâ≤', descColor: 'ÊèèËø∞È¢úËâ≤', statsColor: 'Â±ûÊÄßÈ¢úËâ≤', authorColor: '‰ΩúËÄÖÈ¢úËâ≤' },
        prompts: { resetConfirm: 'ÈáçÁΩÆÊâÄÊúâÂç°ÁâáÊï∞ÊçÆÔºü', autoDeleteInfo: 'Âç°ÁâáÂ∞ÜÂú®30Â§©ÂêéËá™Âä®Âà†Èô§„ÄÇ' },
        buttons: { addAbility: '+ Ê∑ªÂä†', remove: 'Âà†Èô§', change: 'Êõ¥Êîπ', recenter: 'Â±Ö‰∏≠', download: '‰∏ãËΩΩ', autoRotate: '3DËßÜÂõæ', resetCard: 'üîÑ ÈáçÁΩÆ', save: '‰øùÂ≠ò', load: 'Âä†ËΩΩ', deleteAll: 'ÂÖ®ÈÉ®Âà†Èô§' },
        sections: { image: 'ÂõæÁâá', basicInfo: 'Âü∫Êú¨‰ø°ÊÅØ', rarityEffects: 'ÊïàÊûú', abilities: 'ÊäÄËÉΩ', stats: 'Â±ûÊÄß', appearance: 'Â§ñËßÇ', cardStyle: 'Âç°ÁâáÊ†∑Âºè', textStyle: 'ÊñáÊú¨Ê†∑Âºè', particles: 'Á≤íÂ≠êÁ≥ªÁªü', abilityStyle: 'ÊäÄËÉΩÊ†∑Âºè', reset: 'ÈáçÁΩÆ' },
        labels: { name: 'ÂêçÁß∞', hp: 'ÁîüÂëΩÂÄº', element: 'Â±ûÊÄß', stage: 'Èò∂ÊÆµ', description: 'ÊèèËø∞', author: '‰ΩúËÄÖ', effect: 'ÊïàÊûú', weakness: 'Âº±ÁÇπ', resistance: 'ÊäóÊÄß', retreatCost: 'Êí§ÈÄÄÊ∂àËÄó', abilityName: 'ÊäÄËÉΩÂêçÁß∞', damage: '‰º§ÂÆ≥', energyCost: 'ËÉΩÈáèÊ∂àËÄó', abilityDesc: 'ÊèèËø∞', borderColor: 'ËæπÊ°ÜÈ¢úËâ≤', backgroundColor: 'Âç°ÁâáËÉåÊôØ', abilityBackground: 'ÊäÄËÉΩËÉåÊôØ', textColor: 'ÊñáÂ≠óÈ¢úËâ≤', font: 'Â≠ó‰Ωì', size: 'Â§ßÂ∞è', weight: 'Á≤óÁªÜ', zoom: 'Áº©Êîæ', backgroundStyle: 'ËÉåÊôØÊ†∑Âºè', solid: 'Á∫ØËâ≤', gradient: 'Ê∏êÂèò', cardInner: 'Âç°ÁâáÂÜÖÈÉ®', primaryColor: '‰∏ªËâ≤', secondaryColor: 'ÂâØËâ≤', presets: 'È¢ÑËÆæ', nameColor: 'ÂêçÁß∞È¢úËâ≤', hpColor: 'ÁîüÂëΩÂÄºÈ¢úËâ≤', typeColor: 'Â±ûÊÄßÈ¢úËâ≤', descColor: 'ÊèèËø∞È¢úËâ≤', statsColor: 'Â±ûÊÄßÈ¢úËâ≤', authorColor: '‰ΩúËÄÖÈ¢úËâ≤', particleEmoji: 'Á≤íÂ≠êË°®ÊÉÖ', animation: 'Âä®Áîª' },
        textures: { none: 'Êó†', grid: 'ÁΩëÊ†º', scales: 'È≥ûÁâá', cross: 'ÂçÅÂ≠ó', stars: 'ÊòüÊòü', hexagons: 'ÂÖ≠ËæπÂΩ¢', lines: 'Á∫øÊù°', dots: 'ÁÇπÈòµ', waves: 'Ê≥¢Êµ™', circuit: 'ÁîµË∑Ø' },
        animations: { fire: '‰∏äÂçá', water: 'Ê∞îÊ≥°', nature: 'ÊºÇÊµÆ', electric: 'ÁÅ´Ëä±', mystic: 'È≠îÊ≥ï', fighting: 'ÂÜ≤Âáª', shadow: 'Ê∑°ÂÖ•Ê∑°Âá∫', metal: 'ÈΩøËΩÆ', light: 'ËæêÂ∞Ñ', dragon: 'Â®Å‰∏•', ice: 'Èõ™', neutral: 'ÂæÆÂ¶ô' },
        common: { cancel: 'ÂèñÊ∂à', close: 'ÂÖ≥Èó≠' }
      },
    };
    const LanguageContext = createContext();
    const useLanguage = () => {
      const context = useContext(LanguageContext);
      if (!context) {
        throw new Error('useLanguage must be used within a LanguageProvider')
      }
      return context
    };

    // --- Notification System ---
    const NotificationContext = createContext();

    const NotificationToast = ({ notification, onClose }) => {
      useEffect(() => {
        if (notification.duration) {
          const timer = setTimeout(() => {
            onClose(notification.id);
          }, notification.duration);
          return () => clearTimeout(timer);
        }
      }, [notification, onClose]);

      const icons = {
        success: '‚úÖ',
        error: '‚ùå',
        info: '‚ÑπÔ∏è',
        warning: '‚ö†Ô∏è'
      };

      return (
        <div className={`notification-toast ${notification.type}`} onClick={() => onClose(notification.id)}>
          <div className="notification-icon">{icons[notification.type] || '‚ÑπÔ∏è'}</div>
          <div className="notification-content">
            <div className="notification-title">{notification.title}</div>
            <div className="notification-message">{notification.message}</div>
          </div>
          <button className="notification-close" onClick={(e) => { e.stopPropagation(); onClose(notification.id); }}>
            &times;
          </button>
        </div>
      );
    };

    const NotificationProvider = ({ children }) => {
      const [notifications, setNotifications] = useState([]);

      const notify = useCallback((message, type = 'info', title = '', duration = 4000) => {
        const id = Date.now();
        const defaultTitles = {
          success: 'Success',
          error: 'Error',
          info: 'Information',
          warning: 'Warning'
        };
        setNotifications(prev => [...prev, {
          id,
          message,
          type,
          title: title || defaultTitles[type],
          duration
        }]);
      }, []);

      const removeNotification = useCallback((id) => {
        setNotifications(prev => prev.filter(n => n.id !== id));
      }, []);

      const contextValue = useMemo(() => ({ notify }), [notify]);

      return (
        <NotificationContext.Provider value={contextValue}>
          {children}
          <div className="notification-container">
            {notifications.map(n => (
              <NotificationToast key={n.id} notification={n} onClose={removeNotification} />
            ))}
          </div>
        </NotificationContext.Provider>
      );
    };

    const useNotification = () => {
      const context = useContext(NotificationContext);
      if (!context) {
        throw new Error('useNotification must be used within a NotificationProvider');
      }
      return context;
    };
    const CARD_LIMITS = {
      HP_MIN: 0, HP_MAX: 999, DAMAGE_MIN: 0, DAMAGE_MAX: 9999, COST_MIN: 0, COST_MAX: 6, RETREAT_MIN: 0, RETREAT_MAX: 5, NAME_MAX_LENGTH: 25, DESC_MAX_LENGTH: 150, ATTACK_DESC_MAX_LENGTH: 80, AUTHOR_MAX_LENGTH: 30, MAX_FILE_SIZE: 25 * 1024 * 1024, // 25MB
      ZOOM_MIN: 1, ZOOM_MAX: 3,
    };
    const ELEMENT_TYPES = {
      Fire: { icon: 'üî•', primary: '#FF6B35', secondary: '#FFE066', weakness: 'üíß', resistance: 'üåø' },
      Water: { icon: 'üíß', primary: '#4FC3F7', secondary: '#E1F5FE', weakness: '‚ö°', resistance: 'üî•' },
      Nature: { icon: 'üåø', primary: '#66BB6A', secondary: '#C8E6C9', weakness: 'üî•', resistance: 'üíß' },
      Electric: { icon: '‚ö°', primary: '#FFEE58', secondary: '#FFF9C4', weakness: 'üëä', resistance: '‚öôÔ∏è' },
      Mystic: { icon: 'üîÆ', primary: '#BA68C8', secondary: '#F3E5F5', weakness: 'üåë', resistance: 'üëä' },
      Fighting: { icon: 'üëä', primary: '#D84315', secondary: '#FFAB91', weakness: 'üîÆ', resistance: 'üåë' },
      Shadow: { icon: 'üåë', primary: '#5D4037', secondary: '#A1887F', weakness: '‚ú®', resistance: 'üîÆ' },
      Metal: { icon: '‚öôÔ∏è', primary: '#90A4AE', secondary: '#ECEFF1', weakness: 'üî•', resistance: 'üåø' },
      Light: { icon: '‚ú®', primary: '#FFD54F', secondary: '#FFF8E1', weakness: 'üåë', resistance: 'üîÆ' },
      Dragon: { icon: 'üêâ', primary: '#7E57C2', secondary: '#D1C4E9', weakness: '‚ùÑÔ∏è', resistance: 'üî•' },
      Ice: { icon: '‚ùÑÔ∏è', primary: '#4DD0E1', secondary: '#E0F7FA', weakness: 'üî•', resistance: 'üíß' },
      Neutral: { icon: '‚≠ê', primary: '#BDBDBD', secondary: '#F5F5F5', weakness: 'üëä', resistance: 'üëª' },
    };
    const ELEMENT_KEYS = Object.keys(ELEMENT_TYPES);

    const STAGES = ['Base', 'Stage1', 'Stage2', 'Special', 'Legendary', 'Mythic', 'Ultra'];

    const ELEMENT_TEXTURES = {
      Fire: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5c-5 10-15 15-15 25 0 8 7 15 15 15s15-7 15-15c0-10-10-15-15-25z' fill='%23ff6b3520' /%3E%3Cpath d='M30 15c-3 6-9 9-9 15 0 5 4 9 9 9s9-4 9-9c0-6-6-9-9-15z' fill='%23ff450015' /%3E%3C/svg%3E")`, Water: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='15' cy='15' r='8' fill='%2300bcd420' /%3E%3Ccircle cx='45' cy='35' r='6' fill='%232196f315' /%3E%3Ccircle cx='25' cy='45' r='10' fill='%2303a9f418' /%3E%3Cpath d='M5 30 Q15 25 25 30 T45 30 T60 30' stroke='%2300bcd415' fill='none' stroke-width='2'/%3E%3C/svg%3E")`, Nature: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5 Q35 15 30 25 Q25 15 30 5z' fill='%234caf5020' /%3E%3Cpath d='M15 30 Q25 35 20 45 Q15 35 15 30z' fill='%238bc34a18' /%3E%3Cpath d='M45 25 Q50 35 45 45 Q40 35 45 25z' fill='%234caf5015' /%3E%3Ccircle cx='10' cy='50' r='3' fill='%234caf5012' /%3E%3C/svg%3E")`, Electric: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0 L25 25 L35 20 L20 60 L25 30 L15 35 Z' fill='%23ffeb3b15' /%3E%3Cpath d='M50 10 L48 20 L52 18 L45 35' stroke='%23ffc10710' fill='none' stroke-width='2'/%3E%3Ccircle cx='10' cy='45' r='2' fill='%23ffeb3b20' /%3E%3C/svg%3E")`, Mystic: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='30,5 32,15 40,10 35,18 45,20 35,22 40,30 32,25 30,35 28,25 20,30 25,22 15,20 25,18 20,10 28,15' fill='%239c27b015' /%3E%3Ccircle cx='10' cy='50' r='4' fill='%23e91e6310' /%3E%3Ccircle cx='50' cy='45' r='3' fill='%239c27b012' /%3E%3C/svg%3E")`, Fighting: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 10 L50 50' stroke='%23f4433615' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M50 10 L10 50' stroke='%23ff572215' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M30 5 L30 55' stroke='%23f4433610' stroke-width='3'/%3E%3Cpath d='M5 30 L55 30' stroke='%23f4433610' stroke-width='3'/%3E%3C/svg%3E")`, Shadow: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cellipse cx='30' cy='50' rx='20' ry='8' fill='%2300000015' /%3E%3Cellipse cx='15' cy='30' rx='10' ry='5' fill='%2300000010' /%3E%3Cellipse cx='45' cy='20' rx='12' ry='6' fill='%2300000012' /%3E%3Cpath d='M20 10 Q30 20 25 35 Q35 25 40 40' stroke='%2300000008' fill='none' stroke-width='3'/%3E%3C/svg%3E")`, Metal: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='5' y='5' width='20' height='20' rx='2' fill='none' stroke='%2360606015' stroke-width='2'/%3E%3Crect x='35' y='35' width='20' height='20' rx='2' fill='none' stroke='%2360606015' stroke-width='2'/%3E%3Ccircle cx='15' cy='15' r='3' fill='%2390909020' /%3E%3Ccircle cx='45' cy='45' r='3' fill='%2390909020' /%3E%3Ccircle cx='45' cy='15' r='2' fill='%2360606015' /%3E%3Ccircle cx='15' cy='45' r='2' fill='%2360606015' /%3E%3C/svg%3E")`, Light: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='30' cy='30' r='15' fill='%23fff59d10' /%3E%3Cpath d='M30 5 L30 15 M30 45 L30 55 M5 30 L15 30 M45 30 L55 30 M12 12 L19 19 M41 41 L48 48 M12 48 L19 41 M41 19 L48 12' stroke='%23ffeb3b15' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E")`, Dragon: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 20 Q20 15 30 20 Q40 15 50 20 L50 35 Q40 40 30 35 Q20 40 10 35 Z' fill='%23673ab720' /%3E%3Cpath d='M10 35 Q20 30 30 35 Q40 30 50 35 L50 50 Q40 55 30 50 Q20 55 10 50 Z' fill='%23673ab715' /%3E%3Cpath d='M10 5 Q20 0 30 5 Q40 0 50 5 L50 20 Q40 25 30 20 Q20 25 10 20 Z' fill='%23673ab712' /%3E%3C/svg%3E")`, Ice: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5 L30 55 M15 15 L45 45 M45 15 L15 45' stroke='%2381d4fa20' stroke-width='2'/%3E%3Cpath d='M30 20 L25 15 M30 20 L35 15 M30 40 L25 45 M30 40 L35 45' stroke='%2329b6f618' stroke-width='2'/%3E%3Cpolygon points='30,25 33,30 30,35 27,30' fill='%2381d4fa15' /%3E%3C/svg%3E")`, Neutral: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='30' cy='30' r='20' fill='none' stroke='%2390909010' stroke-width='1'/%3E%3Ccircle cx='30' cy='30' r='10' fill='none' stroke='%2390909008' stroke-width='1'/%3E%3C/svg%3E")`,
    };
    /* Textures SVG Patterns */
    const CARD_TEXTURES = {
      none: '',
      grid: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='grid' width='20' height='20' patternUnits='userSpaceOnUse'%3E%3Cpath d='M20 0L0 0 0 20' fill='none' stroke='black' stroke-width='2'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23grid)'/%3E%3C/svg%3E")`,
      scales: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='scales' width='20' height='10' patternUnits='userSpaceOnUse'%3E%3Cpath d='M0 10 Q10 20 20 10 M10 0 Q20 10 30 0 M-10 0 Q0 10 10 0' fill='none' stroke='black' stroke-width='2'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23scales)'/%3E%3C/svg%3E")`,
      cross: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='cross' width='20' height='20' patternUnits='userSpaceOnUse'%3E%3Cpath d='M10 5v10M5 10h10' fill='none' stroke='black' stroke-width='3' stroke-linecap='round'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23cross)'/%3E%3C/svg%3E")`,
      stars: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='stars' width='30' height='30' patternUnits='userSpaceOnUse'%3E%3Cpath d='M15 5l3 7 7 3-7 3-3 7-3-7-7-3 7-3z' fill='black'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23stars)'/%3E%3C/svg%3E")`,
      hexagons: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='hex' width='28' height='49' patternUnits='userSpaceOnUse'%3E%3Cpath d='M14 0l14 8.1v16.2l-14 8.1L0 24.3V8.1z' fill='none' stroke='black' stroke-width='2'/%3E%3Cpath d='M14 49V32.4' stroke='black' stroke-width='2'/%3E%3Cpath d='M0 8.1L-14 0m28 0l14 8.1' stroke='black' stroke-width='2'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23hex)'/%3E%3C/svg%3E")`,
      lines: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='lines' width='20' height='20' patternUnits='userSpaceOnUse' patternTransform='rotate(45)'%3E%3Cline x1='0' y1='0' x2='0' y2='20' stroke='black' stroke-width='3'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23lines)'/%3E%3C/svg%3E")`,
      dots: `url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='10' cy='10' r='2.5' fill='black'/%3E%3C/svg%3E")`,
      waves: `url("data:image/svg+xml,%3Csvg width='100' height='20' viewBox='0 0 100 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M21.184 20c.357-.13.72-.264 1.088-.402l1.768-.661C33.64 15.347 39.647 14 50 14c10.271 0 15.362 1.222 24.629 4.928.955.383 1.869.74 2.75 1.072h6.225c-2.51-.73-5.139-1.691-8.233-2.928C65.888 13.278 60.562 12 50 12c-10.626 0-16.855 1.397-26.66 5.063l-1.767.662c-2.475.923-4.66 1.674-6.724 2.275h6.335zm0-20C13.258 2.892 8.077 4 0 4V2c5.744 0 9.951-.574 14.85-2h6.334zM77.38 0C85.239 2.966 90.502 4 100 4V2c-6.842 0-11.386-.542-16.326-2h-6.292zM0 14c8.44 0 13.718-1.21 22.272-4.402l1.768-.661C33.64 5.347 39.647 4 50 4c10.271 0 15.362 1.222 24.629 4.928C84.112 12.722 89.438 14 100 14v-2c-10.271 0-15.362-1.222-24.629-4.928C65.888 3.278 60.562 2 50 2 39.374 2 33.145 3.397 23.34 7.063l-1.767.662C13.223 10.84 8.163 12 0 12v2z' fill='black' fill-rule='evenodd'/%3E%3C/svg%3E")`,
      circuit: `url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 10 L20 10 L20 30 L50 30 L50 10 M80 10 L80 40 L60 40 M10 80 L30 80 L30 60 L60 60 L60 80 M90 90 L80 90 L80 70 L50 70' fill='none' stroke='black' stroke-width='2'/%3E%3Ccircle cx='20' cy='30' r='3' fill='black'/%3E%3Ccircle cx='60' cy='40' r='3' fill='black'/%3E%3Ccircle cx='30' cy='60' r='3' fill='black'/%3E%3Ccircle cx='80' cy='70' r='3' fill='black'/%3E%3C/svg%3E")`,
    };
    const ELEMENT_PARTICLES = {
      Fire: { emoji: 'üî•', alt: ['üî•', '‚ú®'], count: 12, speed: 'fast', direction: 'up' },
      Water: { emoji: 'üíß', alt: ['ü´ß', 'üí¶'], count: 12, speed: 'slow', direction: 'up' },
      Nature: { emoji: 'üçÉ', alt: ['üåø', 'üå∏'], count: 11, speed: 'medium', direction: 'float' },
      Electric: { emoji: '‚ö°', alt: ['‚ö°', '‚≠ê'], count: 9, speed: 'fast', direction: 'random' },
      Mystic: { emoji: 'üîÆ', alt: ['‚ú®', 'üí´'], count: 10, speed: 'slow', direction: 'float' },
      Fighting: { emoji: 'üí•', alt: ['üí¢', '‚ö°'], count: 8, speed: 'fast', direction: 'random' },
      Shadow: { emoji: 'üåë', alt: ['üíÄ', 'üëª'], count: 7, speed: 'slow', direction: 'down' },
      Metal: { emoji: '‚öôÔ∏è', alt: ['‚õìÔ∏è', 'üî©'], count: 6, speed: 'slow', direction: 'float' },
      Light: { emoji: '‚ú®', alt: ['‚≠ê', 'üåü'], count: 12, speed: 'medium', direction: 'radial' },
      Dragon: { emoji: 'üêâ', alt: ['üíé', 'üî•'], count: 6, speed: 'medium', direction: 'float' },
      Ice: { emoji: '‚ùÑÔ∏è', alt: ['‚ùÖ', 'üíé'], count: 14, speed: 'slow', direction: 'down' },
      Neutral: { emoji: '‚ú¶', alt: ['‚ö™', '‚óÜ'], count: 5, speed: 'slow', direction: 'float' },
    };
    const FONTS = [
      { id: 'nunito', name: 'Nunito', family: "'Nunito', sans-serif" },
      { id: 'poppins', name: 'Poppins', family: "'Poppins', sans-serif" },
      { id: 'roboto', name: 'Roboto', family: "'Roboto', sans-serif" },
      { id: 'oswald', name: 'Oswald', family: "'Oswald', sans-serif" },
      { id: 'playfair', name: 'Playfair Display', family: "'Playfair Display', serif" },
      { id: 'bangers', name: 'Bangers', family: "'Bangers', cursive" },
      { id: 'cinzel', name: 'Cinzel', family: "'Cinzel', serif" },
      { id: 'dancing', name: 'Dancing Script', family: "'Dancing Script', cursive" },
      { id: 'orbitron', name: 'Orbitron', family: "'Orbitron', sans-serif" },
      { id: 'amatic', name: 'Amatic SC', family: "'Amatic SC', cursive" },
    ];
    const PARTICLE_ANIMATIONS = [
      { key: 'fire', label: 'Rising (Fire)' },
      { key: 'water', label: 'Bubbles (Water)' },
      { key: 'nature', label: 'Floating (Nature)' },
      { key: 'electric', label: 'Sparks (Electric)' },
      { key: 'mystic', label: 'Magic (Mystic)' },
      { key: 'fighting', label: 'Impact (Fighting)' },
      { key: 'shadow', label: 'Fade (Shadow)' },
      { key: 'metal', label: 'Gears (Metal)' },
      { key: 'light', label: 'Radiate (Light)' },
      { key: 'dragon', label: 'Majestic (Dragon)' },
      { key: 'ice', label: 'Snow (Ice)' },
      { key: 'neutral', label: 'Subtle (Neutral)' }
    ];
    const INITIAL_CARD_DATA = {
      name: 'My Creature', hp: 120, type: 'Fire', stage: 'Base', weakness: 'üíß', resistance: 'üåø', retreatCost: 2, description: 'A mysterious creature with incredible powers.', author: 'Creator', font: 'nunito', borderColor: '', backgroundColor: '', abilityBackground: 'rgba(255, 255, 255, 0.7)', textColor: '', nameColor: '', hpColor: '', typeColor: '', descColor: '', statsColor: '', authorColor: '', showHP: true, showWeakRes: true, showRetreat: true, showDescription: true, showParticles: true,
      colorMode: 'solid', primaryColor: '#ff6b35', secondaryColor: '#ff9e80', customIcon: 'üî•', particleEmoji: 'üî•', particleAnimation: 'fire',
      cardInnerBackground: 'rgba(255, 255, 255, 0.95)', cardInnerColorMode: 'solid', cardInnerSecondaryBackground: '#f5f5fa',
      texture: 'none',
      /* Typography Defaults */
      nameSize: 16, nameWeight: '700', hpSize: 18, hpWeight: '700', stageSize: 9, stageWeight: '700', descSize: 8, descWeight: '400', statsSize: 8, statsWeight: '400', authorSize: 6, authorWeight: '400', moveNameSize: 12, moveNameWeight: '700', moveDescSize: 8, moveDescWeight: '400',
    };
    const INITIAL_ATTACKS = [
      { id: '1', name: 'Fireball', damage: 60, cost: 2, desc: 'Flip a coin. If heads, the Defending Pok√©mon is now Burned.', showDamage: true, background: 'rgba(255, 255, 255, 0.7)', colorMode: 'solid', secondaryBackground: '#ffffff' },
      { id: '2', name: 'Flamethrower', damage: 90, cost: 3, desc: 'Discard an Energy attached to this Pok√©mon.', showDamage: true, background: 'rgba(255, 255, 255, 0.7)', colorMode: 'solid', secondaryBackground: '#ffffff' },
    ];
    const INITIAL_IMAGE_SETTINGS = {
      zoom: 1, offsetX: 0, offsetY: 0,
    };
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const parseIntSafe = (value, fallback = 0) => {
      const parsed = parseInt(value, 10);
      return isNaN(parsed) ? fallback : parsed
    };
    const parseFloatSafe = (value, fallback = 0) => {
      const parsed = parseFloat(value);
      return isNaN(parsed) ? fallback : parsed
    };
    const generateId = () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const useThrottle = (callback, delay) => {
      const lastCall = useRef(0);
      const callbackRef = useRef(callback);
      callbackRef.current = callback;
      return useCallback((...args) => {
        const now = Date.now();
        if (now - lastCall.current >= delay) {
          lastCall.current = now;
          callbackRef.current(...args)
        }
      }, [delay])
    };

    const downloadAsImage = async (element, filename, format = 'png', targetHeight = 1080) => {
      if (!element) return;
      try {
        if (!window.html2canvas) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        // 1. Create a clean container for the clone
        const container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.top = '-10000px';
        container.style.left = '-10000px';
        container.style.zIndex = '-1';
        container.style.zoom = '1'; // Force no zoom
        container.style.width = 'auto';
        container.style.height = 'auto';
        document.body.appendChild(container);

        // 2. Clone the element
        const clone = element.cloneNode(true);

        // 3. Reset styles on the clone to ensure perfect capture
        clone.style.transform = 'none';
        clone.style.margin = '0';
        clone.style.zoom = '1';
        clone.style.position = 'relative';
        clone.style.boxShadow = 'none'; // Remove shadow to avoid border artifacts if that's the issue
        // If the user wants the shadow, we can comment the line above, but "borders" usually implies unwanted shadow area.
        // Let's assume we want a clean cut of the card content.
        // Re-reading: "le d√©coupage n'est pas bon" -> likely unwanted extra space.

        // For JPG, we keep the rounded corners but fill the background with white
        // This avoids black artifacts while preserving the card shape
        // The user will see white corners, which is the standard behavior for rounded images in JPG


        container.appendChild(clone);

        // 4. Calculate scale based on the CLEAN clone
        // We wait a microtask to let DOM update (though synchronous append usually works)
        const rect = clone.getBoundingClientRect();
        const scale = targetHeight / rect.height;

        const backgroundColor = format === 'jpg' ? '#ffffff' : null;

        const canvas = await html2canvas(clone, {
          backgroundColor: backgroundColor,
          scale: scale,
          useCORS: true,
          allowTaint: true,
          logging: false,
          removeContainer: true
        });

        // 5. Cleanup
        document.body.removeChild(container);

        const link = document.createElement('a');
        link.download = `${filename}.${format}`;
        link.href = canvas.toDataURL(`image/${format === 'jpg' ? 'jpeg' : format}`, 0.9);
        link.click();
        URL.revokeObjectURL(link.href);
      } catch (err) {
        console.error('Download failed:', err);
      }
    };
    const downloadAsPNG = (el, fn) => downloadAsImage(el, fn, 'png', 1080);
    const downloadAsJPG = (el, fn) => downloadAsImage(el, fn, 'jpg', 1080);
    const downloadAsWebP = (el, fn) => downloadAsImage(el, fn, 'webp', 1080);


    const downloadAsGIF = async (cardElement, filename = 'card', duration = 3000, fps = 15, t, onStatusChange) => {
      if (!cardElement) return false;

      try {
        // 1. Show instructions modal and wait for user confirmation
        const { stream, fps: selectedFps, targetHeight: selectedScale } = await new Promise((resolve, reject) => {
          const modal = document.getElementById('gif-instructions-modal');
          const startBtn = document.getElementById('start-gif-btn');
          const cancelBtn = document.getElementById('cancel-gif-btn');

          // Update modal text with translations
          const translations = t || (typeof TRANSLATIONS !== 'undefined' ? TRANSLATIONS['en'] : null);

          if (translations && translations.gifModal) {
            const gm = translations.gifModal;
            const titleEl = modal.querySelector('h3');
            if (titleEl) titleEl.textContent = gm.title;

            const bodyEl = modal.querySelector('p');
            if (bodyEl) bodyEl.textContent = gm.body;

            const step1 = modal.querySelector('#gif-modal-step-1');
            if (step1) step1.innerHTML = gm.step1;
            const step2 = modal.querySelector('#gif-modal-step-2');
            if (step2) step2.innerHTML = gm.step2;
            const step3 = modal.querySelector('#gif-modal-step-3');
            if (step3) step3.innerHTML = gm.step3;

            const noteEl = modal.querySelector('.modal-note span:last-child');
            if (noteEl) noteEl.textContent = gm.note;

            const warningEl = modal.querySelector('.modal-warning span:last-child');
            if (warningEl && gm.warning) warningEl.textContent = gm.warning;

            const fpsLabel = modal.querySelector('#gif-fps-label');
            if (fpsLabel && gm.fpsLabel) fpsLabel.textContent = gm.fpsLabel;

            const qualityLabel = modal.querySelector('#gif-quality-label');
            if (qualityLabel && gm.qualityLabel) qualityLabel.textContent = gm.qualityLabel;

            const fpsNormal = modal.querySelector('#gif-fps-normal');
            if (fpsNormal && gm.fpsNormal) fpsNormal.textContent = gm.fpsNormal;
            const fpsCinema = modal.querySelector('#gif-fps-cinema');
            if (fpsCinema && gm.fpsCinema) fpsCinema.textContent = gm.fpsCinema;
            const fpsSmooth = modal.querySelector('#gif-fps-smooth');
            if (fpsSmooth && gm.fpsSmooth) fpsSmooth.textContent = gm.fpsSmooth;
            const fpsUltra = modal.querySelector('#gif-fps-ultra');
            if (fpsUltra && gm.fpsUltra) fpsUltra.textContent = gm.fpsUltra;

            const qualitySD = modal.querySelector('#gif-quality-sd');
            if (qualitySD && gm.qualitySD) qualitySD.textContent = gm.qualitySD;
            const qualityNormal = modal.querySelector('#gif-quality-normal');
            if (qualityNormal && gm.qualityNormal) qualityNormal.textContent = gm.qualityNormal;
            const qualityHigh = modal.querySelector('#gif-quality-high');
            if (qualityHigh && gm.qualityHigh) qualityHigh.textContent = gm.qualityHigh;
            const qualityQHD = modal.querySelector('#gif-quality-qhd');
            if (qualityQHD && gm.qualityQHD) qualityQHD.textContent = gm.qualityQHD;
            const qualityUltra = modal.querySelector('#gif-quality-ultra');
            if (qualityUltra && gm.qualityUltra) qualityUltra.textContent = gm.qualityUltra;

            if (cancelBtn) cancelBtn.textContent = gm.cancel;
            if (startBtn) startBtn.textContent = gm.start;
          }

          modal.style.display = 'flex';

          const cleanup = () => {
            modal.style.display = 'none';
            startBtn.removeEventListener('click', onStart);
            cancelBtn.removeEventListener('click', onCancel);
          };

          const onStart = async () => {
            const selectedFps = parseInt(document.getElementById('gif-fps-select').value) || 15;
            const selectedHeight = parseInt(document.getElementById('gif-scale-select').value) || 720;

            cleanup();
            try {
              const s = await navigator.mediaDevices.getDisplayMedia({
                video: {
                  displaySurface: 'browser',
                  cursor: 'never',
                  width: { ideal: 3840 }, // Request 4K resolution
                  height: { ideal: 2160 }
                },
                audio: false,
                preferCurrentTab: true
              });
              resolve({ stream: s, fps: selectedFps, targetHeight: selectedHeight });
            } catch (err) {
              reject(err);
            }
          };

          const onCancel = () => {
            cleanup();
            reject(new Error('User cancelled'));
          };

          startBtn.addEventListener('click', onStart);
          cancelBtn.addEventListener('click', onCancel);
        });

        // Add capturing class to freeze layout and hide cursor
        document.body.classList.add('is-capturing');
        document.documentElement.classList.add('is-capturing');

        // Create overlay to block mouse
        const overlay = document.createElement('div');
        overlay.id = 'capture-overlay';

        // Brute-force block all mouse events
        const blockEvent = (e) => {
          e.preventDefault();
          e.stopPropagation();
          return false;
        };
        ['mousemove', 'mousedown', 'mouseup', 'click', 'contextmenu', 'dblclick', 'wheel', 'mouseover', 'mouseout'].forEach(event => {
          overlay.addEventListener(event, blockEvent, { capture: true, passive: false });
        });

        document.body.appendChild(overlay);
        if (document.activeElement) document.activeElement.blur(); // Remove focus

        if (onStatusChange) onStatusChange('‚è≥ Loading libs...');

        // 2. Load dependencies
        if (!window.GIF) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        // 3. Setup Video & Canvas
        const video = document.createElement('video');
        video.srcObject = stream;
        video.play();

        // Wait for video dimensions and layout stabilization
        await new Promise(r => video.onloadedmetadata = r);
        await new Promise(r => setTimeout(r, 1000)); // Longer warmup for layout shift

        if (onStatusChange) onStatusChange('üì∏ Capturing...');

        const workerBlob = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js')
          .then(r => r.blob());
        const workerUrl = URL.createObjectURL(workerBlob);

        // Since we fixed the card to center (50% 50%), we crop the center of the video
        // We target the .game-card specifically to be precise
        const gameCard = document.querySelector('.game-card');
        const rect = gameCard.getBoundingClientRect();

        // Maximum generous padding
        const padding = 0;

        const scaleX = video.videoWidth / window.innerWidth;
        const scaleY = video.videoHeight / window.innerHeight;

        // Calculate crop size based on card size + padding
        const cropW = (rect.width + padding * 2) * scaleX;
        const cropH = (rect.height + padding * 2) * scaleY;

        // Center the crop on the video
        const cropX = (video.videoWidth - cropW) / 2;
        const cropY = (video.videoHeight - cropH) / 2;

        // Apply user selected height standard
        const finalH = selectedScale; // selectedScale is actually targetHeight now
        const aspectRatio = cropW / cropH;
        const finalW = Math.round(finalH * aspectRatio);

        const gif = new GIF({
          workers: 2,
          quality: 1, // Best quality
          workerScript: workerUrl,
          width: finalW,
          height: finalH
        });

        const canvas = document.createElement('canvas');
        canvas.width = finalW;
        canvas.height = finalH;
        const ctx = canvas.getContext('2d');

        // 4. Capture Loop & Promise Wrapper
        return new Promise((resolve, reject) => {
          const frameInterval = 1000 / selectedFps;
          const totalFrames = (duration / 1000) * selectedFps;
          let frameCount = 0;

          const finishCapture = () => {
            // Stop stream
            stream.getTracks().forEach(track => track.stop());
            document.body.classList.remove('is-capturing');
            document.documentElement.classList.remove('is-capturing');
            if (overlay) overlay.remove();

            if (onStatusChange) onStatusChange(t?.download?.encoding || '‚öôÔ∏è Encoding...');

            gif.on('finished', (blob) => {
              const link = document.createElement('a');
              link.download = filename + '.gif';
              link.href = URL.createObjectURL(blob);
              link.click();

              URL.revokeObjectURL(link.href);
              URL.revokeObjectURL(workerUrl);
              resolve(true);
            });

            gif.render();
          };

          const captureInterval = setInterval(() => {
            if (frameCount >= totalFrames) {
              clearInterval(captureInterval);
              finishCapture();
              return;
            }

            // Draw cropped video frame to canvas (Center crop) with scaling
            ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, finalW, finalH);
            gif.addFrame(canvas, { copy: true, delay: frameInterval });

            frameCount++;
            if (onStatusChange) onStatusChange(`üì∏ ${Math.round((frameCount / totalFrames) * 100)}%`);
          }, frameInterval);
        });

      } catch (error) {
        console.error('GIF Error:', error);
        document.body.classList.remove('is-capturing');
        document.documentElement.classList.remove('is-capturing');
        const overlay = document.getElementById('capture-overlay');
        if (overlay) overlay.remove();
        throw error; // Re-throw to be handled by caller
      }
    };
    // --- IndexedDB Helper (FluxDB) ---
    const db = {
      dbName: 'CardCreatorDB',
      version: 1,
      storeName: 'cards',

      open() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.version);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              db.createObjectStore(this.storeName, { keyPath: 'id' });
            }
          };
        });
      },

      async save(card) {
        // Sanitize name before saving
        const sanitizedCard = { ...card, name: sanitize(card.name) };
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.put(sanitizedCard);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
        });
      },

      async getAll() {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result.sort((a, b) => b.timestamp - a.timestamp)); // Newest first
        });
      },

      async delete(id) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.delete(id);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      },

      async cleanupOld(maxAgeDays = 30) {
        const db = await this.open();
        const maxAge = maxAgeDays * 24 * 60 * 60 * 1000; // Convert days to ms
        const now = Date.now();

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            const cards = request.result;
            const oldCards = cards.filter(card => (now - card.timestamp) > maxAge);

            oldCards.forEach(card => {
              store.delete(card.id);
            });

            resolve(oldCards.length);
          };
        });
      },

      async deleteAll() {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.clear();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      }
    };

    const sanitize = (str) => {
      if (!str) return '';
      return String(str).replace(/[<>]/g, ''); // Basic tag stripping
    };

    // --- Save/Load Components ---
    const SaveModal = ({ isOpen, onClose, onSave, defaultName, t }) => {
      const [name, setName] = useState(defaultName);
      useEffect(() => setName(defaultName), [defaultName]);

      if (!isOpen) return null;

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content" onClick={e => e.stopPropagation()}>
            <div className="modal-header">
              <h3>üíæ {t.buttons.save || 'Save Card'}</h3>
            </div>
            <div className="modal-body">
              <div className="modal-note">
                <span className="note-icon">‚ÑπÔ∏è</span>
                <span>{t.prompts.saveHint || 'Your card (text + image) will be saved locally.'}</span>
              </div>
              <div style={{ marginTop: '15px', marginBottom: '20px' }}>
                <InputGroup
                  id="save-name"
                  label={t.labels.name}
                  value={name}
                  onChange={setName}
                  maxLength={50}
                />
              </div>
            </div>
            <div className="modal-footer">
              <button className="secondary-button" onClick={onClose}>{t.common.cancel}</button>
              <button className="primary-button" onClick={() => onSave(name)}>{t.buttons.save}</button>
            </div>
          </div>
        </div>
      );
    };

    const ConfirmModal = ({ isOpen, onClose, onConfirm, title, message, t }) => {
      if (!isOpen) return null;
      return (
        <div className="modal-overlay" onClick={onClose} style={{ zIndex: 11000 }}>
          <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '400px' }}>
            <div className="modal-header">
              <h3 style={{ color: '#f44336' }}>‚ö†Ô∏è {title}</h3>
            </div>
            <div className="modal-body">
              <p>{message}</p>
            </div>
            <div className="modal-footer">
              <button className="secondary-button" onClick={onClose}>{t.common.cancel}</button>
              <button className="primary-button" style={{ background: '#f44336' }} onClick={onConfirm}>{t.buttons.remove || 'Confirm'}</button>
            </div>
          </div>
        </div>
      );
    };

    const LoadModal = ({ isOpen, onClose, onLoad, onDelete, onDeleteAll, cards, t }) => {
      if (!isOpen) return null;

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content load-modal" onClick={e => e.stopPropagation()}>
            <div className="modal-header">
              <h3>üìÇ {t.buttons.load || 'Load Card'}</h3>
            </div>
            <div className="modal-note" style={{ margin: '0 0 15px 0' }}>
              <span className="note-icon">üïê</span>
              <span>{t.prompts.autoDeleteInfo || 'Saved cards are automatically deleted after 30 days.'}</span>
            </div>
            <div className="modal-body" style={{ overflowY: 'auto', paddingRight: '5px' }}>

              {cards.length === 0 ? (
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '40px', gap: '15px', textAlign: 'center' }}>
                  <div style={{ fontSize: '40px', opacity: 0.8 }}>üì≠</div>
                  <div style={{ fontWeight: 600, color: '#888' }}>{t.prompts.noSaves || 'No saved cards found.'}</div>
                </div>
              ) : (
                <div className="saved-cards-grid">
                  {cards.map(card => (
                    <div key={card.id} className="saved-card-item" onClick={() => onLoad(card)} title={t.buttons.load}>
                      <button
                        className="delete-card-btn"
                        onClick={(e) => { e.stopPropagation(); onDelete(card.id); }}
                        title={t.buttons.remove}
                      >
                        &times;
                      </button>
                      <div className="saved-card-preview" style={{ backgroundImage: `url(${card.thumbnail || card.image})`, backgroundSize: 'cover', backgroundPosition: 'top center' }}>
                        {!card.image && !card.thumbnail && <span style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', fontSize: '3em' }}>üÉè</span>}
                      </div>
                      <div className="saved-card-info">
                        <div className="saved-card-name">{card.name}</div>
                        <div className="saved-card-date">{new Date(card.timestamp).toLocaleDateString()} ‚Ä¢ {new Date(card.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
            <div className="modal-footer" style={{ marginTop: '20px', justifyContent: 'flex-end', gap: '12px' }}>
              <button className="secondary-button" onClick={onClose}>{t.common.close || 'Close'}</button>
              {cards.length > 0 && (
                <button className="primary-button" style={{ background: '#f44336' }} onClick={onDeleteAll}>
                  üóëÔ∏è {t.buttons.deleteAll || 'Delete All'}
                </button>
              )}
            </div>
          </div>
        </div>
      );
    };

    const InputGroup = React.memo(({
      id, label, type = 'text', value, onChange, min, max, step, maxLength, rows, options, style, className = '', disabled = false,
    }) => {
      const inputId = `input-${id}`;
      const handleChange = useCallback((e) => {
        onChange(e.target.value)
      }, [onChange]);
      const renderInput = () => {
        const commonProps = { id: inputId, value, onChange: handleChange, disabled };
        if (options) {
          return (<select {...commonProps}>
            {options.map(opt => (<option key={opt.value} value={opt.value}>
              {opt.label}
            </option>))}
          </select>)
        }
        if (rows) {
          return (<textarea
            {...commonProps}
            rows={rows}
            maxLength={maxLength}
            style={{ resize: 'none' }}
          />)
        }
        if (type === 'color') {
          const isHex = /^#[0-9A-Fa-f]{6}$/.test(value);
          const colorInputValue = isHex ? value : '#000000';
          return (<div className="color-input-wrapper"><input
            {...commonProps}
            value={colorInputValue}
            type="color"
            className="color-input"
          /><input
              type="text"
              value={value}
              onChange={handleChange}
              placeholder="#RRGGBB"
              className="color-text-input"
              maxLength={7}
            /></div>)
        }
        return (<input
          {...commonProps}
          type={type}
          min={min}
          max={max}
          step={step}
          maxLength={maxLength}
        />)
      };
      return (<div className={`input-group ${className}`} style={style}><label htmlFor={inputId}>{label}</label>
        {renderInput()}
      </div>)
    });
    InputGroup.displayName = 'InputGroup';
    const Checkbox = React.memo(({ id, label, checked, onChange }) => {
      const inputId = `checkbox-${id}`;
      return (<div className="checkbox-group"><input
        type="checkbox"
        id={inputId}
        checked={checked}
        onChange={(e) => onChange(e.target.checked)}
      /><label htmlFor={inputId}>{label}</label></div>)
    });
    Checkbox.displayName = 'Checkbox';
    const EmojiInput = React.memo(({ label, value, onChange }) => {
      const { t } = useLanguage();
      const [isOpen, setIsOpen] = useState(false);
      const wrapperRef = useRef(null);
      const pickerRef = useRef(null);

      useEffect(() => {
        const handleClickOutside = (event) => {
          if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
            setIsOpen(false);
          }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, []);

      useEffect(() => {
        if (isOpen && pickerRef.current) {
          const picker = pickerRef.current;
          const handleEmojiClick = (event) => {
            onChange(event.detail.unicode);
            setIsOpen(false);
          };
          picker.addEventListener('emoji-click', handleEmojiClick);
          return () => picker.removeEventListener('emoji-click', handleEmojiClick);
        }
      }, [isOpen, onChange]);

      return (
        <div className="input-group" ref={wrapperRef}>
          <label>{label}</label>
          <div className="emoji-input-wrapper" style={{ position: 'relative' }}>
            <button
              type="button"
              className="emoji-btn"
              onClick={() => setIsOpen(!isOpen)}
              style={{
                width: '100%',
                padding: '8px',
                textAlign: 'left',
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '6px',
                color: '#fff',
                cursor: 'pointer',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                height: '42px'
              }}
            >
              <span style={{ fontSize: '1.2em' }}>{value || '‚ùì'}</span>
              <span style={{ fontSize: '0.8em', opacity: 0.7 }}>‚ñº</span>
            </button>
            {isOpen && (
              <div className="emoji-picker-wrapper">
                <emoji-picker ref={pickerRef} class="dark"></emoji-picker>
              </div>
            )}
          </div>
        </div>
      );
    });
    EmojiInput.displayName = 'EmojiInput';
    const AttackInfoEditor = React.memo(({
      index, attack, typeIcon, onUpdate, onRemove, canRemove, t,
    }) => {
      const handleChange = useCallback((field, value) => {
        onUpdate(index, { ...attack, [field]: value })
      }, [index, attack, onUpdate]);
      const handleNumericChange = useCallback((field, value, min, max) => {
        const parsed = parseIntSafe(value, min);
        handleChange(field, clamp(parsed, min, max))
      }, [handleChange]);
      return (<div className="attack-editor"><div className="attack-header-edit"><h3 className="attack-title">
        {typeIcon} {t.sections.abilities} {index + 1}
      </h3>
        {canRemove && (<button
          type="button"
          className="remove-attack-btn"
          onClick={() => onRemove(index)}
          aria-label={t.buttons.remove}
        >
          ‚úï
        </button>)}
      </div><div className="attack-grid"><InputGroup
        id={`attack-${attack.id}-name`}
        label={t.labels.abilityName}
        value={attack.name}
        onChange={(v) => handleChange('name', v)}
        maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
      /><InputGroup
            id={`attack-${attack.id}-damage`}
            label={t.labels.damage}
            type="number"
            value={attack.damage}
            onChange={(v) => handleNumericChange('damage', v, CARD_LIMITS.DAMAGE_MIN, CARD_LIMITS.DAMAGE_MAX)}
          /><InputGroup
            id={`attack-${attack.id}-cost`}
            label={t.labels.energyCost}
            type="number"
            value={attack.cost}
            onChange={(v) => handleNumericChange('cost', v, CARD_LIMITS.COST_MIN, CARD_LIMITS.COST_MAX)}
            min={CARD_LIMITS.COST_MIN}
            max={CARD_LIMITS.COST_MAX}
          /></div><InputGroup
          id={`attack-${attack.id}-desc`}
          label={t.labels.abilityDesc}
          value={attack.desc}
          onChange={(v) => handleChange('desc', v)}
          maxLength={CARD_LIMITS.ATTACK_DESC_MAX_LENGTH}
        /><Checkbox
          id={`attack-${attack.id}-show-damage`}
          label={t.checkboxes.showDamage || 'Afficher les d√©g√¢ts'}
          checked={attack.showDamage !== false}
          onChange={(v) => handleChange('showDamage', v)}
        />
      </div>)
    });
    AttackInfoEditor.displayName = 'AttackInfoEditor';

    const AttackStyleEditor = React.memo(({
      index, attack, typeIcon, onUpdate, t,
    }) => {
      const handleChange = useCallback((field, value) => {
        onUpdate(index, { ...attack, [field]: value })
      }, [index, attack, onUpdate]);
      return (<div className="attack-editor" style={{ marginBottom: '12px', padding: '12px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px' }}>
        <div className="attack-header-edit" style={{ marginBottom: '8px' }}>
          <h3 className="attack-title" style={{ fontSize: '14px', opacity: 0.8 }}>
            {typeIcon} {attack.name || `${t.sections.abilities} ${index + 1}`}
          </h3>
        </div>
        <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.backgroundStyle || "Background Style"}</label>
        <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
          <button
            className={`mode-toggle-btn ${attack.colorMode === 'solid' ? 'active' : ''}`}
            onClick={() => handleChange('colorMode', 'solid')}
          >
            {t.labels.solid || "Solid"}
          </button>
          <button
            className={`mode-toggle-btn ${attack.colorMode !== 'solid' ? 'active' : ''}`}
            onClick={() => handleChange('colorMode', 'gradient')}
          >
            {t.labels.gradient || "Gradient"}
          </button>
        </div>
        <div style={{ display: 'grid', gridTemplateColumns: attack.colorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px', minHeight: '74px' }}>
          <InputGroup
            id={`attack-${attack.id}-bg`}
            label={attack.colorMode === 'solid' ? (t.labels.backgroundColor || "Background") : (t.labels.primaryColor || "Primary")}
            type="color"
            value={attack.background || 'rgba(255, 255, 255, 0.7)'}
            onChange={(v) => handleChange('background', v)}
          />
          {attack.colorMode !== 'solid' && (
            <InputGroup
              id={`attack-${attack.id}-sec-bg`}
              label={t.labels.secondaryColor || "Secondary"}
              type="color"
              value={attack.secondaryBackground || '#ffffff'}
              onChange={(v) => handleChange('secondaryBackground', v)}
            />
          )}
        </div>
      </div>)
    });
    AttackStyleEditor.displayName = 'AttackStyleEditor';


    const ImageEditor = React.memo(({
      image, settings, onSettingsChange, isLoading, error, onUpload, onClear, t,
    }) => {
      const fileInputRef = useRef(null);
      const containerRef = useRef(null);
      const [isDragging, setIsDragging] = useState(false);
      const [isPanning, setIsPanning] = useState(false);
      const panStart = useRef({ x: 0, y: 0 });
      const offsetStart = useRef({ x: 0, y: 0 });
      const handleDragOver = useCallback((e) => {
        e.preventDefault();
        if (!isPanning) setIsDragging(true)
      }, [isPanning]);
      const handleDragLeave = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false)
      }, []);
      const handleDrop = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false);
        const file = e.dataTransfer.files[0];
        if (file) onUpload(file)
      }, [onUpload]);
      const handleClick = useCallback(() => {
        if (!image) fileInputRef.current?.click()
      }, [image]);
      const handleFileChange = useCallback((e) => {
        const file = e.target.files?.[0];
        if (file) onUpload(file);
        e.target.value = ''
      }, [onUpload]);
      const handleZoomChange = useCallback((value) => {
        const zoom = parseFloatSafe(value, 1);
        const clampedZoom = clamp(zoom, CARD_LIMITS.ZOOM_MIN, CARD_LIMITS.ZOOM_MAX);
        onSettingsChange({
          ...settings, zoom: clampedZoom, offsetX: clamp(settings.offsetX, -(clampedZoom - 1) * 50 - 30, (clampedZoom - 1) * 50 + 30), offsetY: clamp(settings.offsetY, -(clampedZoom - 1) * 50 - 30, (clampedZoom - 1) * 50 + 30)
        })
      }, [settings, onSettingsChange]);
      const handlePanStart = useCallback((e) => {
        if (!image) return;
        e.preventDefault();
        setIsPanning(true);
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        panStart.current = { x: clientX, y: clientY };
        offsetStart.current = { x: settings.offsetX, y: settings.offsetY }
      }, [image, settings.offsetX, settings.offsetY]);
      const handlePanMove = useCallback((e) => {
        if (!isPanning) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const deltaX = clientX - panStart.current.x;
        const deltaY = clientY - panStart.current.y;
        const maxOffset = (settings.zoom - 1) * 50 + 30;
        const newOffsetX = clamp(offsetStart.current.x + deltaX, -maxOffset, maxOffset);
        const newOffsetY = clamp(offsetStart.current.y + deltaY, -maxOffset, maxOffset);
        onSettingsChange({
          zoom: settings.zoom, offsetX: newOffsetX, offsetY: newOffsetY
        })
      }, [isPanning, settings.zoom, onSettingsChange]);
      const handlePanEnd = useCallback(() => {
        setIsPanning(false)
      }, []);
      const handleReset = useCallback(() => {
        onSettingsChange(INITIAL_IMAGE_SETTINGS)
      }, [onSettingsChange]);
      return (<div className="image-editor"><div className="image-editor-header">
        {image && (<div className="image-actions"><button type="button" onClick={() => fileInputRef.current?.click()} className="small-btn">
          {t.buttons.change}
        </button><button type="button" onClick={handleReset} className="small-btn">
            {t.buttons.recenter}
          </button><button type="button" onClick={onClear} className="small-btn danger">
            {t.buttons.remove}
          </button></div>)}
      </div><div
        ref={containerRef}
        className={`image-preview-container ${isDragging ? 'dragging' : ''} ${error ? 'error' : ''} ${image ? 'has-image' : ''}`}
        onClick={handleClick}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onMouseDown={image ? handlePanStart : undefined}
        onMouseMove={image ? handlePanMove : undefined}
        onMouseUp={handlePanEnd}
        onMouseLeave={handlePanEnd}
        onTouchStart={image ? handlePanStart : undefined}
        onTouchMove={image ? handlePanMove : undefined}
        onTouchEnd={handlePanEnd}
        role={image ? "application" : "button"}
        tabIndex={0}
        aria-label={t.imageEditor.dropHint}
      ><input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            accept="image/png,image/jpeg,image/gif,image/webp"
            style={{ display: 'none' }}
            aria-hidden="true"
          />
          {image ? (<div
            className="image-preview"
            style={{
              backgroundImage: `url(${image})`, backgroundSize: `${settings.zoom * 100}%`, backgroundPosition: `calc(50% + ${settings.offsetX}px) calc(50% + ${settings.offsetY}px)`, backgroundRepeat: 'no-repeat'
            }}
          >
            {isPanning && <div className="pan-overlay">‚Üî</div>}
          </div>) : (<div className="upload-placeholder"><div className="upload-icon">{isLoading ? '‚è≥' : 'üì∑'}</div><div className="upload-text">
            {isLoading ? t.imageEditor.loading : error ? error : t.imageEditor.dropHint}
          </div><div className="upload-hint">{t.imageEditor.formats}</div></div>)}
        </div>
        {image && (<div className="image-controls"><div className="zoom-control"><label htmlFor="zoom-slider">{t.labels.zoom}:{(settings.zoom * 100).toFixed(0)}%</label><input
          id="zoom-slider"
          type="range"
          min={CARD_LIMITS.ZOOM_MIN}
          max={CARD_LIMITS.ZOOM_MAX}
          step={0.05}
          value={settings.zoom}
          onChange={(e) => handleZoomChange(e.target.value)}
        /></div></div>)}
      </div>)
    });
    ImageEditor.displayName = 'ImageEditor';

    const Card = React.memo(({
      cardData, attacks, image, imageSettings, mousePos, isHovering, cardRef, onMouseMove, onMouseEnter, onMouseLeave, autoRotate, t
    }) => {
      const typeData = ELEMENT_TYPES[cardData.type] || ELEMENT_TYPES.Neutral;
      const weaknessIcon = ELEMENT_TYPES[cardData.weakness]?.icon || cardData.weakness || '‚ùì';
      const resistanceIcon = ELEMENT_TYPES[cardData.resistance]?.icon || cardData.resistance || '‚ùì';
      const fontData = FONTS.find(f => f.id === cardData.font) || FONTS[0];
      const borderColor = cardData.borderColor || '#ffd700';
      const textColor = cardData.textColor || '#1a1a2e';

      // Use custom icon if available, otherwise fallback to type icon
      const displayIcon = cardData.customIcon || typeData.icon;

      const cardStyle = useMemo(() => {
        const capturing = document.body.classList.contains('is-capturing');
        return {
          transform: (isHovering && !capturing) ? `perspective(1000px) rotateY(${(mousePos.x - 0.5) * 15}deg) rotateX(${(0.5 - mousePos.y) * 15}deg) scale(1.02)` : 'perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)',
          transition: autoRotate ? 'none' : 'transform 0.12s ease-out'
        }
      }, [isHovering, mousePos.x, mousePos.y, autoRotate]);



      const imageStyle = useMemo(() => {
        const primary = cardData.primaryColor || typeData.primary;
        const baseStyle = { borderColor: primary };
        if (image) {
          return {
            ...baseStyle, backgroundImage: `url(${image})`, backgroundSize: `${imageSettings.zoom * 100}%`, backgroundPosition: `calc(50% + ${imageSettings.offsetX}px) calc(50% + ${imageSettings.offsetY}px)`, backgroundRepeat: 'no-repeat'
          }
        }
        const secondary = cardData.secondaryColor || typeData.secondary;
        return {
          ...baseStyle, background: `linear-gradient(135deg, ${primary}40, ${secondary}40)`
        }
      }, [image, imageSettings, typeData.primary, typeData.secondary, cardData.primaryColor, cardData.secondaryColor]);

      const cardGradient = useMemo(() => {
        // If manual background color is set (from Appearance tab), use it
        if (cardData.backgroundColor) {
          return cardData.backgroundColor;
        }
        // Otherwise use the Card Style settings
        const primary = cardData.primaryColor || typeData.primary;
        const secondary = cardData.secondaryColor || typeData.secondary;

        if (cardData.colorMode === 'solid') {
          return primary;
        }
        return `linear-gradient(135deg, ${primary} 0%, ${secondary} 50%, ${primary} 100%)`;
      }, [cardData.backgroundColor, cardData.colorMode, cardData.primaryColor, cardData.secondaryColor, typeData.primary, typeData.secondary]);

      // Particle settings
      const particleEmoji = cardData.particleEmoji || ELEMENT_PARTICLES[cardData.type]?.emoji || '‚ú®';
      const particleCount = ELEMENT_PARTICLES[cardData.type]?.count || 6;
      const particleAnim = cardData.particleAnimation || 'float';

      return (<div
        ref={cardRef}
        className="card-container"
        style={cardStyle}
        onMouseMove={onMouseMove}
        onMouseEnter={onMouseEnter}
        onMouseLeave={onMouseLeave}
      ><div
        className="game-card"
        style={{
          background: cardGradient, borderColor: borderColor, fontFamily: fontData.family,
        }}
      >
          {/* Texture Layer */}
          {cardData.texture && cardData.texture !== 'none' && (
            <div className="texture-layer" style={{
              WebkitMaskImage: CARD_TEXTURES[cardData.texture],
              maskImage: CARD_TEXTURES[cardData.texture],
              backgroundColor: cardData.textureColor || '#000000'
            }}></div>
          )}

          {/* Inner card frame */}
          <div className="card-inner" style={{
            color: textColor,
            backgroundImage: cardData.cardInnerColorMode === 'gradient'
              ? `linear-gradient(180deg, ${cardData.cardInnerBackground}, ${cardData.cardInnerSecondaryBackground})`
              : 'none',
            backgroundColor: cardData.cardInnerColorMode === 'gradient' ? 'transparent' : cardData.cardInnerBackground
          }}>
            {/* Header */}
            <div className="card-header"><div className="card-header-left"><span className="stage-badge" style={{ background: cardData.primaryColor || typeData.primary, color: cardData.typeColor || 'inherit', fontSize: `${cardData.stageSize}px`, fontWeight: cardData.stageWeight }}>
              {t.stages[STAGES.indexOf(cardData.stage)] || cardData.stage}
            </span><span className="creature-name" style={{ color: cardData.nameColor || 'inherit', fontSize: `${cardData.nameSize}px`, fontWeight: cardData.nameWeight }}>{cardData.name}</span></div>
              {cardData.showHP && (<div className="card-header-right"><span className="hp-value" style={{ color: cardData.hpColor || 'inherit', fontSize: `${cardData.hpSize}px`, fontWeight: cardData.hpWeight }}>{t.card.hp} {cardData.hp}</span><span className="type-icon">{displayIcon}</span></div>)}
            </div>
            {/* Image */}
            <div className="card-image" style={imageStyle}>
              {!image && (<span className="placeholder-icon">{displayIcon}</span>)}
            </div>
            {/* Description bar */}
            {cardData.showDescription && cardData.description && (<div className="card-description" style={{ color: cardData.descColor || 'inherit', fontSize: `${cardData.descSize}px`, fontWeight: cardData.descWeight, lineHeight: cardData.descHeight || 1.3 }}>{cardData.description}</div>)}
            {/* Attacks */}
            <div className="attacks-container">
              {attacks.map((attack) => (
                <div key={attack.id} className="attack-card" style={{
                  backgroundImage: attack.colorMode === 'gradient'
                    ? `linear-gradient(180deg, ${attack.background}, ${attack.secondaryBackground})`
                    : 'none',
                  backgroundColor: attack.colorMode === 'gradient' ? 'transparent' : (attack.background || cardData.abilityBackground),
                  backgroundRepeat: 'no-repeat',
                  backgroundPosition: 'top center',
                  backgroundSize: '100% 102%'
                }}><div className="attack-header"><div className="attack-cost">
                  {[...Array(Math.max(0, Math.min(10, attack.cost)))].map((_, i) => (<span key={i} className="energy-icon">{displayIcon}</span>))}
                </div><span className="attack-name" style={{ color: cardData.moveNameColor || cardData.descColor || 'inherit', fontSize: `${cardData.moveNameSize}px`, fontWeight: cardData.moveNameWeight }}>{attack.name}</span>{attack.showDamage !== false && <span className="attack-damage" style={{ color: cardData.moveNameColor || cardData.descColor || 'inherit', fontSize: `${Number(cardData.moveNameSize) + 2}px`, fontWeight: cardData.moveNameWeight }}>{attack.damage}</span>}</div>
                  {attack.desc && <div className="attack-desc" style={{ color: cardData.moveDescColor || cardData.descColor || 'inherit', fontSize: `${cardData.moveDescSize}px`, fontWeight: cardData.moveDescWeight }}>{attack.desc}</div>}
                </div>))}
            </div>
            {/* Footer */}
            <div className="card-footer" style={{ color: cardData.statsColor || 'inherit', fontSize: `${cardData.statsSize}px`, fontWeight: cardData.statsWeight }}>
              {cardData.showWeakRes && (<div className="footer-stats"><div className="stat"><span className="stat-label">{t.card.weakness} </span><span className="stat-icon">{weaknessIcon}</span><span className="stat-value weakness"> √ó2</span></div><div className="stat"><span className="stat-label">{t.card.resistance} </span><span className="stat-icon">{resistanceIcon}</span><span className="stat-value resistance"> -30</span></div></div>)}
              {cardData.showRetreat && (<div className="retreat-cost"><span className="stat-label">{t.card.cost} </span>
                {[...Array(Math.max(0, cardData.retreatCost))].map((_, i) => (<span key={i} className="retreat-icon">‚ö™</span>))}
              </div>)}
            </div>
            {/* Author */}
            <div className="card-author" style={{ color: cardData.authorColor || 'inherit', fontSize: `${cardData.authorSize}px`, fontWeight: cardData.authorWeight }}>
              {t.card.illus} {cardData.author} ‚Ä¢ Card Creator
            </div></div>

          {/* Particles layer */}
          {cardData.showParticles && (<div className={`particles-layer particles-${particleAnim}`}>
            {[...Array(particleCount)].map((_, i) => (<span
              key={i}
              className={`particle particle-${i % 3}`}
              style={{
                left: `${3 + (i * 31) % 94}%`,
                top: `${2 + (i * 37) % 96}%`,
                animationDelay: `${i * 0.5}s`,
                fontSize: `${10 + (i * 5) % 15}px`,
                position: 'absolute'
              }}
            >
              {particleEmoji}
            </span>))}
          </div>)}
        </div></div>)
    });

    Card.displayName = 'Card';
    const CollapsibleSection = React.memo(({ title, icon, children, defaultOpen = true, isOpen: controlledIsOpen, onToggle }) => {
      const [internalIsOpen, setInternalIsOpen] = useState(defaultOpen);
      const isControlled = controlledIsOpen !== undefined;
      const isOpen = isControlled ? controlledIsOpen : internalIsOpen;

      const handleToggle = () => {
        if (isControlled) {
          onToggle && onToggle();
        } else {
          setInternalIsOpen(!internalIsOpen);
        }
      };

      return (<div className={`collapsible-section ${isOpen ? 'open' : ''}`}><button
        type="button"
        className="collapsible-header"
        onClick={handleToggle}
        aria-expanded={isOpen}
      ><span>{icon} {title}</span><span className="collapse-icon">{isOpen ? '‚ñº' : '‚ñ∂'}</span></button>
        {isOpen && <div className="collapsible-content">{children}</div>}
      </div>)
    });
    CollapsibleSection.displayName = 'CollapsibleSection';

    const TextSettingsGroup = React.memo(({ label, colorKey, sizeKey, weightKey, cardData, updateCardData, t, showColor = true }) => {
      const [isOpen, setIsOpen] = useState(false);
      const currentColor = cardData[colorKey] || cardData.textColor || '#1a1a2e';

      return (
        <div className="text-settings-group" style={{ marginBottom: '8px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px', overflow: 'hidden' }}>
          <button
            type="button"
            onClick={() => setIsOpen(!isOpen)}
            style={{
              width: '100%',
              padding: '10px 12px',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              background: 'none',
              border: 'none',
              color: 'white',
              cursor: 'pointer',
              textAlign: 'left'
            }}
          >
            <span style={{ fontSize: '13px', fontWeight: 600, opacity: 0.9 }}>{label}</span>
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>

              <span style={{ fontSize: '10px', opacity: 0.5, transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>‚ñº</span>
            </div>
          </button>

          {isOpen && (
            <div style={{ padding: '12px', paddingTop: '0' }}>
              <div style={{ display: 'grid', gap: '12px' }}>
                {showColor && (
                  <InputGroup
                    id={`${colorKey}-input`}
                    label={t.labels.textColor}
                    type="color"
                    value={currentColor}
                    onChange={(v) => updateCardData(colorKey, v)}
                  />
                )}
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                  {sizeKey && (
                    <InputGroup
                      id={`${sizeKey}-input`}
                      label={t.labels.size}
                      type="number"
                      value={cardData[sizeKey]}
                      onChange={(v) => updateCardData(sizeKey, Number(v))}
                    />
                  )}
                  {weightKey && (
                    <div className="input-group">
                      <label htmlFor={`${weightKey}-input`}>{t.labels.weight}</label>
                      <select
                        id={`${weightKey}-input`}
                        value={cardData[weightKey]}
                        onChange={(e) => updateCardData(weightKey, e.target.value)}
                        style={{ width: '100%' }}
                      >
                        <option value="400">Normal</option>
                        <option value="700">Bold</option>
                        <option value="900">Black</option>
                      </select>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      );
    });

    function CardCreatorContent() {
      const { t, lang, setLang } = useLanguage();
      const { notify } = useNotification();
      const [cardData, setCardData] = useState(INITIAL_CARD_DATA);
      const [attacks, setAttacks] = useState(INITIAL_ATTACKS);
      const [image, setImage] = useState(null);
      const [imageSettings, setImageSettings] = useState(INITIAL_IMAGE_SETTINGS);
      const [imageLoading, setImageLoading] = useState(false);
      const [imageError, setImageError] = useState(null);
      const [mousePos, setMousePos] = useState({ x: 0.5, y: 0.5 });
      const [isHovering, setIsHovering] = useState(false);
      const [autoRotate, setAutoRotate] = useState(true);
      const [activeTab, setActiveTab] = useState('visual');
      const [openSection, setOpenSection] = useState('image'); // Default open section for visual tab
      const [showResetConfirm, setShowResetConfirm] = useState(false);

      // Save/Load State
      const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
      const [isLoadModalOpen, setIsLoadModalOpen] = useState(false);
      const [savedCards, setSavedCards] = useState([]);
      const [isLoading, setIsLoading] = useState(false); // Local loading state for save/load operations

      // Confirm Modal State
      const [confirmState, setConfirmState] = useState({ isOpen: false, title: '', message: '', onConfirm: null });
      const openConfirm = (title, message, onConfirm) => {
        setConfirmState({ isOpen: true, title, message, onConfirm });
      };

      const openLoadModal = async () => {
        try {
          // Auto-delete cards older than 30 days
          await db.cleanupOld(30);
          const cards = await db.getAll();
          setSavedCards(cards);
          setIsLoadModalOpen(true);
        } catch (err) {
          console.error('Error loading cards:', err);
          notify(t.prompts.saveError || 'Could not load cards', 'error');
        }
      };

      const handleSaveCard = async (saveName) => {
        setIsLoading(true);
        try {
          const cardElement = document.querySelector('.game-card');
          const canvas = await html2canvas(cardElement, {
            scale: 0.5,
            backgroundColor: null,
            logging: false,
            useCORS: true
          });
          const thumbnail = canvas.toDataURL('image/jpeg', 0.7);

          const newCard = {
            id: crypto.randomUUID(),
            timestamp: Date.now(),
            name: saveName || cardData.name || 'Untitled',
            cardData,
            attacks,
            image: image,
            thumbnail: thumbnail
          };

          await db.save(newCard);
          setIsSaveModalOpen(false);
          notify(t.prompts.saveSuccess || 'Card saved successfully!', 'success');
        } catch (err) {
          console.error('Save failed:', err);
          if (err.name === 'QuotaExceededError') {
            notify(t.prompts.quotaError || 'Storage full!', 'error');
          } else {
            notify('Failed to save card', 'error');
          }
        } finally {
          setIsLoading(false);
        }
      };

      const handleLoadCard = (savedCard) => {
        setCardData({ ...INITIAL_CARD_DATA, ...savedCard.cardData });
        setAttacks(savedCard.attacks);
        setImage(savedCard.image || null);
        setIsLoadModalOpen(false);
        notify('Card loaded!', 'success');
      };

      const handleDeleteCard = async (id) => {
        openConfirm(
          t.buttons.remove,
          t.prompts.deleteConfirm || "Delete this saved card?",
          async () => {
            try {
              await db.delete(id);
              const cards = await db.getAll();
              setSavedCards(cards);
              setConfirmState(prev => ({ ...prev, isOpen: false }));
              notify('Card deleted', 'info');
            } catch (err) {
              console.error(err);
              notify('Failed to delete card', 'error');
            }
          }
        );
      };

      const handleDeleteAllCards = () => {
        openConfirm(
          t.buttons.deleteAll || 'Delete All',
          t.prompts.deleteAllConfirm || 'Delete all saved cards? This cannot be undone.',
          async () => {
            try {
              await db.deleteAll();
              setSavedCards([]);
              setConfirmState(prev => ({ ...prev, isOpen: false }));
              notify(t.prompts.allDeleted || 'All cards deleted', 'info');
            } catch (err) {
              console.error(err);
              notify('Failed to delete cards', 'error');
            }
          }
        );
      };
      const cardRef = useRef(null);
      const autoRotateRef = useRef(null);
      useEffect(() => {
        const modal = document.getElementById('gif-instructions-modal');
        if (modal && t && t.gifModal) {
          const gm = t.gifModal;
          const titleEl = modal.querySelector('h3');
          if (titleEl) titleEl.textContent = gm.title;

          const bodyEl = modal.querySelector('p');
          if (bodyEl) bodyEl.textContent = gm.body;

          const step1 = modal.querySelector('#gif-modal-step-1');
          if (step1) step1.innerHTML = gm.step1;
          const step2 = modal.querySelector('#gif-modal-step-2');
          if (step2) step2.innerHTML = gm.step2;
          const step3 = modal.querySelector('#gif-modal-step-3');
          if (step3) step3.innerHTML = gm.step3;

          const noteEl = modal.querySelector('.modal-note span:last-child');
          if (noteEl) noteEl.textContent = gm.note;

          const warningEl = modal.querySelector('.modal-warning span:last-child');
          if (warningEl && gm.warning) warningEl.textContent = gm.warning;

          const fpsLabel = modal.querySelector('#gif-fps-label');
          if (fpsLabel && gm.fpsLabel) fpsLabel.textContent = gm.fpsLabel;

          const qualityLabel = modal.querySelector('#gif-quality-label');
          if (qualityLabel && gm.qualityLabel) qualityLabel.textContent = gm.qualityLabel;

          const fpsNormal = modal.querySelector('#gif-fps-normal');
          if (fpsNormal && gm.fpsNormal) fpsNormal.textContent = gm.fpsNormal;
          const fpsCinema = modal.querySelector('#gif-fps-cinema');
          if (fpsCinema && gm.fpsCinema) fpsCinema.textContent = gm.fpsCinema;
          const fpsSmooth = modal.querySelector('#gif-fps-smooth');
          if (fpsSmooth && gm.fpsSmooth) fpsSmooth.textContent = gm.fpsSmooth;
          const fpsUltra = modal.querySelector('#gif-fps-ultra');
          if (fpsUltra && gm.fpsUltra) fpsUltra.textContent = gm.fpsUltra;

          const qualitySD = modal.querySelector('#gif-quality-sd');
          if (qualitySD && gm.qualitySD) qualitySD.textContent = gm.qualitySD;
          const qualityNormal = modal.querySelector('#gif-quality-normal');
          if (qualityNormal && gm.qualityNormal) qualityNormal.textContent = gm.qualityNormal;
          const qualityHigh = modal.querySelector('#gif-quality-high');
          if (qualityHigh && gm.qualityHigh) qualityHigh.textContent = gm.qualityHigh;
          const qualityQHD = modal.querySelector('#gif-quality-qhd');
          if (qualityQHD && gm.qualityQHD) qualityQHD.textContent = gm.qualityQHD;
          const qualityUltra = modal.querySelector('#gif-quality-ultra');
          if (qualityUltra && gm.qualityUltra) qualityUltra.textContent = gm.qualityUltra;

          const cancelBtn = document.getElementById('cancel-gif-btn');
          if (cancelBtn) cancelBtn.textContent = gm.cancel;
          const startBtn = document.getElementById('start-gif-btn');
          if (startBtn) startBtn.textContent = gm.start;
        }
      }, [t]);

      useEffect(() => {
        const capturing = document.body.classList.contains('is-capturing');
        if (autoRotate && !capturing) {
          let angle = 0;
          setIsHovering(true); // Active l'effet 3D
          autoRotateRef.current = setInterval(() => {
            angle += 0.025; // Mouvement plus lent et fluide
            const x = 0.5 + Math.sin(angle) * 0.35;
            const y = 0.5 + Math.sin(angle * 2) * 0.25;
            setMousePos({ x, y })
          }, 40)
        } else {
          if (autoRotateRef.current) {
            clearInterval(autoRotateRef.current);
            autoRotateRef.current = null
          }
          setIsHovering(false);
          setMousePos({ x: 0.5, y: 0.5 })
        }
        return () => {
          if (autoRotateRef.current) {
            clearInterval(autoRotateRef.current)
          }
        }
      }, [autoRotate]);
      const handleMouseEnterManual = useCallback(() => {
        if (document.body.classList.contains('is-capturing')) return;
        if (autoRotate && autoRotateRef.current) {
          clearInterval(autoRotateRef.current);
          autoRotateRef.current = null
        }
        setIsHovering(true)
      }, [autoRotate]);
      const handleMouseLeaveManual = useCallback(() => {
        if (document.body.classList.contains('is-capturing')) return;
        if (autoRotate) {
          let angle = 0;
          autoRotateRef.current = setInterval(() => {
            angle += 0.025;
            const x = 0.5 + Math.sin(angle) * 0.35;
            const y = 0.5 + Math.sin(angle * 2) * 0.25;
            setMousePos({ x, y })
          }, 40);
          setIsHovering(true); // Garder l'effet 3D actif
        } else {
          setIsHovering(false);
          setMousePos({ x: 0.5, y: 0.5 })
        }
      }, [autoRotate]);
      const updateCardData = useCallback((field, value) => {
        setCardData(prev => ({ ...prev, [field]: value }))
      }, []);
      const updateCardDataNumeric = useCallback((field, value, min, max) => {
        const parsed = parseIntSafe(value, min);
        setCardData(prev => ({ ...prev, [field]: clamp(parsed, min, max) }))
      }, []);
      const updateAttack = useCallback((index, newAttack) => {
        setAttacks(prev => prev.map((a, i) => i === index ? newAttack : a))
      }, []);
      const addAttack = useCallback(() => {
        if (attacks.length >= 3) return;
        setAttacks(prev => [...prev, { id: generateId(), name: t.defaults.newAbility, damage: 50, cost: 2, desc: '', showDamage: true, background: 'rgba(255, 255, 255, 0.7)', colorMode: 'solid', secondaryBackground: '#ffffff' }])
      }, [attacks.length, t]);
      const removeAttack = useCallback((index) => {
        if (attacks.length <= 1) return;
        setAttacks(prev => prev.filter((_, i) => i !== index))
      }, [attacks.length]);
      const processImageFile = useCallback((file) => {
        if (!file) return;
        const validTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
        if (!validTypes.includes(file.type)) {
          setImageError(t.imageEditor.unsupportedFormat);
          return
        }
        if (file.size > CARD_LIMITS.MAX_FILE_SIZE) {
          setImageError(t.imageEditor.fileTooLarge);
          return
        }
        setImageLoading(true);
        setImageError(null);
        const reader = new FileReader();
        reader.onload = (e) => {
          setImage(e.target.result);
          setImageSettings(INITIAL_IMAGE_SETTINGS);
          setImageLoading(false)
        };
        reader.onerror = () => {
          setImageError('Error');
          setImageLoading(false)
        };
        reader.readAsDataURL(file)
      }, [t]);
      const clearImage = useCallback(() => {
        setImage(null);
        setImageSettings(INITIAL_IMAGE_SETTINGS);
        setImageError(null)
      }, []);
      const handleMouseMoveThrottled = useCallback((e) => {
        if (document.body.classList.contains('is-capturing')) return;
        if (!cardRef.current) return;
        const rect = cardRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        setMousePos({ x: clamp(x, 0, 1), y: clamp(y, 0, 1) })
      }, []);
      const handleMouseMove = useThrottle(handleMouseMoveThrottled, 16);
      const typeOptions = useMemo(() => ELEMENT_KEYS.map(type => ({
        value: type, label: `${ELEMENT_TYPES[type].icon} ${t.elements[type] || type}`
      })),
        [t]);
      const stageOptions = useMemo(() => STAGES.map((stage, index) => ({
        value: stage, label: t.stages[index] || stage
      })),
        [t]);
      const fontOptions = useMemo(() => FONTS.map(font => ({ value: font.id, label: font.name })),
        []);
      const textureOptions = useMemo(() => Object.keys(CARD_TEXTURES).map(key => ({
        value: key, label: t.textures?.[key] || key
      })), [t]);
      const typeIcon = ELEMENT_TYPES[cardData.type]?.icon || '‚≠ê';
      return (<div className="app-container">
        <div className="header-controls">
          <div className="header-btn-group">
            <button className="header-btn save" onClick={() => setIsSaveModalOpen(true)} title={t.buttons.save || 'Save'}>
              üíæ <span className="btn-text">{t.buttons.save || 'Save'}</span>
            </button>
            <button className="header-btn load" onClick={openLoadModal} title={t.buttons.load || 'Load'}>
              üìÇ <span className="btn-text">{t.buttons.load || 'Load'}</span>
            </button>
          </div>
          <select
            value={lang}
            onChange={(e) => setLang(e.target.value)}
            className="lang-select"
          >
            {Object.entries(LANGUAGES).map(([code, { name, flag }]) => (
              <option key={code} value={code}>
                {name}
              </option>
            ))}
          </select>
        </div>
        <h1 className="title">‚ú® {t.appTitle} ‚ú®</h1><p className="subtitle">{t.appSubtitle}</p>
        <div className="main-layout">
          {/* Card Preview */}
          <div className="card-preview"><Card
            cardData={cardData}
            attacks={attacks}
            image={image}
            imageSettings={imageSettings}
            mousePos={mousePos}
            isHovering={isHovering}
            cardRef={cardRef}
            onMouseMove={handleMouseMove}
            onMouseEnter={handleMouseEnterManual}
            onMouseLeave={handleMouseLeaveManual}
            autoRotate={autoRotate}
            t={t}
          /><p className="hover-hint">{t.hoverHint}</p>
            {/* Auto Rotate Button */}
            <button
              className={`auto-rotate-btn ${autoRotate ? 'active' : ''}`}
              onClick={() => setAutoRotate(!autoRotate)}
            >
              {autoRotate ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'} {t.buttons.autoRotate || "Vue 3D"}
            </button>
            {/* Download & Reset Group - Matches width */}
            <div style={{ display: 'flex', flexDirection: 'column', width: 'fit-content', alignItems: 'stretch', marginTop: '24px' }}>
              <div className="download-section" style={{ width: '100%', boxSizing: 'border-box', marginTop: 0 }}>
                <p className="download-title" style={{ marginTop: 0 }}>{t.download.title}</p>
                <div className="download-buttons">
                  <button
                    className="download-btn download-png"
                    onClick={() => downloadAsPNG(cardRef.current, cardData.name || 'card')}
                    title={t.download.pngTitle}
                  >
                    üñºÔ∏è PNG
                  </button>
                  <button
                    className="download-btn download-jpg"
                    onClick={() => downloadAsJPG(cardRef.current, cardData.name || 'card')}
                    title={t.download.jpgTitle}
                  >
                    üì∑ JPG
                  </button>
                  <button
                    className="download-btn download-webp"
                    onClick={() => downloadAsWebP(cardRef.current, cardData.name || 'card')}
                    title={t.download.webpTitle}
                  >
                    üåê WebP
                  </button>
                  <button
                    className="download-btn download-gif"
                    onClick={async (e) => {
                      const btn = e.currentTarget;
                      const originalText = btn.textContent;

                      // Debug translation removed
                      try {
                        btn.textContent = t.download.capturing;
                        btn.disabled = true;
                        await downloadAsGIF(
                          cardRef.current,
                          cardData.name || 'card',
                          3000,
                          10,
                          t,
                          (text) => { btn.textContent = text; }
                        );
                      } catch (err) {
                        // Silent catch
                      } finally {
                        btn.textContent = originalText;
                        btn.disabled = false;
                      }
                    }}
                    title={t.download.gifTitle}
                  >
                    üé¨ GIF
                  </button>

                </div>
              </div>

              {/* Reset Button */}
              <div style={{ marginTop: '10px' }}>
                <button
                  className="no-capture"
                  onClick={() => {
                    setShowResetConfirm(true);
                  }}
                  style={{ width: '100%', padding: '12px', background: 'rgba(244, 67, 54, 0.1)', color: '#f44336', border: '1px solid rgba(244, 67, 54, 0.2)', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', transition: 'all 0.2s' }}
                  onMouseOver={(e) => { e.currentTarget.style.background = 'rgba(244, 67, 54, 0.2)'; }}
                  onMouseOut={(e) => { e.currentTarget.style.background = 'rgba(244, 67, 54, 0.1)'; }}
                >
                  {t.buttons.resetCard}
                </button>
              </div>
            </div>
          </div>
          {/* Editor Panel */}
          <div className="editor-panel">
            <div className="editor-tabs">
              <button
                className={`tab-btn ${activeTab === 'visual' ? 'active' : ''}`}
                onClick={() => { setActiveTab('visual'); setOpenSection('image'); }}
              >
                üì∑ {t.tabs.visual}
              </button>
              <button
                className={`tab-btn ${activeTab === 'content' ? 'active' : ''}`}
                onClick={() => { setActiveTab('content'); setOpenSection('basicInfo'); }}
              >
                üìù {t.tabs.content || t.tabs.info}
              </button>
              <button
                className={`tab-btn ${activeTab === 'colors' ? 'active' : ''}`}
                onClick={() => { setActiveTab('colors'); setOpenSection('cardStyle'); }}
              >
                üé® {t.tabs.colors || t.tabs.style}
              </button>

            </div>

            <div className="tab-content">
              {activeTab === 'content' && (
                <>
                  <CollapsibleSection
                    title={t.sections.basicInfo}
                    icon="üìù"
                    isOpen={openSection === 'basicInfo'}
                    onToggle={() => setOpenSection(openSection === 'basicInfo' ? null : 'basicInfo')}
                  >
                    <div className="grid-2">
                      <InputGroup
                        id="creature-name"
                        label={t.labels.name}
                        value={cardData.name}
                        onChange={(v) => updateCardData('name', v)}
                        maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
                      />
                      <InputGroup
                        id="creature-hp"
                        label={t.labels.hp}
                        type="number"
                        value={cardData.hp}
                        onChange={(v) => updateCardDataNumeric('hp', v, CARD_LIMITS.HP_MIN, CARD_LIMITS.HP_MAX)}
                        min={CARD_LIMITS.HP_MIN}
                        max={CARD_LIMITS.HP_MAX}
                      />
                    </div>
                    <InputGroup
                      id="creature-stage"
                      label={t.labels.stage}
                      value={cardData.stage}
                      onChange={(v) => updateCardData('stage', v)}
                      options={stageOptions}
                    />
                    <InputGroup
                      id="creature-description"
                      label={t.labels.description}
                      value={cardData.description}
                      onChange={(v) => updateCardData('description', v)}
                      rows={2}
                      maxLength={CARD_LIMITS.DESC_MAX_LENGTH}
                    />
                    <InputGroup
                      id="creature-author"
                      label={t.labels.author}
                      value={cardData.author}
                      onChange={(v) => updateCardData('author', v)}
                      maxLength={CARD_LIMITS.AUTHOR_MAX_LENGTH}
                    />
                  </CollapsibleSection>


                  <CollapsibleSection
                    title={t.sections.abilities || "Abilities Info"}
                    icon="‚öîÔ∏è"
                    isOpen={openSection === 'abilitiesInfo'}
                    onToggle={() => setOpenSection(openSection === 'abilitiesInfo' ? null : 'abilitiesInfo')}
                  >
                    {attacks.map((attack, idx) => (
                      <AttackInfoEditor
                        key={attack.id}
                        index={idx}
                        attack={attack}
                        typeIcon={typeIcon}
                        onUpdate={updateAttack}
                        onRemove={removeAttack}
                        canRemove={attacks.length > 1}
                        t={t}
                      />
                    ))}
                    <button
                      type="button"
                      className="add-attack-btn"
                      onClick={addAttack}
                      disabled={attacks.length >= 3}
                    >
                      {t.buttons.addAbility} {attacks.length >= 3 && '(max 3)'}
                    </button>
                  </CollapsibleSection>

                  <CollapsibleSection
                    title={t.sections.stats}
                    icon="üìä"
                    isOpen={openSection === 'stats'}
                    onToggle={() => setOpenSection(openSection === 'stats' ? null : 'stats')}
                  >
                    <div className="grid-3">
                      <EmojiInput
                        label={t.labels.weakness}
                        value={cardData.weakness}
                        onChange={(v) => updateCardData('weakness', v)}
                      />
                      <EmojiInput
                        label={t.labels.resistance}
                        value={cardData.resistance}
                        onChange={(v) => updateCardData('resistance', v)}
                      />
                      <InputGroup
                        id="creature-retreat"
                        label={t.labels.retreatCost}
                        type="number"
                        value={cardData.retreatCost}
                        onChange={(v) => updateCardDataNumeric('retreatCost', v, CARD_LIMITS.RETREAT_MIN, CARD_LIMITS.RETREAT_MAX)}
                        min={CARD_LIMITS.RETREAT_MIN}
                        max={CARD_LIMITS.RETREAT_MAX}
                      />
                    </div>
                  </CollapsibleSection>

                </>
              )}


              {activeTab === 'visual' && (
                <>
                  <CollapsibleSection
                    title={t.sections.image}
                    icon="üì∑"
                    isOpen={openSection === 'image'}
                    onToggle={() => setOpenSection(openSection === 'image' ? null : 'image')}
                  >
                    <ImageEditor
                      image={image}
                      settings={imageSettings}
                      onSettingsChange={setImageSettings}
                      isLoading={imageLoading}
                      error={imageError}
                      onUpload={processImageFile}
                      onClear={clearImage}
                      t={t}
                    />
                  </CollapsibleSection>

                  {/* Presets Section - Moved from style tab */}
                  <CollapsibleSection
                    title={t.labels.presets || "Presets"}
                    icon="‚ö°"
                    isOpen={openSection === 'presets'}
                    onToggle={() => setOpenSection(openSection === 'presets' ? null : 'presets')}
                  >
                    <div className="icon-presets" style={{ display: 'grid', gridTemplateColumns: 'repeat(6, 1fr)', gap: '8px' }}>
                      {Object.entries(ELEMENT_TYPES).map(([key, data]) => (
                        <button
                          key={key}
                          type="button"
                          className="preset-btn"
                          onClick={() => {
                            setCardData(prev => ({
                              ...prev,
                              customIcon: data.icon,
                              primaryColor: data.primary,
                              secondaryColor: data.secondary,
                              particleEmoji: ELEMENT_PARTICLES[key]?.emoji || '‚ú®',
                              particleAnimation: key.toLowerCase(),
                              type: key,
                              weakness: data.weakness,
                              resistance: data.resistance,
                              cardInnerBackground: 'rgba(255, 255, 255, 0.95)',
                              cardInnerColorMode: 'solid',
                              cardInnerSecondaryBackground: `${data.primary}10`,
                              borderColor: data.primary,
                              nameColor: '', hpColor: '', typeColor: '', descColor: '', statsColor: '', authorColor: '', textColor: ''
                            }));
                            setAttacks(prev => prev.map(a => ({
                              ...a,
                              background: data.primary + '40',
                              secondaryBackground: data.secondary + '40',
                              colorMode: 'gradient'
                            })));
                          }}
                          title={t.elements[key] || key}
                          style={{
                            backgroundColor: data.primary + '20',
                            border: '1px solid ' + data.primary + '40',
                            borderRadius: '6px',
                            padding: '8px',
                            cursor: 'pointer',
                            fontSize: '1.2em',
                            transition: 'all 0.2s'
                          }}
                          onMouseEnter={(e) => {
                            e.currentTarget.style.backgroundColor = data.primary + '40';
                            e.currentTarget.style.transform = 'scale(1.05)';
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor = data.primary + '20';
                            e.currentTarget.style.transform = 'scale(1)';
                          }}
                        >
                          {data.icon}
                        </button>
                      ))}
                    </div>
                  </CollapsibleSection>

                  <CollapsibleSection
                    title={t.sections.particles || "Particles"}
                    icon="‚ú®"
                    isOpen={openSection === 'particles'}
                    onToggle={() => setOpenSection(openSection === 'particles' ? null : 'particles')}
                  >
                    <div className="grid-2">
                      <EmojiInput
                        label={t.labels.particleEmoji || "Particle Emoji"}
                        value={cardData.particleEmoji}
                        onChange={(v) => updateCardData('particleEmoji', v)}
                      />
                      <InputGroup
                        id="particle-animation"
                        label={t.labels.animation || "Animation"}
                        value={cardData.particleAnimation || 'fire'}
                        onChange={(v) => updateCardData('particleAnimation', v)}
                        options={PARTICLE_ANIMATIONS.map(anim => ({ value: anim.key, label: t.animations?.[anim.key] || anim.label }))}
                      />
                    </div>
                    <div style={{ marginTop: '12px' }}>
                      <Checkbox
                        id="show-particles"
                        label={t.checkboxes.showParticles}
                        checked={cardData.showParticles}
                        onChange={(v) => updateCardData('showParticles', v)}
                      />
                    </div>
                  </CollapsibleSection>

                </>
              )}

              {activeTab === 'colors' && (
                <>
                  {/* Card Style Section */}
                  <CollapsibleSection
                    title={t.sections.cardStyle || "Card Style"}
                    icon="üé®"
                    isOpen={openSection === 'cardStyle'}
                    onToggle={() => setOpenSection(openSection === 'cardStyle' ? null : 'cardStyle')}
                  >
                    <div className="grid-2" style={{ marginBottom: '12px' }}>
                      <EmojiInput
                        label={t.labels.element}
                        value={cardData.customIcon}
                        onChange={(v) => updateCardData('customIcon', v)}
                      />
                      <InputGroup
                        id="creature-stage"
                        label={t.labels.stage}
                        value={cardData.stage}
                        onChange={(v) => updateCardData('stage', v)}
                        options={stageOptions}
                      />
                    </div>
                    <div style={{ marginBottom: '12px', display: 'grid', gridTemplateColumns: cardData.texture && cardData.texture !== 'none' ? '2fr 1fr' : '1fr', gap: '8px' }}>
                      <InputGroup
                        id="card-texture"
                        label={t.labels.texture || "Texture"}
                        value={cardData.texture || 'none'}
                        onChange={(v) => updateCardData('texture', v)}
                        options={textureOptions}
                      />
                      {cardData.texture && cardData.texture !== 'none' && (
                        <InputGroup
                          id="texture-color"
                          label="Color"
                          type="color"
                          value={cardData.textureColor || '#000000'}
                          onChange={(v) => updateCardData('textureColor', v)}
                        />
                      )}
                    </div>
                    <div style={{ marginBottom: '12px' }}>
                      <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.backgroundStyle || "Background Style"}</label>
                      <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                        <button
                          className={`mode-toggle-btn ${cardData.colorMode === 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('colorMode', 'solid')}
                        >
                          {t.labels.solid || "Solid"}
                        </button>
                        <button
                          className={`mode-toggle-btn ${cardData.colorMode !== 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('colorMode', 'gradient')}
                        >
                          {t.labels.gradient || "Gradient"}
                        </button>
                      </div>
                      <div style={{ display: 'grid', gridTemplateColumns: cardData.colorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px', minHeight: '74px' }}>
                        <InputGroup
                          id="primary-color"
                          label={cardData.colorMode === 'solid' ? t.labels.backgroundColor : (t.labels.primaryColor || "Primary Color")}
                          type="color"
                          value={cardData.primaryColor}
                          onChange={(v) => updateCardData('primaryColor', v)}
                        />
                        {cardData.colorMode !== 'solid' && (
                          <InputGroup
                            id="secondary-color"
                            label={t.labels.secondaryColor || "Secondary Color"}
                            type="color"
                            value={cardData.secondaryColor}
                            onChange={(v) => updateCardData('secondaryColor', v)}
                          />
                        )}
                      </div>
                    </div>

                    <div style={{ marginBottom: '12px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '12px' }}>
                      <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.cardInner || "Card Inner Background"}</label>
                      <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                        <button
                          className={`mode-toggle-btn ${cardData.cardInnerColorMode === 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('cardInnerColorMode', 'solid')}
                        >
                          {t.labels.solid || "Solid"}
                        </button>
                        <button
                          className={`mode-toggle-btn ${cardData.cardInnerColorMode !== 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('cardInnerColorMode', 'gradient')}
                        >
                          {t.labels.gradient || "Gradient"}
                        </button>
                      </div>
                      <div style={{ display: 'grid', gridTemplateColumns: cardData.cardInnerColorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px' }}>
                        <InputGroup
                          id="inner-primary-color"
                          label={cardData.cardInnerColorMode === 'solid' ? (t.labels.backgroundColor || "Background") : (t.labels.primaryColor || "Primary")}
                          type="color"
                          value={cardData.cardInnerBackground || '#ffffff'}
                          onChange={(v) => updateCardData('cardInnerBackground', v)}
                        />
                        {cardData.cardInnerColorMode !== 'solid' && (
                          <InputGroup
                            id="inner-secondary-color"
                            label={t.labels.secondaryColor || "Secondary"}
                            type="color"
                            value={cardData.cardInnerSecondaryBackground || '#f5f5fa'}
                            onChange={(v) => updateCardData('cardInnerSecondaryBackground', v)}
                          />
                        )}
                      </div>
                    </div>
                    <InputGroup
                      id="card-border-color"
                      label={t.labels.borderColor}
                      type="color"
                      value={cardData.borderColor || '#ffd700'}
                      onChange={(v) => updateCardData('borderColor', v)}
                    />
                  </CollapsibleSection>

                  {/* Text Style Section */}
                  <CollapsibleSection
                    title={t.sections.textStyle || "Text Style"}
                    icon="üìù"
                    isOpen={openSection === 'textStyle'}
                    onToggle={() => setOpenSection(openSection === 'textStyle' ? null : 'textStyle')}
                  >
                    <div style={{ marginBottom: '20px' }}>
                      <InputGroup
                        id="card-font"
                        label={t.labels.font}
                        value={cardData.font}
                        onChange={(v) => updateCardData('font', v)}
                        options={fontOptions}
                      />
                    </div>

                    <div>
                      <TextSettingsGroup label={t.labels.name} colorKey="nameColor" sizeKey="nameSize" weightKey="nameWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.hp} colorKey="hpColor" sizeKey="hpSize" weightKey="hpWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.element + " / " + t.labels.stage} colorKey="typeColor" sizeKey="stageSize" weightKey="stageWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.abilityName || "Ability Name"} colorKey="moveNameColor" sizeKey="moveNameSize" weightKey="moveNameWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.abilityDesc || "Abilities Description"} colorKey="moveDescColor" sizeKey="moveDescSize" weightKey="moveDescWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.description} colorKey="descColor" sizeKey="descSize" weightKey="descWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.stats || "Stats"} colorKey="statsColor" sizeKey="statsSize" weightKey="statsWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.author} colorKey="authorColor" sizeKey="authorSize" weightKey="authorWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                    </div>
                  </CollapsibleSection>

                  {/* Ability Style Section */}
                  <CollapsibleSection
                    title={t.sections.abilityStyle || "Ability Style"}
                    icon="üé®"
                    isOpen={openSection === 'abilityStyle'}
                    onToggle={() => setOpenSection(openSection === 'abilityStyle' ? null : 'abilityStyle')}
                  >
                    {attacks.map((attack, idx) => (
                      <AttackStyleEditor
                        key={attack.id}
                        index={idx}
                        attack={attack}
                        typeIcon={typeIcon}
                        onUpdate={updateAttack}
                        t={t}
                      />
                    ))}
                  </CollapsibleSection>

                  {/* Display Options - Moved from visual tab */}
                  <CollapsibleSection
                    title={t.display.title}
                    icon="üëÅÔ∏è"
                    isOpen={openSection === 'appearance'}
                    onToggle={() => setOpenSection(openSection === 'appearance' ? null : 'appearance')}
                  >
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                      <Checkbox
                        id="show-hp"
                        label={t.checkboxes.showHP}
                        checked={cardData.showHP}
                        onChange={(v) => updateCardData('showHP', v)}
                      />
                      <Checkbox
                        id="show-weak-res"
                        label={t.checkboxes.showWeakRes}
                        checked={cardData.showWeakRes}
                        onChange={(v) => updateCardData('showWeakRes', v)}
                      />
                      <Checkbox
                        id="show-retreat"
                        label={t.checkboxes.showRetreat}
                        checked={cardData.showRetreat}
                        onChange={(v) => updateCardData('showRetreat', v)}
                      />
                      <Checkbox
                        id="show-desc"
                        label={t.checkboxes.showDescription}
                        checked={cardData.showDescription}
                        onChange={(v) => updateCardData('showDescription', v)}
                      />
                      <Checkbox
                        id="show-damage"
                        label={t.checkboxes.showDamage || 'Show Damage'}
                        checked={cardData.showDamage !== false}
                        onChange={(v) => updateCardData('showDamage', v)}
                      />
                    </div>
                  </CollapsibleSection>

                </>
              )}
            </div>

            {showResetConfirm && (
              <div className="modal-overlay" onClick={() => setShowResetConfirm(false)} style={{ zIndex: 11000 }}>
                <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '400px' }}>
                  <div className="modal-header">
                    <h3 style={{ color: '#f44336' }}>‚ö†Ô∏è {t.sections?.reset || 'Reset'}</h3>
                  </div>
                  <div className="modal-body">
                    <p>{t.prompts.resetConfirm}</p>
                  </div>
                  <div className="modal-footer">
                    <button className="secondary-button" onClick={() => setShowResetConfirm(false)}>
                      {t.common.cancel}
                    </button>
                    <button
                      className="primary-button"
                      style={{ background: '#f44336' }}
                      onClick={() => {
                        setCardData(INITIAL_CARD_DATA);
                        setAttacks(INITIAL_ATTACKS);
                        setImage(null);
                        setImageSettings(INITIAL_IMAGE_SETTINGS);
                        setShowResetConfirm(false);
                      }}
                    >
                      {t.buttons.resetCard}
                    </button>
                  </div>
                </div>
              </div>
            )}

            <SaveModal
              isOpen={isSaveModalOpen}
              onClose={() => setIsSaveModalOpen(false)}
              onSave={handleSaveCard}
              defaultName={cardData.name}
              t={t}
            />
            <LoadModal
              isOpen={isLoadModalOpen}
              onClose={() => setIsLoadModalOpen(false)}
              onLoad={handleLoadCard}
              onDelete={handleDeleteCard}
              onDeleteAll={handleDeleteAllCards}
              cards={savedCards}
              t={t}
            />
            <ConfirmModal
              isOpen={confirmState.isOpen}
              onClose={() => setConfirmState(prev => ({ ...prev, isOpen: false }))}
              onConfirm={confirmState.onConfirm}
              title={confirmState.title}
              message={confirmState.message}
              t={t}
            />

          </div></div></div >)
    }
    function CardCreator() {
      const [lang, setLang] = useState('en');
      const t = TRANSLATIONS[lang];

      return (
        <LanguageContext.Provider value={{ lang, setLang, t }}>
          <NotificationProvider>
            <CardCreatorContent />
          </NotificationProvider>
        </LanguageContext.Provider>
      )
    }
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CardCreator />);


  </script>
</body>

</html>
