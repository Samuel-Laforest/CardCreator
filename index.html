<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Creator</title>
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Html2Canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- Emoji Picker -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
  <script src="data.js"></script>
  <link rel="stylesheet" href="styles.css">
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@400;700&family=Bangers&family=Cinzel:wght@400;700;900&family=Dancing+Script:wght@400;700&family=Nunito:wght@400;700;900&family=Orbitron:wght@400;700;900&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700;900&family=Poppins:wght@400;700;900&family=Roboto:wght@400;700;900&display=swap"
    rel="stylesheet">
</head>

<body>
  <div id="root"></div>

  <!-- GIF Instructions Modal -->
  <div id="gif-instructions-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h3>üìπ High Quality GIF Capture (v2)</h3>
      </div>
      <div class="modal-body">
        <p>To get a perfect result, we need to capture the screen:</p>
        <div class="steps-list">
          <div class="step-item">
            <span class="step-number">1</span>
            <div id="gif-modal-step-1" class="step-text">Select the <strong>"Chrome Tab"</strong> tab.</div>
          </div>
          <div class="step-item">
            <span class="step-number">2</span>
            <div id="gif-modal-step-2" class="step-text">Choose <strong>this page</strong> from the list.</div>
          </div>
          <div class="step-item">
            <span class="step-number">3</span>
            <div id="gif-modal-step-3" class="step-text">Click <strong>"Share"</strong>.</div>
          </div>
        </div>
        <div class="gif-settings" style="margin-bottom: 20px; display: flex; gap: 15px;">
          <div class="setting-group" style="flex: 1;">
            <label id="gif-fps-label"
              style="display: block; color: #a0a0c0; font-size: 12px; margin-bottom: 5px; font-weight: 600;">FPS</label>
            <select id="gif-fps-select" class="gif-settings-select">
              <option value="15" id="gif-fps-normal">15 FPS (Normal)</option>
              <option value="24" id="gif-fps-cinema" selected>24 FPS (Cinema)</option>
              <option value="30" id="gif-fps-smooth">30 FPS (Smooth)</option>
              <option value="60" id="gif-fps-ultra">60 FPS (Ultra)</option>
            </select>
          </div>
          <div class="setting-group" style="flex: 1;">
            <label id="gif-quality-label"
              style="display: block; color: #a0a0c0; font-size: 12px; margin-bottom: 5px; font-weight: 600;">Quality
              (Height)</label>
            <select id="gif-scale-select" class="gif-settings-select">
              <option value="480" id="gif-quality-sd">480p (SD)</option>
              <option value="720" id="gif-quality-normal" selected>720p (HD)</option>
              <option value="1080" id="gif-quality-high">1080p (Full HD)</option>
              <option value="1440" id="gif-quality-qhd">1440p (QHD)</option>
              <option value="2160" id="gif-quality-ultra">4K (UHD)</option>
            </select>
          </div>
        </div>
        <div class="modal-note">
          <span class="note-icon">üí°</span>
          <span>The mouse will be automatically hidden and the card cropped.</span>
        </div>
        <div class="modal-warning">
          <span class="note-icon">‚ö†Ô∏è</span>
          <span>Using maximum settings (60 FPS / 4K) may take longer and use high CPU.</span>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancel-gif-btn" class="secondary-btn">Cancel</button>
        <button id="start-gif-btn" class="primary-btn">Start Capture</button>
      </div>
    </div>
  </div>

  <script type="text/babel">

    const { useState, useRef, useMemo, useCallback, useEffect, createContext, useContext } = React;
    const LanguageContext = createContext();
    const useLanguage = () => {
      const context = useContext(LanguageContext);
      if (!context) {
        throw new Error('useLanguage must be used within a LanguageProvider')
      }
      return context
    };

    // --- Notification System ---
    const NotificationContext = createContext();

    const NotificationToast = ({ notification, onClose }) => {
      useEffect(() => {
        if (notification.duration) {
          const timer = setTimeout(() => {
            onClose(notification.id);
          }, notification.duration);
          return () => clearTimeout(timer);
        }
      }, [notification, onClose]);

      const icons = {
        success: '‚úÖ',
        error: '‚ùå',
        info: '‚ÑπÔ∏è',
        warning: '‚ö†Ô∏è'
      };

      return (
        <div className={`notification-toast ${notification.type}`} onClick={() => onClose(notification.id)}>
          <div className="notification-icon">{icons[notification.type] || '‚ÑπÔ∏è'}</div>
          <div className="notification-content">
            <div className="notification-title">{notification.title}</div>
            <div className="notification-message">{notification.message}</div>
          </div>
          <button className="notification-close" onClick={(e) => { e.stopPropagation(); onClose(notification.id); }}>
            &times;
          </button>
        </div>
      );
    };

    const NotificationProvider = ({ children }) => {
      const { t } = useLanguage();
      const [notifications, setNotifications] = useState([]);

      const notify = useCallback((message, type = 'info', title = '', duration = 4000) => {
        const id = Date.now();
        const defaultTitles = {
          success: t.notifications?.success || 'Success',
          error: t.notifications?.error || 'Error',
          info: t.notifications?.info || 'Information',
          warning: t.notifications?.warning || 'Warning'
        };
        setNotifications(prev => [...prev, {
          id,
          message,
          type,
          title: title || defaultTitles[type],
          duration
        }]);
      }, []);

      const removeNotification = useCallback((id) => {
        setNotifications(prev => prev.filter(n => n.id !== id));
      }, []);

      const contextValue = useMemo(() => ({ notify }), [notify]);

      return (
        <NotificationContext.Provider value={contextValue}>
          {children}
          <div className="notification-container">
            {notifications.map(n => (
              <NotificationToast key={n.id} notification={n} onClose={removeNotification} />
            ))}
          </div>
        </NotificationContext.Provider>
      );
    };

    const useNotification = () => {
      const context = useContext(NotificationContext);
      if (!context) {
        throw new Error('useNotification must be used within a NotificationProvider');
      }
      return context;
    };
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const parseIntSafe = (value, fallback = 0) => {
      const parsed = parseInt(value, 10);
      return isNaN(parsed) ? fallback : parsed
    };
    const parseFloatSafe = (value, fallback = 0) => {
      const parsed = parseFloat(value);
      return isNaN(parsed) ? fallback : parsed
    };
    const generateId = () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const useThrottle = (callback, delay) => {
      const lastCall = useRef(0);
      const callbackRef = useRef(callback);
      callbackRef.current = callback;
      return useCallback((...args) => {
        const now = Date.now();
        if (now - lastCall.current >= delay) {
          lastCall.current = now;
          callbackRef.current(...args)
        }
      }, [delay])
    };

    const downloadAsImage = async (element, filename, format = 'png', targetHeight = 1080) => {
      if (!element) return;
      try {
        if (!window.html2canvas) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        // 1. Create a clean container for the clone
        const container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.top = '-10000px';
        container.style.left = '-10000px';
        container.style.zIndex = '-1';
        container.style.zoom = '1'; // Force no zoom
        container.style.width = 'auto';
        container.style.height = 'auto';
        document.body.appendChild(container);

        // 2. Clone the element
        const clone = element.cloneNode(true);

        // 3. Reset styles on the clone to ensure perfect capture
        clone.style.transform = 'none';
        clone.style.margin = '0';
        clone.style.zoom = '1';
        clone.style.position = 'relative';
        clone.style.boxShadow = 'none'; // Remove shadow to avoid border artifacts if that's the issue
        // If the user wants the shadow, we can comment the line above, but "borders" usually implies unwanted shadow area.
        // Let's assume we want a clean cut of the card content.
        // Re-reading: "le d√©coupage n'est pas bon" -> likely unwanted extra space.

        // For JPG, we keep the rounded corners but fill the background with white
        // This avoids black artifacts while preserving the card shape
        // The user will see white corners, which is the standard behavior for rounded images in JPG


        container.appendChild(clone);

        // 4. Calculate scale based on the CLEAN clone
        // We wait a microtask to let DOM update (though synchronous append usually works)
        const rect = clone.getBoundingClientRect();
        const scale = targetHeight / rect.height;

        const backgroundColor = format === 'jpg' ? '#ffffff' : null;

        const canvas = await html2canvas(clone, {
          backgroundColor: backgroundColor,
          scale: scale,
          useCORS: true,
          allowTaint: true,
          logging: false,
          removeContainer: true
        });

        // 5. Cleanup
        document.body.removeChild(container);

        const link = document.createElement('a');
        link.download = `${filename}.${format}`;
        link.href = canvas.toDataURL(`image/${format === 'jpg' ? 'jpeg' : format}`, 0.9);
        link.click();
      } catch (err) {
        console.error('Download failed:', err);
      }
    };
    const downloadAsPNG = (el, fn) => downloadAsImage(el, fn, 'png', 1080);
    const downloadAsJPG = (el, fn) => downloadAsImage(el, fn, 'jpg', 1080);
    const downloadAsWebP = (el, fn) => downloadAsImage(el, fn, 'webp', 1080);


    const downloadAsGIF = async (cardElement, filename = 'card', duration = 3000, fps = 15, t, onStatusChange) => {
      if (!cardElement) return false;

      try {
        // 1. Show instructions modal and wait for user confirmation
        const { stream, fps: selectedFps, targetHeight: selectedScale } = await new Promise((resolve, reject) => {
          const modal = document.getElementById('gif-instructions-modal');
          const startBtn = document.getElementById('start-gif-btn');
          const cancelBtn = document.getElementById('cancel-gif-btn');

          // Update modal text with translations
          const translations = t || (typeof TRANSLATIONS !== 'undefined' ? TRANSLATIONS['en'] : null);

          if (translations && translations.gifModal) {
            const gm = translations.gifModal;
            const titleEl = modal.querySelector('h3');
            if (titleEl) titleEl.textContent = gm.title;

            const bodyEl = modal.querySelector('p');
            if (bodyEl) bodyEl.textContent = gm.body;

            const step1 = modal.querySelector('#gif-modal-step-1');
            if (step1) step1.innerHTML = gm.step1;
            const step2 = modal.querySelector('#gif-modal-step-2');
            if (step2) step2.innerHTML = gm.step2;
            const step3 = modal.querySelector('#gif-modal-step-3');
            if (step3) step3.innerHTML = gm.step3;

            const noteEl = modal.querySelector('.modal-note span:last-child');
            if (noteEl) noteEl.textContent = gm.note;

            const warningEl = modal.querySelector('.modal-warning span:last-child');
            if (warningEl && gm.warning) warningEl.textContent = gm.warning;

            const fpsLabel = modal.querySelector('#gif-fps-label');
            if (fpsLabel && gm.fpsLabel) fpsLabel.textContent = gm.fpsLabel;

            const qualityLabel = modal.querySelector('#gif-quality-label');
            if (qualityLabel && gm.qualityLabel) qualityLabel.textContent = gm.qualityLabel;

            const fpsNormal = modal.querySelector('#gif-fps-normal');
            if (fpsNormal && gm.fpsNormal) fpsNormal.textContent = gm.fpsNormal;
            const fpsCinema = modal.querySelector('#gif-fps-cinema');
            if (fpsCinema && gm.fpsCinema) fpsCinema.textContent = gm.fpsCinema;
            const fpsSmooth = modal.querySelector('#gif-fps-smooth');
            if (fpsSmooth && gm.fpsSmooth) fpsSmooth.textContent = gm.fpsSmooth;
            const fpsUltra = modal.querySelector('#gif-fps-ultra');
            if (fpsUltra && gm.fpsUltra) fpsUltra.textContent = gm.fpsUltra;

            const qualitySD = modal.querySelector('#gif-quality-sd');
            if (qualitySD && gm.qualitySD) qualitySD.textContent = gm.qualitySD;
            const qualityNormal = modal.querySelector('#gif-quality-normal');
            if (qualityNormal && gm.qualityNormal) qualityNormal.textContent = gm.qualityNormal;
            const qualityHigh = modal.querySelector('#gif-quality-high');
            if (qualityHigh && gm.qualityHigh) qualityHigh.textContent = gm.qualityHigh;
            const qualityQHD = modal.querySelector('#gif-quality-qhd');
            if (qualityQHD && gm.qualityQHD) qualityQHD.textContent = gm.qualityQHD;
            const qualityUltra = modal.querySelector('#gif-quality-ultra');
            if (qualityUltra && gm.qualityUltra) qualityUltra.textContent = gm.qualityUltra;

            if (cancelBtn) cancelBtn.textContent = gm.cancel;
            if (startBtn) startBtn.textContent = gm.start;
          }

          modal.style.display = 'flex';

          const cleanup = () => {
            modal.style.display = 'none';
            startBtn.removeEventListener('click', onStart);
            cancelBtn.removeEventListener('click', onCancel);
          };

          const onStart = async () => {
            const selectedFps = parseInt(document.getElementById('gif-fps-select').value) || 15;
            const selectedHeight = parseInt(document.getElementById('gif-scale-select').value) || 720;

            cleanup();
            try {
              const s = await navigator.mediaDevices.getDisplayMedia({
                video: {
                  displaySurface: 'browser',
                  cursor: 'never',
                  width: { ideal: 3840 }, // Request 4K resolution
                  height: { ideal: 2160 }
                },
                audio: false,
                preferCurrentTab: true
              });
              resolve({ stream: s, fps: selectedFps, targetHeight: selectedHeight });
            } catch (err) {
              reject(err);
            }
          };

          const onCancel = () => {
            cleanup();
            reject(new Error('User cancelled'));
          };

          startBtn.addEventListener('click', onStart);
          cancelBtn.addEventListener('click', onCancel);
        });

        // Add capturing class to freeze layout and hide cursor
        document.body.classList.add('is-capturing');
        document.documentElement.classList.add('is-capturing');

        // Create overlay to block mouse
        const overlay = document.createElement('div');
        overlay.id = 'capture-overlay';

        // Brute-force block all mouse events
        const blockEvent = (e) => {
          e.preventDefault();
          e.stopPropagation();
          return false;
        };
        ['mousemove', 'mousedown', 'mouseup', 'click', 'contextmenu', 'dblclick', 'wheel', 'mouseover', 'mouseout'].forEach(event => {
          overlay.addEventListener(event, blockEvent, { capture: true, passive: false });
        });

        document.body.appendChild(overlay);
        if (document.activeElement) document.activeElement.blur(); // Remove focus

        if (onStatusChange) onStatusChange(t?.gifModal?.loadingLibs || '‚è≥ Loading libs...');

        // 2. Load dependencies
        if (!window.GIF) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        // 3. Setup Video & Canvas
        const video = document.createElement('video');
        video.srcObject = stream;
        video.play();

        // Wait for video dimensions and layout stabilization
        await new Promise(r => video.onloadedmetadata = r);
        await new Promise(r => setTimeout(r, 1000)); // Longer warmup for layout shift

        if (onStatusChange) onStatusChange(t?.gifModal?.capturing || 'üì∏ Capturing...');

        const workerBlob = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js')
          .then(r => r.blob());
        const workerUrl = URL.createObjectURL(workerBlob);

        // Since we fixed the card to center (50% 50%), we crop the center of the video
        // We target the .game-card specifically to be precise
        const gameCard = document.querySelector('.game-card');
        const rect = gameCard.getBoundingClientRect();

        // Inset to crop tighter on the card edges (0 = exact fit)
        const inset = 0;

        const scaleX = video.videoWidth / window.innerWidth;
        const scaleY = video.videoHeight / window.innerHeight;

        // Calculate crop size based on card size minus inset
        const cropW = (rect.width - inset * 2) * scaleX;
        const cropH = (rect.height - inset * 2) * scaleY;

        // Use the actual card position with inset adjustment
        const cropX = (rect.left + inset) * scaleX;
        const cropY = (rect.top + inset) * scaleY;

        // Apply user selected height standard
        const finalH = selectedScale; // selectedScale is actually targetHeight now
        const aspectRatio = cropW / cropH;
        const finalW = Math.round(finalH * aspectRatio);

        const gif = new GIF({
          workers: 2,
          quality: 1, // Best quality
          workerScript: workerUrl,
          width: finalW,
          height: finalH
        });

        const canvas = document.createElement('canvas');
        canvas.width = finalW;
        canvas.height = finalH;
        const ctx = canvas.getContext('2d');

        // 4. Capture Loop & Promise Wrapper
        return new Promise((resolve, reject) => {
          const frameInterval = 1000 / selectedFps;
          const totalFrames = (duration / 1000) * selectedFps;
          let frameCount = 0;

          const finishCapture = () => {
            // Stop stream
            stream.getTracks().forEach(track => track.stop());
            document.body.classList.remove('is-capturing');
            document.documentElement.classList.remove('is-capturing');
            if (overlay) overlay.remove();

            if (onStatusChange) onStatusChange(t?.download?.encoding || '‚öôÔ∏è Encoding...');

            gif.on('finished', (blob) => {
              const link = document.createElement('a');
              link.download = filename + '.gif';
              link.href = URL.createObjectURL(blob);
              link.click();

              URL.revokeObjectURL(workerUrl);
              resolve(true);
            });

            gif.render();
          };

          const captureInterval = setInterval(() => {
            if (frameCount >= totalFrames) {
              clearInterval(captureInterval);
              finishCapture();
              return;
            }

            // Draw cropped video frame to canvas (Center crop) with scaling
            ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, finalW, finalH);
            gif.addFrame(canvas, { copy: true, delay: frameInterval });

            frameCount++;
            if (onStatusChange) onStatusChange(`üì∏ ${Math.round((frameCount / totalFrames) * 100)}%`);
          }, frameInterval);
        });

      } catch (error) {
        console.error('GIF Error:', error);
        document.body.classList.remove('is-capturing');
        document.documentElement.classList.remove('is-capturing');
        const overlay = document.getElementById('capture-overlay');
        if (overlay) overlay.remove();
        throw error; // Re-throw to be handled by caller
      }
    };
    // --- IndexedDB Helper (FluxDB) ---
    const db = {
      dbName: 'CardCreatorDB',
      version: 1,
      storeName: 'cards',

      open() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.version);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              db.createObjectStore(this.storeName, { keyPath: 'id' });
            }
          };
        });
      },

      async save(card) {
        // Sanitize name before saving
        const sanitizedCard = { ...card, name: sanitize(card.name) };
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.put(sanitizedCard);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
        });
      },

      async getAll() {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result.sort((a, b) => b.timestamp - a.timestamp)); // Newest first
        });
      },

      async delete(id) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.delete(id);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      },

      async cleanupOld(maxAgeDays = 30) {
        const db = await this.open();
        const maxAge = maxAgeDays * 24 * 60 * 60 * 1000; // Convert days to ms
        const now = Date.now();

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            const cards = request.result;
            const oldCards = cards.filter(card => (now - card.timestamp) > maxAge);

            oldCards.forEach(card => {
              store.delete(card.id);
            });

            resolve(oldCards.length);
          };
        });
      },

      async deleteAll() {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.clear();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      }
    };

    const sanitize = (str) => {
      if (!str) return '';
      // Escape all HTML special characters to prevent XSS
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
    };

    // Validate color strings to prevent CSS injection
    const isValidColor = (color) => {
      if (!color) return true;
      // Allow hex colors, rgb/rgba, hsl/hsla, and named colors
      const colorRegex = /^(#[0-9A-Fa-f]{3,8}|rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\)|rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*[\d.]+\)|hsl\(\d{1,3},\s*\d{1,3}%,\s*\d{1,3}%\)|hsla\(\d{1,3},\s*\d{1,3}%,\s*\d{1,3}%,\s*[\d.]+\)|[a-zA-Z]+)$/;
      return colorRegex.test(color.trim());
    };

    // Sanitize card data to prevent injection attacks
    const sanitizeCardData = (data) => {
      if (!data || typeof data !== 'object') return {};
      const sanitized = {};
      const colorFields = ['borderColor', 'backgroundColor', 'abilityBackground', 'textColor', 'nameColor', 'hpColor', 'typeColor', 'descColor', 'statsColor', 'authorColor', 'primaryColor', 'secondaryColor', 'cardInnerBackground', 'cardInnerSecondaryBackground', 'textureColor', 'moveNameColor', 'moveDescColor'];
      const textFields = ['name', 'description', 'author'];
      const numberFields = ['hp', 'retreatCost', 'nameSize', 'hpSize', 'stageSize', 'descSize', 'statsSize', 'authorSize', 'moveNameSize', 'moveDescSize'];

      for (const [key, value] of Object.entries(data)) {
        if (colorFields.includes(key)) {
          sanitized[key] = isValidColor(value) ? value : '';
        } else if (textFields.includes(key)) {
          sanitized[key] = sanitize(String(value || '').substring(0, 200));
        } else if (numberFields.includes(key)) {
          sanitized[key] = typeof value === 'number' ? Math.min(Math.max(value, 0), 9999) : 0;
        } else if (typeof value === 'boolean') {
          sanitized[key] = !!value;
        } else if (typeof value === 'string') {
          sanitized[key] = String(value).substring(0, 500);
        } else {
          sanitized[key] = value;
        }
      }
      return sanitized;
    };

    // --- Deck Builder Modal ---
    const PAPER_FORMATS = [
      { id: 'a4', label: 'A4', width: 794, height: 1123 },
      { id: 'a3', label: 'A3', width: 1123, height: 1587 }
    ];

    const DeckBuilderModal = ({ isOpen, onClose, t, savedCards, notify }) => {
      const [paperFormat, setPaperFormat] = useState('a4');
      const [cardCount, setCardCount] = useState(9);
      const [cardWidthCm, setCardWidthCm] = useState(6.35);
      const [showCustomSettings, setShowCustomSettings] = useState(false);

      const paper = PAPER_FORMATS.find(p => p.id === paperFormat) || PAPER_FORMATS[0];
      const padding = 15; // Optimized: reduced from 30px for more cards
      const gap = 6; // Optimized: reduced from 12px for more cards
      const cardRatio = 448 / 320;

      // Convert cm to px (96dpi = 37.795px per cm)
      const pxPerCm = 37.795;

      // Calculate max card size that fits on paper (at least 1 card must fit)
      const maxCardWidthFromWidth = (paper.width - padding * 2) / pxPerCm;
      const maxCardWidthFromHeight = (paper.height - padding * 2) / cardRatio / pxPerCm;
      const maxCardWidthCm = Math.min(maxCardWidthFromWidth, maxCardWidthFromHeight);

      // Ensure cardWidthCm doesn't exceed max
      const effectiveCardWidthCm = Math.min(cardWidthCm, maxCardWidthCm);
      const cardWidthPx = effectiveCardWidthCm * pxPerCm;
      const cardHeightPx = cardWidthPx * cardRatio;

      // Function to calculate max cards for a given card size (in cm)
      const getMaxCardsForSize = useCallback((widthCm, formatId = paperFormat) => {
        const targetPaper = PAPER_FORMATS.find(p => p.id === formatId) || PAPER_FORMATS[0];
        const clampedWidth = Math.min(widthCm, Math.min((targetPaper.width - padding * 2) / pxPerCm, (targetPaper.height - padding * 2) / cardRatio / pxPerCm));
        const widthPx = clampedWidth * pxPerCm;
        const heightPx = widthPx * cardRatio;
        const cols = Math.floor((targetPaper.width - padding * 2 + gap) / (widthPx + gap));
        const rows = Math.floor((targetPaper.height - padding * 2 + gap) / (heightPx + gap));
        return Math.max(1, cols * rows);
      }, [paperFormat]);

      // Calculate how many cards fit with the requested size
      const maxCols = Math.floor((paper.width - padding * 2 + gap) / (cardWidthPx + gap));
      const maxRows = Math.floor((paper.height - padding * 2 + gap) / (cardHeightPx + gap));
      const maxCards = maxCols * maxRows;

      // Limit card count to what fits
      const effectiveCardCount = Math.min(cardCount, maxCards);

      // Calculate best grid layout for the effective card count
      const calculateLayout = (count, maxC, maxR) => {
        let bestCols = 1, bestRows = count;
        let bestWaste = count;

        for (let c = 1; c <= Math.min(count, maxC); c++) {
          const r = Math.ceil(count / c);
          if (r <= maxR) {
            const waste = (c * r) - count;
            if (waste < bestWaste || (waste === bestWaste && Math.abs(c - r) < Math.abs(bestCols - bestRows))) {
              bestWaste = waste;
              bestCols = c;
              bestRows = r;
            }
          }
        }
        return { cols: bestCols, rows: bestRows };
      };

      const layout = calculateLayout(effectiveCardCount, maxCols, maxRows);
      const { cols, rows } = layout;

      const [grid, setGrid] = useState([]);
      const gridRef = useRef(null);

      useEffect(() => {
        setGrid(prev => {
          const newGrid = Array(effectiveCardCount).fill(null);
          prev.forEach((card, i) => {
            if (i < effectiveCardCount) newGrid[i] = card;
          });
          return newGrid;
        });
      }, [effectiveCardCount]);

      const addToGrid = useCallback((card) => {
        setGrid(prev => {
          const idx = prev.findIndex(item => item === null);
          if (idx === -1) {
            notify(t.deckBuilder?.full || "Grid is full!", 'error');
            return prev;
          }
          const newGrid = [...prev];
          newGrid[idx] = card;
          return newGrid;
        });
      }, [notify, t]);

      const removeFromGrid = useCallback((index) => {
        setGrid(prev => {
          const newGrid = [...prev];
          newGrid[index] = null;
          return newGrid;
        });
      }, []);

      const clearGrid = useCallback(() => {
        setGrid(Array(cardCount).fill(null));
      }, [cardCount]);

      const handleExport = async () => {
        if (!gridRef.current) return;
        try {
          notify(t.deckBuilder?.exporting || "Preparing sheet...", 'info');
          // Professional quality: scale 6 = ~300 DPI for print
          const canvas = await html2canvas(gridRef.current, {
            scale: 6,
            useCORS: true,
            backgroundColor: '#ffffff',
            logging: false,
            allowTaint: false
          });
          const link = document.createElement('a');
          link.download = `deck_sheet_${paperFormat.toUpperCase()}_${effectiveCardCount}cards_${Date.now()}.png`;
          // Use PNG for lossless quality
          link.href = canvas.toDataURL('image/png', 1.0);
          link.click();
          notify(t.deckBuilder?.success || "Sheet downloaded!", 'success');
        } catch (err) {
          console.error(err);
          notify(t.deckBuilder?.error || "Export failed", 'error');
        }
      };

      const handleExportPDF = async () => {
        if (!gridRef.current) return;
        try {
          notify(t.deckBuilder?.exporting || "Preparing PDF...", 'info');

          // Professional quality: scale 6 = ~300 DPI for print
          const canvas = await html2canvas(gridRef.current, {
            scale: 6,
            useCORS: true,
            backgroundColor: '#ffffff',
            logging: false,
            allowTaint: false
          });

          // Get jsPDF from global scope
          const { jsPDF } = window.jspdf;

          // Create PDF with correct paper format and orientation
          const pdfFormat = paperFormat === 'a3' ? 'a3' : 'a4';
          const pdf = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: pdfFormat,
            compress: false // No compression for max quality
          });

          // Get PDF page dimensions in mm
          const pageWidth = pdf.internal.pageSize.getWidth();
          const pageHeight = pdf.internal.pageSize.getHeight();

          // Use PNG for lossless quality in PDF
          const imgData = canvas.toDataURL('image/png', 1.0);
          pdf.addImage(imgData, 'PNG', 0, 0, pageWidth, pageHeight, undefined, 'NONE');

          // Save the PDF
          pdf.save(`deck_sheet_${pdfFormat.toUpperCase()}_${effectiveCardCount}cards_${Date.now()}.pdf`);

          notify(t.deckBuilder?.successPdf || "PDF downloaded!", 'success');
        } catch (err) {
          console.error(err);
          notify(t.deckBuilder?.error || "Export failed", 'error');
        }
      };

      if (!isOpen) return null;

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content deck-modal" onClick={e => e.stopPropagation()} style={{ width: '95vw', height: '90vh', maxWidth: '1400px', display: 'flex', flexDirection: 'column', padding: 0, borderRadius: '16px', overflow: 'hidden', background: '#1e1e2f' }}>
            <div className="modal-header" style={{ padding: '16px 24px', borderBottom: '1px solid rgba(255,255,255,0.1)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <span style={{ fontSize: '24px' }}>üñ®Ô∏è</span>
                <div>
                  <h3 style={{ margin: 0, fontSize: '20px', fontWeight: '600' }}>{t.deckBuilder?.title || "Deck Builder"}</h3>
                  <span style={{ fontSize: '12px', opacity: 0.6 }}>{paper.label} ‚Ä¢ {cardCount} {t.deckBuilder?.cards || "cards"} ({cols}√ó{rows})</span>
                </div>
              </div>
              <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
                <button className="secondary-btn" onClick={clearGrid}>üóëÔ∏è {t.deckBuilder?.clear || "Clear"}</button>
                <button className="secondary-btn" onClick={handleExport} title="PNG">üñºÔ∏è PNG</button>
                <button className="primary-btn" onClick={handleExportPDF} title="PDF">üìÑ PDF</button>
                <button className="secondary-btn" onClick={onClose} style={{ padding: '8px 12px' }}>‚úï</button>
              </div>
            </div>

            <div className="modal-body" style={{ flex: 1, display: 'flex', overflow: 'hidden', padding: 0 }}>
              <div className="deck-library" style={{ width: '280px', background: 'rgba(0,0,0,0.2)', padding: '20px', overflowY: 'auto', borderRight: '1px solid rgba(255,255,255,0.1)' }}>
                {/* Settings - Simplified with Presets */}
                <div style={{ marginBottom: '20px', paddingBottom: '16px', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '12px' }}>
                    <span>‚öôÔ∏è</span>
                    <h4 style={{ margin: 0, fontSize: '14px', fontWeight: '600' }}>{t.deckBuilder?.settings || "Settings"}</h4>
                  </div>

                  {/* Paper Format */}
                  <div style={{ marginBottom: '12px' }}>
                    <label style={{ display: 'block', fontSize: '11px', color: '#a0a0c0', marginBottom: '4px', textTransform: 'uppercase' }}>{t.deckBuilder?.paperFormat || "Paper"}</label>
                    <select value={paperFormat} onChange={e => setPaperFormat(e.target.value)} style={{ width: '100%', padding: '8px', borderRadius: '6px', background: '#1a1a2e', border: '1px solid rgba(255,255,255,0.2)', color: '#fff', cursor: 'pointer' }}>
                      {PAPER_FORMATS.map(fmt => <option key={fmt.id} value={fmt.id} style={{ background: '#1a1a2e', color: '#fff' }}>{fmt.label}</option>)}
                    </select>
                  </div>

                  {/* Quick Presets - Grid Layout */}
                  <label style={{ display: 'block', fontSize: '11px', color: '#a0a0c0', marginBottom: '8px', textTransform: 'uppercase' }}>{t.deckBuilder?.presets || "Quick Presets"}</label>
                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '6px', marginBottom: '12px' }}>
                    <button
                      onClick={() => { const max = getMaxCardsForSize(6.35); setCardWidthCm(6.35); setCardCount(max); }}
                      style={{ padding: '10px 8px', borderRadius: '8px', background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)', border: 'none', color: '#fff', fontSize: '11px', fontWeight: '600', cursor: 'pointer', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}
                    >
                      <span style={{ fontSize: '16px' }}>üé¥</span>
                      <span>{t.deckBuilder?.presetStandard || "Standard"}</span>
                      <span style={{ fontSize: '9px', opacity: 0.7 }}>{getMaxCardsForSize(6.35)} {t.deckBuilder?.cards || "cards"}</span>
                    </button>
                    <button
                      onClick={() => { const max = getMaxCardsForSize(5); setCardWidthCm(5); setCardCount(max); }}
                      style={{ padding: '10px 8px', borderRadius: '8px', background: 'linear-gradient(135deg, #10b981, #059669)', border: 'none', color: '#fff', fontSize: '11px', fontWeight: '600', cursor: 'pointer', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}
                    >
                      <span style={{ fontSize: '16px' }}>üì¶</span>
                      <span>{t.deckBuilder?.presetCompact || "Compact"}</span>
                      <span style={{ fontSize: '9px', opacity: 0.7 }}>{getMaxCardsForSize(5)} {t.deckBuilder?.cards || "cards"}</span>
                    </button>
                    <button
                      onClick={() => { const max = getMaxCardsForSize(4); setCardWidthCm(4); setCardCount(max); }}
                      style={{ padding: '10px 8px', borderRadius: '8px', background: 'linear-gradient(135deg, #f59e0b, #d97706)', border: 'none', color: '#fff', fontSize: '11px', fontWeight: '600', cursor: 'pointer', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}
                    >
                      <span style={{ fontSize: '16px' }}>üÉè</span>
                      <span>{t.deckBuilder?.presetMini || "Mini"}</span>
                      <span style={{ fontSize: '9px', opacity: 0.7 }}>{getMaxCardsForSize(4)} {t.deckBuilder?.cards || "cards"}</span>
                    </button>
                    <button
                      onClick={() => { const maxSize = Math.floor(maxCardWidthCm * 10) / 10; setCardWidthCm(maxSize); setCardCount(1); }}
                      style={{ padding: '10px 8px', borderRadius: '8px', background: 'linear-gradient(135deg, #ec4899, #be185d)', border: 'none', color: '#fff', fontSize: '11px', fontWeight: '600', cursor: 'pointer', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}
                    >
                      <span style={{ fontSize: '16px' }}>üñºÔ∏è</span>
                      <span>{t.deckBuilder?.presetMax || "Max"}</span>
                      <span style={{ fontSize: '9px', opacity: 0.7 }}>1 {t.deckBuilder?.card || "card"} ({maxCardWidthCm.toFixed(1)} cm)</span>
                    </button>
                  </div>

                  {/* Current Configuration Display */}
                  <div style={{ background: 'rgba(59, 130, 246, 0.1)', padding: '10px', borderRadius: '8px', marginBottom: '8px', border: '1px solid rgba(59, 130, 246, 0.2)' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', marginBottom: '4px' }}>
                      <span style={{ color: '#a0a0c0' }}>{t.deckBuilder?.currentLayout || "Current"}:</span>
                      <span style={{ fontWeight: '600', color: '#3b82f6' }}>{cols}√ó{rows} ({effectiveCardCount} {t.deckBuilder?.cards || "cards"})</span>
                    </div>
                    <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px' }}>
                      <span style={{ color: '#a0a0c0' }}>{t.deckBuilder?.cardSize || "Card Size"}:</span>
                      <span style={{ fontWeight: '600', color: '#3b82f6' }}>{effectiveCardWidthCm.toFixed(1)} cm (max: {maxCardWidthCm.toFixed(1)})</span>
                    </div>
                  </div>

                  {/* Custom Settings Toggle */}
                  <button
                    onClick={() => setShowCustomSettings && setShowCustomSettings(prev => !prev)}
                    style={{ width: '100%', padding: '8px', borderRadius: '6px', background: 'transparent', border: '1px dashed rgba(255,255,255,0.2)', color: '#a0a0c0', fontSize: '11px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px' }}
                  >
                    <span>üîß</span>
                    <span>{t.deckBuilder?.customize || "Customize"}</span>
                    <span style={{ fontSize: '10px' }}>{showCustomSettings ? '‚ñ≤' : '‚ñº'}</span>
                  </button>

                  {/* Custom Settings (Hidden by Default) */}
                  {showCustomSettings && (
                    <div style={{ marginTop: '12px', padding: '12px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                      <div style={{ marginBottom: '12px' }}>
                        <label style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#a0a0c0', marginBottom: '4px' }}>
                          <span>{t.deckBuilder?.cardCount || "Cards"}</span>
                          <span style={{ color: '#fff' }}>{cardCount}</span>
                        </label>
                        <input type="range" min={1} max={64} value={cardCount} onChange={e => setCardCount(parseInt(e.target.value))} style={{ width: '100%' }} />
                      </div>
                      <div>
                        <label style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#a0a0c0', marginBottom: '4px' }}>
                          <span>{t.deckBuilder?.cardSize || "Card Size"}</span>
                          <span style={{ color: '#fff' }}>{effectiveCardWidthCm.toFixed(1)} cm</span>
                        </label>
                        <input type="range" min={3} max={Math.floor(maxCardWidthCm * 10) / 10} step={0.1} value={cardWidthCm} onChange={e => setCardWidthCm(parseFloat(e.target.value))} style={{ width: '100%' }} />
                      </div>
                    </div>
                  )}
                </div>

                {/* Library */}
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '16px' }}>
                  <span style={{ fontSize: '18px' }}>üìö</span>
                  <h4 style={{ margin: 0, fontSize: '15px', fontWeight: '600' }}>{t.deckBuilder?.library || "Library"}</h4>
                  <span style={{ background: '#3b82f6', padding: '2px 8px', borderRadius: '10px', fontSize: '11px', fontWeight: '600' }}>{savedCards.length}</span>
                </div>
                {savedCards.length === 0 ? (
                  <div style={{ textAlign: 'center', opacity: 0.5, marginTop: '40px', padding: '20px' }}>
                    <span style={{ fontSize: '36px', display: 'block', marginBottom: '12px', opacity: 0.6 }}>üì≠</span>
                    <span style={{ fontSize: '13px' }}>{t.prompts?.noSaves || "No cards found"}</span>
                  </div>
                ) : (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                    {savedCards.map(card => (
                      <div key={card.id} className="library-card" style={{ borderRadius: '8px', overflow: 'hidden', background: 'rgba(255,255,255,0.03)', padding: '8px', border: '1px solid rgba(255,255,255,0.05)' }}>
                        <div style={{ fontSize: '11px', marginBottom: '8px', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', textAlign: 'center', fontWeight: '600', color: '#a0a0c0' }}>{card.name}</div>
                        <div style={{ display: 'flex', gap: '6px' }}>
                          <div onClick={() => addToGrid({ ...card, usedSide: 'front', displayImage: card.thumbnail || card.image })} style={{ flex: 1, cursor: 'pointer', position: 'relative', borderRadius: '6px', overflow: 'hidden', border: '2px solid rgba(59, 130, 246, 0.3)' }} onMouseOver={e => e.currentTarget.style.borderColor = '#3b82f6'} onMouseOut={e => e.currentTarget.style.borderColor = 'rgba(59, 130, 246, 0.3)'}>
                            <img src={card.thumbnail || card.image} alt={card.name + ' front'} style={{ width: '100%', borderRadius: '4px', aspectRatio: '320/448', objectFit: 'cover' }} />
                            <div style={{ position: 'absolute', bottom: 0, left: 0, right: 0, background: 'rgba(59, 130, 246, 0.9)', color: 'white', fontSize: '9px', fontWeight: '600', textAlign: 'center', padding: '2px 0' }}>üé¥ {t.download?.frontSide || 'Front'}</div>
                          </div>
                          <div onClick={() => addToGrid({ ...card, usedSide: 'back', displayImage: card.thumbnailBack || card.thumbnail })} style={{ flex: 1, cursor: 'pointer', position: 'relative', borderRadius: '6px', overflow: 'hidden', border: '2px solid rgba(139, 92, 246, 0.3)' }} onMouseOver={e => e.currentTarget.style.borderColor = '#8b5cf6'} onMouseOut={e => e.currentTarget.style.borderColor = 'rgba(139, 92, 246, 0.3)'}>
                            <img src={card.thumbnailBack || card.thumbnail} alt={card.name + ' back'} style={{ width: '100%', borderRadius: '4px', aspectRatio: '320/448', objectFit: 'cover', background: '#1a1a2e' }} />
                            <div style={{ position: 'absolute', bottom: 0, left: 0, right: 0, background: 'rgba(139, 92, 246, 0.9)', color: 'white', fontSize: '9px', fontWeight: '600', textAlign: 'center', padding: '2px 0' }}>üîô {t.download?.backSide || 'Back'}</div>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              <div className="deck-workspace" style={{ flex: 1, background: '#2a2a3e', overflow: 'auto', padding: '30px', display: 'flex', justifyContent: 'center', alignItems: 'flex-start' }}>
                <div ref={gridRef} className="a4-sheet" style={{
                  width: `${paper.width}px`,
                  minHeight: `${paper.height}px`,
                  background: '#ffffff',
                  boxShadow: '0 10px 40px rgba(0,0,0,0.5)',
                  padding: `${padding}px`,
                  display: 'flex',
                  flexWrap: 'wrap',
                  justifyContent: 'center',
                  alignContent: 'flex-start',
                  gap: `${gap}px`,
                  borderRadius: '4px'
                }}>
                  {grid.map((card, i) => (
                    <div key={i} className="sheet-slot" onClick={() => card && removeFromGrid(i)} title={card ? (t.deckBuilder?.clickToRemove || "Click to remove") : ''}
                      style={{
                        width: `${cardWidthPx}px`,
                        height: `${cardHeightPx}px`,
                        border: card ? '1px solid #e0e0e0' : '2px dashed #ccc',
                        borderRadius: '8px',
                        overflow: 'hidden',
                        position: 'relative',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        background: card ? '#fff' : '#f5f5f5',
                        cursor: card ? 'pointer' : 'default',
                        flexShrink: 0
                      }}>
                      {card ? <img src={card.displayImage || card.image || card.thumbnail} alt={card.name} style={{ width: '100%', height: '100%', objectFit: 'contain' }} /> : <span style={{ color: '#bbb', fontSize: '24px', fontWeight: 'bold' }}>{i + 1}</span>}
                      {card && <div className="slot-overlay" style={{ position: 'absolute', inset: 0, background: 'rgba(239, 68, 68, 0.85)', opacity: 0, transition: 'opacity 0.2s', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', fontSize: '24px', borderRadius: '6px' }}>‚úï</div>}
                      <style>{`.sheet-slot:hover .slot-overlay { opacity: 1; }`}</style>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };


    // --- Save/Load Components ---

    // --- Autosave Effect (Debounced) ---
    const SaveModal = ({ isOpen, onClose, onSave, defaultName, t }) => {
      const [name, setName] = useState(defaultName);
      useEffect(() => setName(defaultName), [defaultName]);

      if (!isOpen) return null;

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content" onClick={e => e.stopPropagation()}>
            <div className="modal-header">
              <h3>üíæ {t.buttons.save || 'Save Card'}</h3>
            </div>
            <div className="modal-body">
              <div className="modal-note">
                <span className="note-icon">‚ÑπÔ∏è</span>
                <span>{t.prompts.saveHint || 'Your card (text + image) will be saved locally.'}</span>
              </div>
              <div style={{ marginTop: '15px', marginBottom: '20px' }}>
                <InputGroup
                  id="save-name"
                  label={t.labels.name}
                  value={name}
                  onChange={setName}
                  maxLength={50}
                />
              </div>
            </div>
            <div className="modal-footer">
              <button className="secondary-button" onClick={onClose}>{t.common.cancel}</button>
              <button className="primary-button" onClick={() => onSave(name)}>{t.buttons.save}</button>
            </div>
          </div>
        </div>
      );
    };

    const LoadModal = ({ isOpen, onClose, onLoad, onDelete, onDeleteAll, cards, t }) => {
      if (!isOpen) return null;

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content load-modal" onClick={e => e.stopPropagation()}>
            <div className="modal-header">
              <h3>üìÇ {t.buttons.load || 'Load Card'}</h3>
            </div>
            <div className="modal-note" style={{ margin: '0 0 15px 0' }}>
              <span className="note-icon">üïê</span>
              <span>{t.prompts.autoDeleteInfo || 'Saved cards are automatically deleted after 30 days.'}</span>
            </div>
            <div className="modal-body" style={{ overflowY: 'auto', paddingRight: '5px' }}>

              {cards.length === 0 ? (
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '40px', gap: '15px', textAlign: 'center' }}>
                  <div style={{ fontSize: '40px', opacity: 0.8 }}>üì≠</div>
                  <div style={{ fontWeight: 600, color: '#888' }}>{t.prompts.noSaves || 'No saved cards found.'}</div>
                </div>
              ) : (
                <div className="saved-cards-grid">
                  {cards.map(card => (
                    <div key={card.id} className="saved-card-item" onClick={() => onLoad(card)} title={t.buttons.load}>
                      <button
                        className="delete-card-btn"
                        onClick={(e) => { e.stopPropagation(); onDelete(card.id); }}
                        title={t.buttons.remove}
                      >
                        &times;
                      </button>
                      <div className="saved-card-preview" style={{ backgroundImage: `url(${card.thumbnail || card.image})`, backgroundSize: 'cover', backgroundPosition: 'top center' }}>
                        {!card.image && !card.thumbnail && <span style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', fontSize: '3em' }}>üÉè</span>}
                      </div>
                      <div className="saved-card-info">
                        <div className="saved-card-name">{card.name}</div>
                        <div className="saved-card-date">{new Date(card.timestamp).toLocaleDateString()} ‚Ä¢ {new Date(card.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
            <div className="modal-footer" style={{ marginTop: '20px', justifyContent: 'flex-end', gap: '12px' }}>
              <button className="secondary-button" onClick={onClose}>{t.common.close || 'Close'}</button>
              {cards.length > 0 && (
                <button className="primary-button" style={{ background: '#f44336' }} onClick={onDeleteAll}>
                  üóëÔ∏è {t.buttons.deleteAll || 'Delete All'}
                </button>
              )}
            </div>
          </div>
        </div>
      );
    };

    const JsonModal = ({ isOpen, onClose, onImport, onExport, t }) => {
      const fileInputRef = useRef(null);
      const [error, setError] = useState(null);

      const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const json = JSON.parse(event.target.result);
            onImport(json);
            setError(null);
            onClose();
          } catch (err) {
            setError(t.json.errorImport);
            console.error("JSON Import Error:", err);
          }
        };
        reader.readAsText(file);
        e.target.value = ''; // Reset
      };

      if (!isOpen) return null;

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '600px' }}>
            <div className="modal-header">
              <h3>‚öôÔ∏è {t.json.modalTitle}</h3>
            </div>

            <div className="modal-body">
              <p style={{ opacity: 0.8, marginBottom: '20px' }}>{t.json.help}</p>

              <div style={{ display: 'flex', gap: '15px', flexWrap: 'wrap' }}>
                <div style={{ flex: 1, minWidth: '200px', padding: '20px', background: 'rgba(255,255,255,0.05)', borderRadius: '10px', textAlign: 'center' }}>
                  <h4 style={{ margin: '0 0 10px 0' }}>{t.json.exportTitle}</h4>
                  <button className="primary-button" style={{ width: '100%' }} onClick={onExport}>
                    {t.json.exportBtn}
                  </button>
                </div>

                <div style={{ flex: 1, minWidth: '200px', padding: '20px', background: 'rgba(255,255,255,0.05)', borderRadius: '10px', textAlign: 'center' }}>
                  <h4 style={{ margin: '0 0 10px 0' }}>{t.json.importTitle}</h4>
                  {error && <div style={{ color: '#ff6b6b', marginBottom: '10px' }}>{error}</div>}
                  <button className="secondary-button" style={{ width: '100%' }} onClick={() => fileInputRef.current?.click()}>
                    {t.json.importBtn}
                  </button>
                  <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    accept=".json"
                    style={{ display: 'none' }}
                  />
                </div>
              </div>
            </div>

            <div className="modal-footer" style={{ marginTop: '20px' }}>
              <button className="secondary-button" onClick={onClose}>{t.common.close}</button>
            </div>
          </div>
        </div>
      );
    };
    const DownloadModal = ({ isOpen, onClose, t, cardRef, cardName, isGifSupported, isFlipped }) => {
      const [gifStatus, setGifStatus] = useState(null);

      if (!isOpen) return null;

      // Get the correct element to capture based on flip state
      const getTargetElement = () => {
        if (!cardRef.current) return null;
        return isFlipped
          ? cardRef.current.querySelector('.game-card-back')
          : cardRef.current.querySelector('.game-card');
      };

      const handleGifDownload = async () => {
        if (gifStatus) return;
        try {
          setGifStatus(t.download.capturing);
          await downloadAsGIF(
            getTargetElement(),
            cardName + (isFlipped ? '_back' : ''),
            3000,
            10,
            t,
            (text) => setGifStatus(text)
          );
          onClose();
          setGifStatus(null);
        } catch (err) {
          setGifStatus(null);
        }
      };

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '600px' }}>
            <div className="modal-header">
              <h3>{t.download.title}</h3>
            </div>
            <div className="modal-body">
              {/* Indicateur clair de la face s√©lectionn√©e */}
              <div style={{
                background: isFlipped ? 'rgba(139, 92, 246, 0.15)' : 'rgba(59, 130, 246, 0.15)',
                border: `1px solid ${isFlipped ? 'rgba(139, 92, 246, 0.3)' : 'rgba(59, 130, 246, 0.3)'}`,
                borderRadius: '10px',
                padding: '12px 16px',
                marginBottom: '16px',
                display: 'flex',
                alignItems: 'center',
                gap: '12px'
              }}>
                <span style={{ fontSize: '24px' }}>{isFlipped ? 'üîô' : 'üé¥'}</span>
                <div>
                  <div style={{ fontWeight: '600', fontSize: '14px', color: isFlipped ? '#a78bfa' : '#60a5fa' }}>
                    {isFlipped ? (t.download?.backSide || 'Back Side') : (t.download?.frontSide || 'Front Side')}
                  </div>
                  <div style={{ fontSize: '12px', opacity: 0.7 }}>
                    {isFlipped
                      ? (t.download?.backHint || 'Flip the card to download the front side')
                      : (t.download?.frontHint || 'Flip the card to download the back side')
                    }
                  </div>
                </div>
              </div>

              <div className="download-options-grid">
                <button
                  className="download-option-card"
                  onClick={() => { downloadAsPNG(getTargetElement(), cardName + (isFlipped ? '_back' : '')); onClose(); }}
                >
                  <div className="option-icon">üñºÔ∏è</div>
                  <div className="option-info">
                    <span className="option-title">PNG</span>
                    <span className="option-desc">{t.download.pngDesc}</span>
                  </div>
                </button>
                <button
                  className="download-option-card"
                  onClick={() => { downloadAsJPG(getTargetElement(), cardName + (isFlipped ? '_back' : '')); onClose(); }}
                >
                  <div className="option-icon">üì∑</div>
                  <div className="option-info">
                    <span className="option-title">JPG</span>
                    <span className="option-desc">{t.download.jpgDesc}</span>
                  </div>
                </button>
                <button
                  className="download-option-card"
                  onClick={() => { downloadAsWebP(getTargetElement(), cardName + (isFlipped ? '_back' : '')); onClose(); }}
                >
                  <div className="option-icon">üåê</div>
                  <div className="option-info">
                    <span className="option-title">WebP</span>
                    <span className="option-desc">{t.download.webpDesc}</span>
                  </div>
                </button>
                {isGifSupported && (
                  <button
                    className="download-option-card"
                    onClick={handleGifDownload}
                    disabled={!!gifStatus}
                  >
                    <div className="option-icon">üé¨</div>
                    <div className="option-info">
                      <span className="option-title">GIF</span>
                      <span className="option-desc">{gifStatus || t.download.gifDesc}</span>
                    </div>
                  </button>
                )}
              </div>
            </div>
            <div className="modal-footer" style={{ marginTop: '20px' }}>
              <button className="secondary-button" onClick={onClose}>{t.common.close}</button>
            </div>
          </div>
        </div>
      );
    };

    const ConfirmModal = ({ isOpen, onClose, onConfirm, title, message, t }) => {
      if (!isOpen) return null;
      return (
        <div className="modal-overlay" onClick={onClose} style={{ zIndex: 11000 }}>
          <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '400px' }}>
            <div className="modal-header">
              <h3 style={{ color: '#f44336' }}>‚ö†Ô∏è {title}</h3>
            </div>
            <div className="modal-body">
              <p>{message}</p>
            </div>
            <div className="modal-footer">
              <button className="secondary-button" onClick={onClose}>{t.common.cancel}</button>
              <button className="primary-button" style={{ background: '#f44336' }} onClick={onConfirm}>{t.buttons.remove || 'Confirm'}</button>
            </div>
          </div>
        </div>
      );
    };

    const InputGroup = React.memo(({
      id, label, type = 'text', value, onChange, min, max, step, maxLength, rows, options, style, className = '', disabled = false,
    }) => {
      const inputId = `input-${id}`;
      const handleChange = useCallback((e) => {
        onChange(e.target.value)
      }, [onChange]);
      const renderInput = () => {
        const commonProps = { id: inputId, value, onChange: handleChange, disabled };
        if (options) {
          return (<select {...commonProps}>
            {options.map(opt => (<option key={opt.value} value={opt.value}>
              {opt.label}
            </option>))}
          </select>)
        }
        if (rows) {
          return (<textarea
            {...commonProps}
            rows={rows}
            maxLength={maxLength}
            style={{ resize: 'none' }}
          />)
        }
        if (type === 'color') {
          const isHex = /^#[0-9A-Fa-f]{6}$/.test(value);
          const colorInputValue = isHex ? value : '#000000';
          return (<div className="color-input-wrapper"><input
            {...commonProps}
            value={colorInputValue}
            type="color"
            className="color-input"
          /><input
              type="text"
              value={value}
              onChange={handleChange}
              placeholder="#RRGGBB"
              className="color-text-input"
              maxLength={7}
            /></div>)
        }
        return (<input
          {...commonProps}
          type={type}
          min={min}
          max={max}
          step={step}
          maxLength={maxLength}
        />)
      };
      return (<div className={`input-group ${className}`} style={style}><label htmlFor={inputId}>{label}</label>
        {renderInput()}
      </div>)
    });
    InputGroup.displayName = 'InputGroup';
    const Checkbox = React.memo(({ id, label, checked, onChange }) => {
      const inputId = `checkbox-${id}`;
      return (<div className="checkbox-group"><input
        type="checkbox"
        id={inputId}
        checked={checked}
        onChange={(e) => onChange(e.target.checked)}
      /><label htmlFor={inputId}>{label}</label></div>)
    });
    Checkbox.displayName = 'Checkbox';
    const EmojiInput = React.memo(({ label, value, onChange }) => {
      const { t } = useLanguage();
      const [isOpen, setIsOpen] = useState(false);
      const wrapperRef = useRef(null);
      const pickerRef = useRef(null);

      useEffect(() => {
        const handleClickOutside = (event) => {
          if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
            setIsOpen(false);
          }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, []);

      useEffect(() => {
        if (isOpen && pickerRef.current) {
          const picker = pickerRef.current;
          const handleEmojiClick = (event) => {
            onChange(event.detail.unicode);
            setIsOpen(false);
          };
          picker.addEventListener('emoji-click', handleEmojiClick);
          return () => picker.removeEventListener('emoji-click', handleEmojiClick);
        }
      }, [isOpen, onChange]);

      return (
        <div className="input-group" ref={wrapperRef}>
          <label>{label}</label>
          <div className="emoji-input-wrapper" style={{ position: 'relative' }}>
            <button
              type="button"
              className="emoji-btn"
              onClick={() => setIsOpen(!isOpen)}
              style={{
                width: '100%',
                padding: '8px',
                textAlign: 'left',
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '6px',
                color: '#fff',
                cursor: 'pointer',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                height: '42px'
              }}
            >
              <span style={{ fontSize: '1.2em' }}>{value || '‚ùì'}</span>
              <span style={{ fontSize: '0.8em', opacity: 0.7 }}>‚ñº</span>
            </button>
            {isOpen && (
              <div className="emoji-picker-wrapper">
                <emoji-picker ref={pickerRef} class="dark"></emoji-picker>
              </div>
            )}
          </div>
        </div>
      );
    });
    EmojiInput.displayName = 'EmojiInput';
    const AttackInfoEditor = React.memo(({
      index, attack, typeIcon, onUpdate, onRemove, canRemove, t,
    }) => {
      const handleChange = useCallback((field, value) => {
        onUpdate(index, { ...attack, [field]: value })
      }, [index, attack, onUpdate]);
      const handleNumericChange = useCallback((field, value, min, max) => {
        const parsed = parseIntSafe(value, min);
        handleChange(field, clamp(parsed, min, max))
      }, [handleChange]);
      return (<div className="attack-editor"><div className="attack-header-edit"><h3 className="attack-title">
        {typeIcon} {t.sections.abilities} {index + 1}
      </h3>
        {canRemove && (<button
          type="button"
          className="remove-attack-btn"
          onClick={() => onRemove(index)}
          aria-label={t.buttons.remove}
        >
          ‚úï
        </button>)}
      </div>
        <div className="attack-grid"><InputGroup
          id={`attack-${attack.id}-name`}
          label={t.labels.abilityName}
          value={attack.name}
          onChange={(v) => handleChange('name', v)}
          maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
        /><InputGroup
            id={`attack-${attack.id}-damage`}
            label={t.labels.damage}
            type="number"
            value={attack.damage}
            onChange={(v) => handleNumericChange('damage', v, CARD_LIMITS.DAMAGE_MIN, CARD_LIMITS.DAMAGE_MAX)}
          /><InputGroup
            id={`attack-${attack.id}-cost`}
            label={t.labels.energyCost}
            type="number"
            value={attack.cost}
            onChange={(v) => handleNumericChange('cost', v, CARD_LIMITS.COST_MIN, CARD_LIMITS.COST_MAX)}
            min={CARD_LIMITS.COST_MIN}
            max={CARD_LIMITS.COST_MAX}
          /></div><InputGroup
          id={`attack-${attack.id}-desc`}
          label={t.labels.abilityDesc}
          value={attack.desc}
          onChange={(v) => handleChange('desc', v)}
          maxLength={CARD_LIMITS.ATTACK_DESC_MAX_LENGTH}
        /><Checkbox
          id={`attack-${attack.id}-show-damage`}
          label={t.checkboxes.showDamage || 'Afficher les d√©g√¢ts'}
          checked={attack.showDamage !== false}
          onChange={(v) => handleChange('showDamage', v)}
        />
      </div>)
    });
    AttackInfoEditor.displayName = 'AttackInfoEditor';

    const AttackStyleEditor = React.memo(({
      index, attack, typeIcon, onUpdate, t,
    }) => {
      const handleChange = useCallback((field, value) => {
        onUpdate(index, { ...attack, [field]: value })
      }, [index, attack, onUpdate]);
      return (<div className="attack-editor" style={{ marginBottom: '12px', padding: '12px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px' }}>
        <div className="attack-header-edit" style={{ marginBottom: '8px' }}>
          <h3 className="attack-title" style={{ fontSize: '14px', opacity: 0.8 }}>
            {typeIcon} {attack.name || `${t.sections.abilities} ${index + 1}`}
          </h3>
        </div>
        <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.backgroundStyle || "Background Style"}</label>
        <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
          <button
            className={`mode-toggle-btn ${attack.colorMode === 'solid' ? 'active' : ''}`}
            onClick={() => handleChange('colorMode', 'solid')}
          >
            {t.labels.solid || "Solid"}
          </button>
          <button
            className={`mode-toggle-btn ${attack.colorMode !== 'solid' ? 'active' : ''}`}
            onClick={() => handleChange('colorMode', 'gradient')}
          >
            {t.labels.gradient || "Gradient"}
          </button>
        </div>
        <div style={{ display: 'grid', gridTemplateColumns: attack.colorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px', minHeight: '74px' }}>
          <InputGroup
            id={`attack-${attack.id}-bg`}
            label={attack.colorMode === 'solid' ? (t.labels.backgroundColor || "Background") : (t.labels.primaryColor || "Primary")}
            type="color"
            value={attack.background || 'rgba(255, 255, 255, 0.7)'}
            onChange={(v) => handleChange('background', v)}
          />
          {attack.colorMode !== 'solid' && (
            <InputGroup
              id={`attack-${attack.id}-sec-bg`}
              label={t.labels.secondaryColor || "Secondary"}
              type="color"
              value={attack.secondaryBackground || '#ffffff'}
              onChange={(v) => handleChange('secondaryBackground', v)}
            />
          )}
        </div>
      </div>)
    });
    AttackStyleEditor.displayName = 'AttackStyleEditor';


    const ImageEditor = React.memo(({
      image, settings, onSettingsChange, isLoading, error, onUpload, onClear, t,
    }) => {
      const fileInputRef = useRef(null);
      const containerRef = useRef(null);
      const [isDragging, setIsDragging] = useState(false);
      const [isPanning, setIsPanning] = useState(false);
      const dragStart = useRef({ x: 0, y: 0 });
      const uniqueId = useMemo(() => `zoom-${Math.random().toString(36).substr(2, 9)}`, []);

      const handleFileChange = useCallback((e) => {
        const file = e.target.files?.[0];
        if (file) onUpload(file);
        e.target.value = ''
      }, [onUpload]);
      const handleClick = useCallback(() => {
        if (!image) fileInputRef.current?.click()
      }, [image]);
      const handleDragOver = useCallback((e) => {
        e.preventDefault();
        setIsDragging(true)
      }, []);
      const handleDragLeave = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false)
      }, []);
      const handleDrop = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false);
        const file = e.dataTransfer.files?.[0];
        if (file) onUpload(file)
      }, [onUpload]);
      const handleZoomChange = useCallback((value) => {
        const zoom = parseFloatSafe(value, 1);
        const clampedZoom = clamp(zoom, 1, 3);
        const maxOffset = clampedZoom * 100;
        onSettingsChange({
          ...settings, zoom: clampedZoom, offsetX: clamp(settings.offsetX, -maxOffset, maxOffset), offsetY: clamp(settings.offsetY, -maxOffset, maxOffset)
        })
      }, [settings, onSettingsChange]);
      const handlePanStart = useCallback((e) => {
        e.preventDefault();
        setIsPanning(true);
        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
        dragStart.current = { x: clientX - settings.offsetX, y: clientY - settings.offsetY }
      }, [settings]);
      const handlePanMove = useCallback((e) => {
        if (!isPanning) return;
        e.preventDefault();
        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
        const newX = clientX - dragStart.current.x;
        const newY = clientY - dragStart.current.y;
        const maxOffset = settings.zoom * 100;
        onSettingsChange({ ...settings, offsetX: clamp(newX, -maxOffset, maxOffset), offsetY: clamp(newY, -maxOffset, maxOffset) })
      }, [isPanning, settings, onSettingsChange]);
      const handlePanEnd = useCallback(() => {
        setIsPanning(false)
      }, []);
      const handleReset = useCallback(() => {
        onSettingsChange(INITIAL_IMAGE_SETTINGS)
      }, [onSettingsChange]);
      return (<div className="image-editor-container"><div className="image-editor-header">
        {image && (<div className="image-actions"><button type="button" onClick={() => fileInputRef.current?.click()} className="small-btn">
          {t.buttons.change}
        </button><button type="button" onClick={handleReset} className="small-btn">
            {t.buttons.recenter}
          </button><button type="button" onClick={onClear} className="small-btn danger">
            {t.buttons.remove}
          </button></div>)}
      </div><div
        ref={containerRef}
        className={`image-preview-container ${isDragging ? 'dragging' : ''} ${error ? 'error' : ''} ${image ? 'has-image' : ''}`}
        onClick={handleClick}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onMouseDown={image ? handlePanStart : undefined}
        onMouseMove={image ? handlePanMove : undefined}
        onMouseUp={handlePanEnd}
        onMouseLeave={handlePanEnd}
        onTouchStart={image ? handlePanStart : undefined}
        onTouchMove={image ? handlePanMove : undefined}
        onTouchEnd={handlePanEnd}
        role={image ? "application" : "button"}
        tabIndex={0}
        aria-label={t.imageEditor.dropHint}
      ><input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            accept="image/png,image/jpeg,image/gif,image/webp"
            style={{ display: 'none' }}
            aria-hidden="true"
          />
          {image ? (<div
            className="image-preview"
            style={{
              backgroundImage: `url(${image})`, backgroundSize: `${settings.zoom * 100}%`, backgroundPosition: `calc(50% + ${settings.offsetX}px) calc(50% + ${settings.offsetY}px)`, backgroundRepeat: 'no-repeat'
            }}
          >
            {isPanning && <div className="pan-overlay">‚Üî</div>}
          </div>) : (<div className="upload-placeholder"><div className="upload-icon">{isLoading ? '‚è≥' : 'üì∑'}</div><div className="upload-text">
            {isLoading ? t.imageEditor.loading : error ? error : t.imageEditor.dropHint}
          </div><div className="upload-hint">{t.imageEditor.formats}</div></div>)}
        </div>
        {image && (<div className="image-controls"><div className="zoom-control"><label htmlFor={uniqueId}>{t.labels.zoom}:{(settings.zoom * 100).toFixed(0)}%</label><input
          id={uniqueId}
          type="range"
          min={1}
          max={3}
          step={0.05}
          value={settings.zoom}
          onChange={(e) => handleZoomChange(e.target.value)}
        /></div></div>)}
      </div>)
    });
    ImageEditor.displayName = 'ImageEditor';

    const Card = React.memo(({
      cardData, attacks, image, imageSettings, cardBackSettings = INITIAL_IMAGE_SETTINGS, mousePos, isHovering, cardRef, onMouseMove, onMouseEnter, onMouseLeave, autoRotate, isFlipped, t
    }) => {
      const typeData = ELEMENT_TYPES[cardData.type] || ELEMENT_TYPES.Neutral;
      const weaknessIcon = ELEMENT_TYPES[cardData.weakness]?.icon || cardData.weakness || '‚ùì';
      const resistanceIcon = ELEMENT_TYPES[cardData.resistance]?.icon || cardData.resistance || '‚ùì';
      const fontData = FONTS.find(f => f.id === cardData.font) || FONTS[0];
      const borderColor = cardData.borderColor || '#ffd700';
      const textColor = cardData.textColor || '#1a1a2e';

      // Use custom icon if available, otherwise fallback to type icon
      const displayIcon = cardData.customIcon || typeData.icon;

      const { containerStyle, flipperStyle } = useMemo(() => {
        const capturing = document.body.classList.contains('is-capturing');
        // Base rotation from mouse position
        const rotY = (mousePos.x - 0.5) * 15;
        const rotX = (0.5 - mousePos.y) * 15;

        // Container handles Tilt (auto or manual)
        const containerTransform = (isHovering && !capturing)
          ? `perspective(1000px) rotateY(${rotY}deg) rotateX(${rotX}deg) scale(1.02)`
          : `perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)`;

        return {
          containerStyle: {
            transform: containerTransform,
            transition: autoRotate ? 'none' : 'transform 0.2s ease-out'
          },
          flipperStyle: {
            transform: `rotateY(${isFlipped ? 180 : 0}deg)`,
            transition: 'transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1)',
            transformStyle: 'preserve-3d',
            width: '100%',
            height: '100%',
            position: 'relative'
          }
        }
      }, [isHovering, mousePos.x, mousePos.y, autoRotate, isFlipped]);



      const imageStyle = useMemo(() => {
        const primary = cardData.primaryColor || typeData.primary;
        const baseStyle = { borderColor: primary };
        if (image) {
          return {
            ...baseStyle, backgroundImage: `url(${image})`, backgroundSize: `${imageSettings.zoom * 100}%`, backgroundPosition: `calc(50% + ${imageSettings.offsetX}px) calc(50% + ${imageSettings.offsetY}px)`, backgroundRepeat: 'no-repeat'
          }
        }
        const secondary = cardData.secondaryColor || typeData.secondary;
        return {
          ...baseStyle, background: `linear-gradient(135deg, ${primary}40, ${secondary}40)`
        }
      }, [image, imageSettings, typeData.primary, typeData.secondary, cardData.primaryColor, cardData.secondaryColor]);

      const cardGradient = useMemo(() => {
        // If manual background color is set (from Appearance tab), use it
        if (cardData.backgroundColor) {
          return cardData.backgroundColor;
        }
        // Otherwise use the Card Style settings
        const primary = cardData.primaryColor || typeData.primary;
        const secondary = cardData.secondaryColor || typeData.secondary;

        if (cardData.colorMode === 'solid') {
          return primary;
        }
        return `linear-gradient(135deg, ${primary} 0%, ${secondary} 50%, ${primary} 100%)`;
      }, [cardData.backgroundColor, cardData.colorMode, cardData.primaryColor, cardData.secondaryColor, typeData.primary, typeData.secondary]);

      // Particle settings
      const particleEmoji = cardData.particleEmoji || ELEMENT_PARTICLES[cardData.type]?.emoji || '‚ú®';
      const particleCount = ELEMENT_PARTICLES[cardData.type]?.count || 6;
      const particleAnim = cardData.particleAnimation || 'float';

      return (<div
        ref={cardRef}
        className="card-container"
        style={containerStyle}
        onMouseMove={onMouseMove}
        onMouseEnter={onMouseEnter}
        onMouseLeave={onMouseLeave}
      >
        <div className="card-flipper" style={flipperStyle}>
          <div
            className="game-card"
            style={{
              background: cardGradient, borderColor: borderColor, fontFamily: fontData.family,
            }}
          >
            {/* Texture Layer */}
            {cardData.texture && cardData.texture !== 'none' && (
              <div className="texture-layer" style={{
                WebkitMaskImage: CARD_TEXTURES[cardData.texture],
                maskImage: CARD_TEXTURES[cardData.texture],
                backgroundColor: cardData.textureColor || '#000000'
              }}></div>
            )}

            {/* Inner card frame */}
            <div className="card-inner" style={{
              color: textColor,
              backgroundImage: cardData.cardInnerColorMode === 'gradient'
                ? `linear-gradient(180deg, ${cardData.cardInnerBackground}, ${cardData.cardInnerSecondaryBackground})`
                : 'none',
              backgroundColor: cardData.cardInnerColorMode === 'gradient' ? 'transparent' : cardData.cardInnerBackground
            }}>
              {/* Header */}
              <div className="card-header"><div className="card-header-left"><span className="stage-badge" style={{ background: cardData.primaryColor || typeData.primary, color: cardData.typeColor || 'inherit', fontSize: `${cardData.stageSize}px`, fontWeight: cardData.stageWeight }}>
                {t.stages[STAGES.indexOf(cardData.stage)] || cardData.stage}
              </span><span className="creature-name" style={{ color: cardData.nameColor || 'inherit', fontSize: `${cardData.nameSize}px`, fontWeight: cardData.nameWeight }}>{cardData.name}</span></div>
                {cardData.showHP && (<div className="card-header-right"><span className="hp-value" style={{ color: cardData.hpColor || 'inherit', fontSize: `${cardData.hpSize}px`, fontWeight: cardData.hpWeight }}>{t.card.hp} {cardData.hp}</span><span className="type-icon">{displayIcon}</span></div>)}
              </div>
              {/* Image */}
              <div className="card-image" style={imageStyle}>
                {!image && (<span className="placeholder-icon">{displayIcon}</span>)}
              </div>
              {/* Description bar */}
              {cardData.showDescription && cardData.description && (<div className="card-description" style={{ color: cardData.descColor || 'inherit', fontSize: `${cardData.descSize}px`, fontWeight: cardData.descWeight, lineHeight: cardData.descHeight || 1.3 }}>{cardData.description}</div>)}
              {/* Attacks */}
              <div className="attacks-container">
                {attacks.map((attack) => (
                  <div key={attack.id} className="attack-card" style={{
                    backgroundImage: attack.colorMode === 'gradient'
                      ? `linear-gradient(180deg, ${attack.background}, ${attack.secondaryBackground})`
                      : 'none',
                    backgroundColor: attack.colorMode === 'gradient' ? 'transparent' : (attack.background || cardData.abilityBackground),
                    backgroundRepeat: 'no-repeat',
                    backgroundPosition: 'top center',
                    backgroundSize: '100% 102%'
                  }}><div className="attack-header"><div className="attack-cost">
                    {[...Array(Math.max(0, Math.min(10, attack.cost)))].map((_, i) => (<span key={i} className="energy-icon">{displayIcon}</span>))}
                  </div><span className="attack-name" style={{ color: cardData.moveNameColor || cardData.descColor || 'inherit', fontSize: `${cardData.moveNameSize}px`, fontWeight: cardData.moveNameWeight }}>{attack.name}</span>{attack.showDamage !== false && <span className="attack-damage" style={{ color: cardData.moveNameColor || cardData.descColor || 'inherit', fontSize: `${Number(cardData.moveNameSize) + 2}px`, fontWeight: cardData.moveNameWeight }}>{attack.damage}</span>}</div>
                    {attack.desc && <div className="attack-desc" style={{ color: cardData.moveDescColor || cardData.descColor || 'inherit', fontSize: `${cardData.moveDescSize}px`, fontWeight: cardData.moveDescWeight }}>{attack.desc}</div>}
                  </div>))}
              </div>
              {/* Footer */}
              <div className="card-footer" style={{ '--stats-color': cardData.statsColor || undefined, color: cardData.statsColor || 'inherit', fontSize: `${cardData.statsSize}px`, fontWeight: cardData.statsWeight }}>
                {cardData.showWeakRes && (<div className="footer-stats"><div className="stat"><span className="stat-label">{t.card.weakness} </span><span className="stat-icon">{weaknessIcon}</span><span className="stat-value weakness"> √ó2</span></div><div className="stat"><span className="stat-label">{t.card.resistance} </span><span className="stat-icon">{resistanceIcon}</span><span className="stat-value resistance"> -30</span></div></div>)}
                {cardData.showRetreat && (<div className="retreat-cost"><span className="stat-label">{t.card.cost} </span>
                  {[...Array(Math.max(0, cardData.retreatCost))].map((_, i) => (<span key={i} className="retreat-icon">‚ö™</span>))}
                </div>)}
              </div>
              {/* Author */}
              <div className="card-author" style={{ color: cardData.authorColor || 'inherit', fontSize: `${cardData.authorSize}px`, fontWeight: cardData.authorWeight }}>
                {t.card.illus} {cardData.author} ‚Ä¢ Card Creator
              </div></div>

            {/* Particles layer */}
            {cardData.showParticles && (<div className={`particles-layer particles-${particleAnim}`}>
              {[...Array(particleCount)].map((_, i) => (<span
                key={i}
                className={`particle particle-${i % 3}`}
                style={{
                  left: `${3 + (i * 31) % 94}%`,
                  top: `${2 + (i * 37) % 96}%`,
                  animationDelay: `${i * 0.5}s`,
                  fontSize: `${10 + (i * 5) % 15}px`,
                  position: 'absolute'
                }}
              >
                {particleEmoji}
              </span>))}
            </div>)}

          </div>
          <div className="game-card-back" style={{
            backgroundImage: cardData.cardBack
              ? `url(${cardData.cardBack})`
              : (() => {
                const primary = cardData.cardBackPrimaryColor || cardData.primaryColor || typeData.primary;
                const secondary = cardData.cardBackSecondaryColor || cardData.secondaryColor || typeData.secondary;
                const gradientType = cardData.cardBackGradientType || 'radial';
                const angle = cardData.cardBackGradientAngle || 135;

                if (gradientType === 'solid') {
                  return 'none';
                } else if (gradientType === 'linear') {
                  return `linear-gradient(${angle}deg, ${primary} 0%, ${secondary} 50%, ${primary} 100%)`;
                } else {
                  return `radial-gradient(ellipse at 30% 20%, ${primary}90 0%, transparent 50%), 
                            radial-gradient(ellipse at 70% 80%, ${secondary}80 0%, transparent 50%),
                            linear-gradient(135deg, ${primary} 0%, ${secondary} 50%, ${primary} 100%)`;
                }
              })(),
            backgroundColor: cardData.cardBack ? 'transparent' : (cardData.cardBackGradientType === 'solid' ? (cardData.cardBackPrimaryColor || cardData.primaryColor || typeData.primary) : 'transparent'),
            backgroundSize: cardData.cardBack ? `${cardBackSettings.zoom * 100}%` : 'cover',
            backgroundPosition: cardData.cardBack ? `calc(50% + ${cardBackSettings.offsetX}px) calc(50% + ${cardBackSettings.offsetY}px)` : 'center',
            backgroundRepeat: 'no-repeat',
            border: cardData.cardBackShowBorder !== false ? `5px solid ${borderColor}` : 'none'
          }}>
            {!cardData.cardBack && (
              <>
                {/* Texture overlay */}
                {cardData.cardBackTexture && cardData.cardBackTexture !== 'none' && (
                  <div style={{
                    position: 'absolute',
                    inset: 0,
                    WebkitMaskImage: CARD_TEXTURES[cardData.cardBackTexture],
                    maskImage: CARD_TEXTURES[cardData.cardBackTexture],
                    backgroundColor: (cardData.cardBackTextureColor || '#000000') + '30',
                    pointerEvents: 'none'
                  }}></div>
                )}
                {/* Decorative frame */}
                {cardData.cardBackShowFrame !== false && (
                  <>
                    <div style={{
                      position: 'absolute',
                      inset: '12px',
                      border: '2px solid rgba(255,255,255,0.3)',
                      borderRadius: '12px',
                      pointerEvents: 'none'
                    }}></div>
                    <div style={{
                      position: 'absolute',
                      inset: '20px',
                      border: '1px solid rgba(255,255,255,0.15)',
                      borderRadius: '8px',
                      pointerEvents: 'none'
                    }}></div>
                  </>
                )}
                {/* Center icon */}
                {cardData.cardBackShowCenterIcon !== false && (
                  <div style={{
                    fontSize: '64px',
                    opacity: 0.4,
                    textShadow: '0 4px 20px rgba(0,0,0,0.3)',
                    transform: 'rotate(-15deg)'
                  }}>
                    {displayIcon}
                  </div>
                )}
                {/* Corner decorations */}
                {cardData.cardBackShowCornerIcons !== false && (
                  <>
                    <div style={{ position: 'absolute', top: '30px', left: '30px', fontSize: '20px', opacity: 0.3 }}>{displayIcon}</div>
                    <div style={{ position: 'absolute', top: '30px', right: '30px', fontSize: '20px', opacity: 0.3, transform: 'scaleX(-1)' }}>{displayIcon}</div>
                    <div style={{ position: 'absolute', bottom: '30px', left: '30px', fontSize: '20px', opacity: 0.3, transform: 'rotate(180deg)' }}>{displayIcon}</div>
                    <div style={{ position: 'absolute', bottom: '30px', right: '30px', fontSize: '20px', opacity: 0.3, transform: 'rotate(180deg) scaleX(-1)' }}>{displayIcon}</div>
                  </>
                )}
              </>
            )}
          </div>
        </div>
      </div >)
    });

    Card.displayName = 'Card';
    const CollapsibleSection = React.memo(({ title, icon, children, defaultOpen = true, isOpen: controlledIsOpen, onToggle }) => {
      const [internalIsOpen, setInternalIsOpen] = useState(defaultOpen);
      const isControlled = controlledIsOpen !== undefined;
      const isOpen = isControlled ? controlledIsOpen : internalIsOpen;

      const handleToggle = () => {
        if (isControlled) {
          onToggle && onToggle();
        } else {
          setInternalIsOpen(!internalIsOpen);
        }
      };

      return (<div className={`collapsible-section ${isOpen ? 'open' : ''}`}><button
        type="button"
        className="collapsible-header"
        onClick={handleToggle}
        aria-expanded={isOpen}
      ><span>{icon} {title}</span><span className="collapse-icon">{isOpen ? '‚ñº' : '‚ñ∂'}</span></button>
        {isOpen && <div className="collapsible-content">{children}</div>}
      </div>)
    });
    CollapsibleSection.displayName = 'CollapsibleSection';

    const TextSettingsGroup = React.memo(({ label, colorKey, sizeKey, weightKey, cardData, updateCardData, t, showColor = true }) => {
      const [isOpen, setIsOpen] = useState(false);
      const currentColor = cardData[colorKey] || cardData.textColor || '#1a1a2e';

      return (
        <div className="text-settings-group" style={{ marginBottom: '8px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px', overflow: 'hidden' }}>
          <button
            type="button"
            onClick={() => setIsOpen(!isOpen)}
            style={{
              width: '100%',
              padding: '10px 12px',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              background: 'none',
              border: 'none',
              color: 'white',
              cursor: 'pointer',
              textAlign: 'left'
            }}
          >
            <span style={{ fontSize: '13px', fontWeight: 600, opacity: 0.9 }}>{label}</span>
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>

              <span style={{ fontSize: '10px', opacity: 0.5, transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>‚ñº</span>
            </div>
          </button>

          {isOpen && (
            <div style={{ padding: '12px', paddingTop: '0' }}>
              <div style={{ display: 'grid', gap: '12px' }}>
                {showColor && (
                  <InputGroup
                    id={`${colorKey}-input`}
                    label={t.labels.textColor}
                    type="color"
                    value={currentColor}
                    onChange={(v) => updateCardData(colorKey, v)}
                  />
                )}
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                  {sizeKey && (
                    <InputGroup
                      id={`${sizeKey}-input`}
                      label={t.labels.size}
                      type="number"
                      value={cardData[sizeKey]}
                      onChange={(v) => updateCardData(sizeKey, Number(v))}
                    />
                  )}
                  {weightKey && (
                    <div className="input-group">
                      <label htmlFor={`${weightKey}-input`}>{t.labels.weight}</label>
                      <select
                        id={`${weightKey}-input`}
                        value={cardData[weightKey]}
                        onChange={(e) => updateCardData(weightKey, e.target.value)}
                        style={{ width: '100%' }}
                      >
                        <option value="400">{t.fontWeights?.normal || 'Normal'}</option>
                        <option value="700">{t.fontWeights?.bold || 'Bold'}</option>
                        <option value="900">{t.fontWeights?.black || 'Black'}</option>
                      </select>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      );
    });

    function CardCreatorContent() {
      const { lang, setLang, t, isGifSupported } = useContext(LanguageContext);
      const { notify } = useNotification();
      const [cardData, setCardData] = useState(() => getInitialCardData(t));
      const [attacks, setAttacks] = useState(() => getInitialAttacks(t));
      const [image, setImage] = useState(null);
      const [imageSettings, setImageSettings] = useState(INITIAL_IMAGE_SETTINGS);
      const [cardBackSettings, setCardBackSettings] = useState(INITIAL_IMAGE_SETTINGS);
      const [imageLoading, setImageLoading] = useState(false);
      const [imageError, setImageError] = useState(null);
      const [backImageLoading, setBackImageLoading] = useState(false);
      const [backImageError, setBackImageError] = useState(null);
      const [mousePos, setMousePos] = useState({ x: 0.5, y: 0.5 });
      const [isHovering, setIsHovering] = useState(false);
      const [autoRotate, setAutoRotate] = useState(true);
      const [activeTab, setActiveTab] = useState('visual');
      const [openSection, setOpenSection] = useState('image'); // Default open section for visual tab
      const [showResetConfirm, setShowResetConfirm] = useState(false);
      const [isFlipped, setIsFlipped] = useState(false);

      // Save/Load State
      const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
      const [isLoadModalOpen, setIsLoadModalOpen] = useState(false);
      const [isJsonModalOpen, setIsJsonModalOpen] = useState(false);
      const [isDownloadModalOpen, setIsDownloadModalOpen] = useState(false);
      const [isDeckBuilderOpen, setIsDeckBuilderOpen] = useState(false);
      const [savedCards, setSavedCards] = useState([]);

      // Confirm Modal State
      const [confirmState, setConfirmState] = useState({ isOpen: false, title: '', message: '', onConfirm: null });
      const openConfirm = (title, message, onConfirm) => {
        setConfirmState({ isOpen: true, title, message, onConfirm });
      };

      const openDeckBuilder = async () => {
        try {
          await db.cleanupOld(30);
          const cards = await db.getAll();
          setSavedCards(cards);
          setIsDeckBuilderOpen(true);
        } catch (err) {
          notify(t.deckBuilder?.errorLoad || "Could not load library", 'error');
        }
      };

      const openLoadModal = async () => {
        try {
          // Auto-delete cards older than 30 days
          await db.cleanupOld(30);
          const cards = await db.getAll();
          setSavedCards(cards);
          setIsLoadModalOpen(true);
        } catch (err) {
          console.error('Error loading cards:', err);
          notify(t.prompts.saveError || 'Could not load cards', 'error');
        }
      };

      const handleSaveCard = async (saveName) => {
        try {
          // Helper function to capture using isolation strategy
          const captureSide = async (selector, isBack = false) => {
            const original = document.querySelector(selector);
            if (!original) return null;

            const clone = original.cloneNode(true);
            const container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.top = '-9999px';
            container.style.left = '-9999px';
            container.style.width = '320px';
            container.style.height = '448px';
            container.style.zIndex = '-9999';
            container.style.transform = 'none';
            document.body.appendChild(container);

            clone.style.position = 'absolute';
            clone.style.top = '0';
            clone.style.left = '0';
            clone.style.transform = 'none';
            clone.style.transition = 'none';
            clone.style.animation = 'none';
            clone.style.backfaceVisibility = 'visible';
            clone.style.visibility = 'visible';
            clone.style.opacity = '1';
            clone.style.margin = '0';

            if (isBack) {
              clone.style.width = '320px';
              clone.style.height = '448px';
              clone.style.position = 'relative';
              clone.style.transform = 'rotateY(0deg)';
              clone.style.backfaceVisibility = 'visible';
              clone.style.WebkitBackfaceVisibility = 'visible';
            }

            container.appendChild(clone);

            // Remove particles from clone to avoid capturing them mid-animation
            const particles = clone.querySelectorAll('.particles-layer, .particle');
            particles.forEach(p => p.remove());

            try {
              // Short wait for rendering
              await new Promise(resolve => setTimeout(resolve, 100));

              const canvas = await html2canvas(container, {
                scale: 12, // 4K+ quality: 320*12=3840px for max print quality
                backgroundColor: null,
                logging: false,
                useCORS: true,
                allowTaint: true,
                width: 320, // Original card width
                height: 448 // Original card height
              });
              document.body.removeChild(container);
              return canvas.toDataURL('image/png', 1.0); // PNG for lossless quality
            } catch (e) {
              console.error(e);
              if (document.body.contains(container)) document.body.removeChild(container);
              return null;
            }
          };

          // 1. Capture Front
          const thumbnail = await captureSide('.game-card');

          // 2. Capture Back
          const thumbnailBack = await captureSide('.game-card-back', true);

          // No flipping needed


          const newCard = {
            id: crypto.randomUUID(),
            timestamp: Date.now(),
            name: saveName || cardData.name || 'Untitled',
            cardData,
            attacks,
            image: image,
            imageSettings: imageSettings,
            cardBackSettings: cardBackSettings,
            thumbnail: thumbnail,
            thumbnailBack: thumbnailBack
          };

          await db.save(newCard);
          setIsSaveModalOpen(false);

          notify(t.prompts.saveSuccess || 'Card saved successfully!', 'success');
        } catch (err) {
          console.error('Save failed:', err);
          if (err.name === 'QuotaExceededError') {
            notify(t.prompts.quotaError || 'Storage full!', 'error');
          } else {
            notify(t.notifications?.saveError || 'Error saving card.', 'error');
          }
        }
      };

      const handleLoadCard = (savedCard) => {
        // Sanitize loaded card data for security
        const sanitizedCardData = sanitizeCardData(savedCard.cardData || {});
        setCardData({ ...getInitialCardData(t), ...sanitizedCardData });

        // Sanitize attacks if present
        if (savedCard.attacks && Array.isArray(savedCard.attacks)) {
          setAttacks(savedCard.attacks.map(attack => ({
            ...attack,
            name: sanitize(String(attack.name || '').substring(0, 50)),
            desc: sanitize(String(attack.desc || '').substring(0, 200))
          })));
        } else {
          setAttacks(getInitialAttacks(t));
        }

        // Validate image
        const isValidImage = !savedCard.image || (typeof savedCard.image === 'string' && savedCard.image.startsWith('data:image/'));
        setImage(isValidImage ? savedCard.image : null);

        setImageSettings(savedCard.imageSettings || INITIAL_IMAGE_SETTINGS);
        setCardBackSettings(savedCard.cardBackSettings || INITIAL_IMAGE_SETTINGS);
        setIsLoadModalOpen(false);
        notify(t.notifications?.cardLoaded || 'Card loaded!', 'success');
      };

      const handleExportJSON = () => {
        try {
          const exportData = {
            version: '1.0',
            timestamp: Date.now(),
            cardData,
            attacks,
            image,
            imageSettings,
            cardBackSettings
          };
          const jsonString = JSON.stringify(exportData, null, 2);
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `${(cardData.name || 'card').replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          // notify(t.notifications?.success || 'Exported!', 'success');
        } catch (err) {
          console.error('Export error:', err);
          notify(t.notifications?.error || 'Export failed', 'error');
        }
      };

      const handleImportJSON = (data) => {
        if (!data || !data.cardData) {
          notify(t.json.errorImport, 'error');
          return;
        }
        try {
          // Sanitize imported card data to prevent XSS/CSS injection
          const sanitizedCardData = sanitizeCardData(data.cardData);
          setCardData({ ...getInitialCardData(t), ...sanitizedCardData });

          // Sanitize attacks
          if (data.attacks && Array.isArray(data.attacks)) {
            const sanitizedAttacks = data.attacks.map(attack => ({
              ...attack,
              id: attack.id || generateId(),
              name: sanitize(String(attack.name || '').substring(0, 50)),
              desc: sanitize(String(attack.desc || '').substring(0, 200)),
              damage: typeof attack.damage === 'number' ? Math.min(Math.max(attack.damage, 0), 9999) : 0,
              cost: typeof attack.cost === 'number' ? Math.min(Math.max(attack.cost, 0), 10) : 0,
              background: isValidColor(attack.background) ? attack.background : '',
              secondaryBackground: isValidColor(attack.secondaryBackground) ? attack.secondaryBackground : ''
            }));
            setAttacks(sanitizedAttacks);
          }

          // Validate image (must be a data URL or empty)
          if (data.image !== undefined) {
            const isValidImage = !data.image || (typeof data.image === 'string' && data.image.startsWith('data:image/'));
            setImage(isValidImage ? data.image : null);
          }

          if (data.imageSettings) setImageSettings(data.imageSettings);
          if (data.cardBackSettings) setCardBackSettings(data.cardBackSettings);

          notify(t.json.successImport, 'success');
        } catch (err) {
          console.error('Import logic error:', err);
          notify(t.notifications?.error || 'Import failed', 'error');
        }
      };

      const handleDeleteCard = async (id) => {
        openConfirm(
          t.buttons.remove,
          t.prompts.deleteConfirm || "Delete this saved card?",
          async () => {
            try {
              await db.delete(id);
              const cards = await db.getAll();
              setSavedCards(cards);
              setConfirmState(prev => ({ ...prev, isOpen: false }));
              notify(t.notifications?.cardDeleted || 'Card deleted', 'info');
            } catch (err) {
              console.error(err);
              notify(t.notifications?.deleteError || 'Failed to delete card', 'error');
            }
          }
        );
      };

      const handleDeleteAllCards = () => {
        openConfirm(
          t.buttons.deleteAll || 'Delete All',
          t.prompts.deleteAllConfirm || 'Delete all saved cards? This cannot be undone.',
          async () => {
            try {
              await db.deleteAll();
              setSavedCards([]);
              setConfirmState(prev => ({ ...prev, isOpen: false }));
              notify(t.notifications?.allDeleted || 'All cards deleted', 'info');
            } catch (err) {
              console.error(err);
              notify(t.notifications?.deleteError || 'Failed to delete cards', 'error');
            }
          }
        );
      };
      const cardRef = useRef(null);
      const autoRotateRef = useRef(null);
      useEffect(() => {
        const modal = document.getElementById('gif-instructions-modal');
        if (modal && t && t.gifModal) {
          const gm = t.gifModal;
          const titleEl = modal.querySelector('h3');
          if (titleEl) titleEl.textContent = gm.title;

          const bodyEl = modal.querySelector('p');
          if (bodyEl) bodyEl.textContent = gm.body;

          const step1 = modal.querySelector('#gif-modal-step-1');
          if (step1) step1.innerHTML = gm.step1;
          const step2 = modal.querySelector('#gif-modal-step-2');
          if (step2) step2.innerHTML = gm.step2;
          const step3 = modal.querySelector('#gif-modal-step-3');
          if (step3) step3.innerHTML = gm.step3;

          const noteEl = modal.querySelector('.modal-note span:last-child');
          if (noteEl) noteEl.textContent = gm.note;

          const warningEl = modal.querySelector('.modal-warning span:last-child');
          if (warningEl && gm.warning) warningEl.textContent = gm.warning;

          const fpsLabel = modal.querySelector('#gif-fps-label');
          if (fpsLabel && gm.fpsLabel) fpsLabel.textContent = gm.fpsLabel;

          const qualityLabel = modal.querySelector('#gif-quality-label');
          if (qualityLabel && gm.qualityLabel) qualityLabel.textContent = gm.qualityLabel;

          const fpsNormal = modal.querySelector('#gif-fps-normal');
          if (fpsNormal && gm.fpsNormal) fpsNormal.textContent = gm.fpsNormal;
          const fpsCinema = modal.querySelector('#gif-fps-cinema');
          if (fpsCinema && gm.fpsCinema) fpsCinema.textContent = gm.fpsCinema;
          const fpsSmooth = modal.querySelector('#gif-fps-smooth');
          if (fpsSmooth && gm.fpsSmooth) fpsSmooth.textContent = gm.fpsSmooth;
          const fpsUltra = modal.querySelector('#gif-fps-ultra');
          if (fpsUltra && gm.fpsUltra) fpsUltra.textContent = gm.fpsUltra;

          const qualitySD = modal.querySelector('#gif-quality-sd');
          if (qualitySD && gm.qualitySD) qualitySD.textContent = gm.qualitySD;
          const qualityNormal = modal.querySelector('#gif-quality-normal');
          if (qualityNormal && gm.qualityNormal) qualityNormal.textContent = gm.qualityNormal;
          const qualityHigh = modal.querySelector('#gif-quality-high');
          if (qualityHigh && gm.qualityHigh) qualityHigh.textContent = gm.qualityHigh;
          const qualityQHD = modal.querySelector('#gif-quality-qhd');
          if (qualityQHD && gm.qualityQHD) qualityQHD.textContent = gm.qualityQHD;
          const qualityUltra = modal.querySelector('#gif-quality-ultra');
          if (qualityUltra && gm.qualityUltra) qualityUltra.textContent = gm.qualityUltra;

          const cancelBtn = document.getElementById('cancel-gif-btn');
          if (cancelBtn) cancelBtn.textContent = gm.cancel;
          const startBtn = document.getElementById('start-gif-btn');
          if (startBtn) startBtn.textContent = gm.start;
        }
      }, [t]);

      useEffect(() => {
        const capturing = document.body.classList.contains('is-capturing');
        if (autoRotate && !capturing) {
          let angle = 0;
          setIsHovering(true); // Active l'effet 3D
          autoRotateRef.current = setInterval(() => {
            angle += 0.025; // Mouvement plus lent et fluide
            const x = 0.5 + Math.sin(angle) * 0.35;
            const y = 0.5 + Math.sin(angle * 2) * 0.25;
            setMousePos({ x, y })
          }, 40)
        } else {
          if (autoRotateRef.current) {
            clearInterval(autoRotateRef.current);
            autoRotateRef.current = null
          }
          setIsHovering(false);
          setMousePos({ x: 0.5, y: 0.5 })
        }
        return () => {
          if (autoRotateRef.current) {
            clearInterval(autoRotateRef.current)
          }
        }
      }, [autoRotate]);
      const handleMouseEnterManual = useCallback(() => {
        if (document.body.classList.contains('is-capturing')) return;
        if (autoRotate && autoRotateRef.current) {
          clearInterval(autoRotateRef.current);
          autoRotateRef.current = null
        }
        setIsHovering(true)
      }, [autoRotate]);
      const handleMouseLeaveManual = useCallback(() => {
        if (document.body.classList.contains('is-capturing')) return;
        if (autoRotate) {
          let angle = 0;
          autoRotateRef.current = setInterval(() => {
            angle += 0.025;
            const x = 0.5 + Math.sin(angle) * 0.35;
            const y = 0.5 + Math.sin(angle * 2) * 0.25;
            setMousePos({ x, y })
          }, 40);
          setIsHovering(true); // Garder l'effet 3D actif
        } else {
          setIsHovering(false);
          setMousePos({ x: 0.5, y: 0.5 })
        }
      }, [autoRotate]);
      const updateCardData = useCallback((field, value) => {
        setCardData(prev => ({ ...prev, [field]: value }))
      }, []);
      const updateCardDataNumeric = useCallback((field, value, min, max) => {
        const parsed = parseIntSafe(value, min);
        setCardData(prev => ({ ...prev, [field]: clamp(parsed, min, max) }))
      }, []);
      const updateAttack = useCallback((index, newAttack) => {
        setAttacks(prev => prev.map((a, i) => i === index ? newAttack : a))
      }, []);
      const addAttack = useCallback(() => {
        if (attacks.length >= 3) return;
        setAttacks(prev => [...prev, { id: generateId(), name: t.defaults.newAbility, damage: 50, cost: 2, desc: '', showDamage: true, background: 'rgba(255, 255, 255, 0.7)', colorMode: 'solid', secondaryBackground: '#ffffff' }])
      }, [attacks.length, t]);
      const removeAttack = useCallback((index) => {
        if (attacks.length <= 1) return;
        setAttacks(prev => prev.filter((_, i) => i !== index))
      }, [attacks.length]);




      const processImageFile = useCallback((file) => {
        if (!file) return;
        const validTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
        if (!validTypes.includes(file.type)) {
          setImageError(t.imageEditor.unsupportedFormat);
          return
        }
        if (file.size > CARD_LIMITS.MAX_FILE_SIZE) {
          setImageError(t.imageEditor.fileTooLarge);
          return
        }
        setImageLoading(true);
        setImageError(null);
        const reader = new FileReader();
        reader.onload = (e) => {
          setImage(e.target.result);
          setImageSettings(INITIAL_IMAGE_SETTINGS);
          setImageLoading(false)
        };
        reader.onerror = () => {
          setImageError('Error');
          setImageLoading(false)
        };
        reader.readAsDataURL(file)
      }, [t]);
      const clearImage = useCallback(() => {
        setImage(null);
        setImageSettings(INITIAL_IMAGE_SETTINGS);
        setImageError(null)
      }, []);

      const processBackImageFile = useCallback((file) => {
        if (!file) return;

        const validTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
        if (!validTypes.includes(file.type)) {
          setBackImageError(t.imageEditor?.unsupportedFormat || 'Unsupported format');
          return;
        }

        if (file.size > CARD_LIMITS.MAX_FILE_SIZE) {
          setBackImageError(t.imageEditor?.fileTooLarge || 'File too large');
          return;
        }

        setBackImageLoading(true);
        setBackImageError(null);

        const reader = new FileReader();
        reader.onload = (e) => {
          updateCardData('cardBack', e.target.result);
          setCardBackSettings(INITIAL_IMAGE_SETTINGS);
          setBackImageLoading(false);
        };
        reader.onerror = () => {
          notify(t.notifications?.error || 'Error', 'error');
          setBackImageError(t.imageEditor?.loading || 'Error');
          setBackImageLoading(false);
        };
        reader.readAsDataURL(file);
      }, [t, updateCardData, notify]);

      const clearBackImage = useCallback(() => {
        updateCardData('cardBack', null);
        setCardBackSettings(INITIAL_IMAGE_SETTINGS);
        setBackImageError(null);
      }, [updateCardData]);

      const handleMouseMoveThrottled = useCallback((e) => {
        if (document.body.classList.contains('is-capturing')) return;
        if (!cardRef.current) return;
        const rect = cardRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        setMousePos({ x: clamp(x, 0, 1), y: clamp(y, 0, 1) })
      }, []);
      const handleMouseMove = useThrottle(handleMouseMoveThrottled, 16);
      const typeOptions = useMemo(() => ELEMENT_KEYS.map(type => ({
        value: type, label: `${ELEMENT_TYPES[type].icon} ${t.elements[type] || type}`
      })),
        [t]);
      const stageOptions = useMemo(() => STAGES.map((stage, index) => ({
        value: stage, label: t.stages[index] || stage
      })),
        [t]);
      const fontOptions = useMemo(() => FONTS.map(font => ({ value: font.id, label: font.name })),
        []);
      const textureOptions = useMemo(() => Object.keys(CARD_TEXTURES).map(key => ({
        value: key, label: t.textures?.[key] || key
      })), [t]);
      const typeIcon = ELEMENT_TYPES[cardData.type]?.icon || '‚≠ê';
      return (<div className="app-container">
        <div className="header-controls">
          <select
            value={lang}
            onChange={(e) => setLang(e.target.value)}
            className="lang-select"
          >
            {Object.entries(LANGUAGES).map(([code, { name, flag }]) => (
              <option key={code} value={code}>
                {name}
              </option>
            ))}
          </select>
        </div>
        <h1 className="title" style={{ marginTop: '20px', marginBottom: '10px' }}>‚ú® {t.appTitle} ‚ú®</h1><p className="subtitle" style={{ marginTop: '5px', marginBottom: '25px' }}>{t.appSubtitle}</p>
        <div className="main-layout">
          <div className="card-preview">
            {/* Card Preview */}
            <Card
              cardData={cardData}
              attacks={attacks}
              image={image}
              imageSettings={imageSettings}
              cardBackSettings={cardBackSettings}
              mousePos={mousePos}
              isHovering={isHovering}
              cardRef={cardRef}
              onMouseMove={handleMouseMove}
              onMouseEnter={handleMouseEnterManual}
              onMouseLeave={handleMouseLeaveManual}
              autoRotate={autoRotate}
              isFlipped={isFlipped}
              t={t}
            /><p className="hover-hint">{t.hoverHint}</p>
            {/* View Controls - 3D Rotate & Flip */}
            <div style={{ display: 'flex', gap: '10px', width: '380px', margin: '0 auto 16px auto' }}>
              <button
                className={`auto-rotate-btn ${autoRotate ? 'active' : ''}`}
                onClick={() => setAutoRotate(!autoRotate)}
                style={{ flex: '1', padding: '8px 8px', fontSize: '13px', display: 'flex', justifyContent: 'center', alignItems: 'center', gap: '6px', minWidth: 0 }}
              >
                {autoRotate ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'} <span style={{ whiteSpace: 'normal', lineHeight: '1.1', textAlign: 'center' }}>{t.buttons.autoRotate || "Vue 3D"}</span>
              </button>
              <button
                className={`auto-rotate-btn ${isFlipped ? 'active' : ''}`}
                onClick={() => setIsFlipped(!isFlipped)}
                style={{ flex: '1', padding: '8px 8px', fontSize: '13px', display: 'flex', justifyContent: 'center', alignItems: 'center', gap: '6px', minWidth: 0 }}
              >
                üîÑ <span style={{ whiteSpace: 'normal', lineHeight: '1.1', textAlign: 'center' }}>{isFlipped ? (t.buttons.showFront || 'Show Front') : (t.buttons.flipCard || 'Flip Card')}</span>
              </button>
            </div>

            {/* Download & Reset Group - Matches width */}
            <div style={{ display: 'flex', flexDirection: 'column', width: '380px', alignItems: 'stretch', marginTop: '10px' }}>
              {/* Action Buttons Group */}
              <div className="download-section" style={{ marginTop: '0' }}>
                <div className="download-buttons" style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
                  {/* Row 1: Storage */}
                  <div style={{ display: 'flex', gap: '6px' }}>
                    <button className="header-btn save" onClick={() => setIsSaveModalOpen(true)} title={t.buttons.save || 'Save'} style={{ flex: 1, padding: '8px 2px', fontSize: '12px', minWidth: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '2px' }}>
                      üíæ <span className="btn-text" style={{ whiteSpace: 'normal', lineHeight: '1.1', textAlign: 'center' }}>{t.buttons.save || 'Save'}</span>
                    </button>
                    <button className="header-btn load" onClick={openLoadModal} title={t.buttons.load || 'Load'} style={{ flex: 1, padding: '8px 2px', fontSize: '12px', minWidth: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '2px' }}>
                      üìÇ <span className="btn-text" style={{ whiteSpace: 'normal', lineHeight: '1.1', textAlign: 'center' }}>{t.buttons.load || 'Load'}</span>
                    </button>
                    <button className="header-btn json" onClick={() => setIsJsonModalOpen(true)} title={t.buttons.json} style={{ flex: 1, padding: '8px 2px', fontSize: '12px', minWidth: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '2px' }}>
                      ‚öôÔ∏è <span className="btn-text" style={{ whiteSpace: 'normal', lineHeight: '1.1', textAlign: 'center' }}>{t.buttons.json}</span>
                    </button>
                  </div>
                  {/* Row 2: Export */}
                  <div style={{ display: 'flex', gap: '10px' }}>
                    <button className="header-btn print" onClick={openDeckBuilder} title={t.deckBuilder?.title} style={{ flex: 1, background: '#8b5cf6', padding: '8px 8px', fontSize: '13px', minWidth: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px' }}>
                      üñ®Ô∏è <span className="btn-text" style={{ whiteSpace: 'normal', lineHeight: '1.1', textAlign: 'center' }}>{t.deckBuilder?.title || "Deck Builder"}</span>
                    </button>
                    <button className="header-btn download" onClick={() => setIsDownloadModalOpen(true)} title={t.download.title} style={{ flex: 1, padding: '8px 8px', fontSize: '13px', minWidth: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px' }}>
                      <span className="btn-text" style={{ whiteSpace: 'normal', lineHeight: '1.1', textAlign: 'center' }}>{t.download.title}</span>
                    </button>
                  </div>
                </div>
              </div>

              {/* Reset Button */}
              <div style={{ marginTop: '6px' }}>
                <button
                  className="no-capture"
                  onClick={() => setShowResetConfirm(true)}
                  style={{ width: '100%', padding: '12px', background: 'rgba(244, 67, 54, 0.1)', color: '#f44336', border: '1px solid rgba(244, 67, 54, 0.2)', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', transition: 'all 0.2s' }}
                  onMouseOver={(e) => { e.currentTarget.style.background = 'rgba(244, 67, 54, 0.2)'; }}
                  onMouseOut={(e) => { e.currentTarget.style.background = 'rgba(244, 67, 54, 0.1)'; }}
                >
                  {t.buttons.resetCard}
                </button>
              </div>
              {/* Legal Notice Link */}
              <a href="legal.html" style={{ display: 'block', textAlign: 'center', color: '#555', fontSize: '11px', marginTop: '15px', textDecoration: 'none' }} onMouseOver={(e) => e.target.style.color = '#ffd700'} onMouseOut={(e) => e.target.style.color = '#555'}>{t.common?.legalNotice || 'Legal'}</a>
            </div>
          </div>
          {/* Editor Panel */}
          <div className="editor-panel">
            <div className="editor-tabs">
              <button
                className={`tab-btn ${activeTab === 'visual' ? 'active' : ''}`}
                onClick={() => { setActiveTab('visual'); setOpenSection('image'); }}
              >
                üì∑ {t.tabs.visual}
              </button>
              <button
                className={`tab-btn ${activeTab === 'content' ? 'active' : ''}`}
                onClick={() => { setActiveTab('content'); setOpenSection('basicInfo'); }}
              >
                üìù {t.tabs.content || t.tabs.info}
              </button>
              <button
                className={`tab-btn ${activeTab === 'colors' ? 'active' : ''}`}
                onClick={() => { setActiveTab('colors'); setOpenSection('cardStyle'); }}
              >
                üé® {t.tabs.colors || t.tabs.style}
              </button>

            </div>

            <div className="tab-content">
              {activeTab === 'content' && (
                <>
                  <CollapsibleSection
                    title={t.sections.basicInfo}
                    icon="üìù"
                    isOpen={openSection === 'basicInfo'}
                    onToggle={() => setOpenSection(openSection === 'basicInfo' ? null : 'basicInfo')}
                  >
                    <div className="grid-2">
                      <InputGroup
                        id="creature-name"
                        label={t.labels.name}
                        value={cardData.name}
                        onChange={(v) => updateCardData('name', v)}
                        maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
                      />

                      <InputGroup
                        id="creature-hp"
                        label={t.labels.hp}
                        type="number"
                        value={cardData.hp}
                        onChange={(v) => updateCardDataNumeric('hp', v, CARD_LIMITS.HP_MIN, CARD_LIMITS.HP_MAX)}
                        min={CARD_LIMITS.HP_MIN}
                        max={CARD_LIMITS.HP_MAX}
                      />
                    </div>
                    <InputGroup
                      id="creature-stage"
                      label={t.labels.stage}
                      value={cardData.stage}
                      onChange={(v) => updateCardData('stage', v)}
                      options={stageOptions}
                    />
                    <div style={{ display: 'flex', flexDirection: 'column' }}>
                      <InputGroup
                        id="creature-description"
                        label={t.labels.description}
                        value={cardData.description}
                        onChange={(v) => updateCardData('description', v)}
                        rows={2}
                        maxLength={CARD_LIMITS.DESC_MAX_LENGTH}
                      />
                    </div>
                    <InputGroup
                      id="creature-author"
                      label={t.labels.author}
                      value={cardData.author}
                      onChange={(v) => updateCardData('author', v)}
                      maxLength={CARD_LIMITS.AUTHOR_MAX_LENGTH}
                    />
                  </CollapsibleSection>


                  <CollapsibleSection
                    title={t.sections.abilities || "Abilities Info"}
                    icon="‚öîÔ∏è"
                    isOpen={openSection === 'abilitiesInfo'}
                    onToggle={() => setOpenSection(openSection === 'abilitiesInfo' ? null : 'abilitiesInfo')}
                  >
                    {attacks.map((attack, idx) => (
                      <AttackInfoEditor
                        key={attack.id}
                        index={idx}
                        attack={attack}
                        typeIcon={typeIcon}
                        onUpdate={updateAttack}
                        onRemove={removeAttack}
                        canRemove={attacks.length > 1}
                        t={t}
                      />
                    ))}
                    <button
                      type="button"
                      className="add-attack-btn"
                      onClick={addAttack}
                      disabled={attacks.length >= 3}
                    >
                      {t.buttons.addAbility} {attacks.length >= 3 && '(max 3)'}
                    </button>
                  </CollapsibleSection>

                  <CollapsibleSection
                    title={t.sections.stats}
                    icon="üìä"
                    isOpen={openSection === 'stats'}
                    onToggle={() => setOpenSection(openSection === 'stats' ? null : 'stats')}
                  >
                    <div className="grid-3">
                      <EmojiInput
                        label={t.labels.weakness}
                        value={cardData.weakness}
                        onChange={(v) => updateCardData('weakness', v)}
                      />
                      <EmojiInput
                        label={t.labels.resistance}
                        value={cardData.resistance}
                        onChange={(v) => updateCardData('resistance', v)}
                      />
                      <InputGroup
                        id="creature-retreat"
                        label={t.labels.retreatCost}
                        type="number"
                        value={cardData.retreatCost}
                        onChange={(v) => updateCardDataNumeric('retreatCost', v, CARD_LIMITS.RETREAT_MIN, CARD_LIMITS.RETREAT_MAX)}
                        min={CARD_LIMITS.RETREAT_MIN}
                        max={CARD_LIMITS.RETREAT_MAX}
                      />
                    </div>
                  </CollapsibleSection>

                </>
              )}


              {activeTab === 'visual' && (
                <>
                  <CollapsibleSection
                    title={t.sections.image}
                    icon="üì∑"
                    isOpen={openSection === 'image'}
                    onToggle={() => setOpenSection(openSection === 'image' ? null : 'image')}
                  >
                    <ImageEditor
                      image={image}
                      settings={imageSettings}
                      onSettingsChange={setImageSettings}
                      isLoading={imageLoading}
                      error={imageError}
                      onUpload={processImageFile}
                      onClear={clearImage}
                      t={t}
                    />
                  </CollapsibleSection>

                  <CollapsibleSection
                    title={t.sections.cardBack || "Card Back"}
                    icon="üîÑ"
                    isOpen={openSection === 'cardBack'}
                    onToggle={() => setOpenSection(openSection === 'cardBack' ? null : 'cardBack')}
                  >
                    <ImageEditor
                      image={cardData.cardBack}
                      settings={cardBackSettings}
                      onSettingsChange={setCardBackSettings}
                      isLoading={backImageLoading}
                      error={backImageError}
                      onUpload={processBackImageFile}
                      onClear={clearBackImage}
                      t={t}
                    />

                    {/* Border option - always visible */}
                    <div style={{ marginTop: '12px' }}>
                      <Checkbox
                        id="cardback-border"
                        label={t.cardBackOptions?.border || "Border"}
                        checked={cardData.cardBackShowBorder !== false}
                        onChange={(v) => updateCardData('cardBackShowBorder', v)}
                      />
                    </div>

                    {/* Card Back Customization - Only show when no custom image */}
                    {!cardData.cardBack && (
                      <div style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid rgba(255,255,255,0.1)' }}>
                        <h4 style={{ margin: '0 0 12px 0', fontSize: '13px', color: '#a0a0c0', fontWeight: 600 }}>
                          {t.cardBackOptions?.title || "Default Back Style"}
                        </h4>

                        {/* Colors */}
                        <div className="grid-2" style={{ marginBottom: '12px' }}>
                          <InputGroup
                            id="card-back-primary"
                            label={t.cardBackOptions?.primaryColor || t.labels.primaryColor || "Primary"}
                            type="color"
                            value={cardData.cardBackPrimaryColor || cardData.primaryColor || '#ff6b35'}
                            onChange={(v) => updateCardData('cardBackPrimaryColor', v)}
                          />
                          <InputGroup
                            id="card-back-secondary"
                            label={t.cardBackOptions?.secondaryColor || t.labels.secondaryColor || "Secondary"}
                            type="color"
                            value={cardData.cardBackSecondaryColor || cardData.secondaryColor || '#ff9e80'}
                            onChange={(v) => updateCardData('cardBackSecondaryColor', v)}
                          />
                        </div>

                        {/* Gradient Type */}
                        <div style={{ marginBottom: '12px' }}>
                          <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>
                            {t.cardBackOptions?.gradientType || "Gradient Type"}
                          </label>
                          <div style={{ display: 'flex', gap: '6px' }}>
                            <button
                              className={`mode-toggle-btn ${cardData.cardBackGradientType === 'radial' ? 'active' : ''}`}
                              onClick={() => updateCardData('cardBackGradientType', 'radial')}
                              style={{ flex: 1 }}
                            >
                              {t.cardBackOptions?.radial || "Radial"}
                            </button>
                            <button
                              className={`mode-toggle-btn ${cardData.cardBackGradientType === 'linear' ? 'active' : ''}`}
                              onClick={() => updateCardData('cardBackGradientType', 'linear')}
                              style={{ flex: 1 }}
                            >
                              {t.cardBackOptions?.linear || "Linear"}
                            </button>
                            <button
                              className={`mode-toggle-btn ${cardData.cardBackGradientType === 'solid' ? 'active' : ''}`}
                              onClick={() => updateCardData('cardBackGradientType', 'solid')}
                              style={{ flex: 1 }}
                            >
                              {t.labels?.solid || "Solid"}
                            </button>
                          </div>
                        </div>

                        {/* Gradient Angle - Only for linear */}
                        {cardData.cardBackGradientType === 'linear' && (
                          <div style={{ marginBottom: '12px' }}>
                            <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>
                              {t.cardBackOptions?.angle || "Angle"}: {cardData.cardBackGradientAngle || 135}¬∞
                            </label>
                            <input
                              type="range"
                              min="0"
                              max="360"
                              step="15"
                              value={cardData.cardBackGradientAngle || 135}
                              onChange={(e) => updateCardData('cardBackGradientAngle', parseInt(e.target.value))}
                              style={{ width: '100%' }}
                            />
                          </div>
                        )}

                        {/* Decorative Elements */}
                        <div style={{ marginTop: '12px' }}>
                          <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '8px', fontWeight: '600' }}>
                            {t.cardBackOptions?.elements || "Decorative Elements"}
                          </label>
                          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '6px' }}>
                            <Checkbox
                              id="cardback-center-icon"
                              label={t.cardBackOptions?.centerIcon || "Center Icon"}
                              checked={cardData.cardBackShowCenterIcon !== false}
                              onChange={(v) => updateCardData('cardBackShowCenterIcon', v)}
                            />
                            <Checkbox
                              id="cardback-corner-icons"
                              label={t.cardBackOptions?.cornerIcons || "Corner Icons"}
                              checked={cardData.cardBackShowCornerIcons !== false}
                              onChange={(v) => updateCardData('cardBackShowCornerIcons', v)}
                            />
                            <Checkbox
                              id="cardback-frame"
                              label={t.cardBackOptions?.frame || "Frame"}
                              checked={cardData.cardBackShowFrame !== false}
                              onChange={(v) => updateCardData('cardBackShowFrame', v)}
                            />
                          </div>
                        </div>

                        {/* Texture */}
                        <div style={{ marginTop: '12px' }}>
                          <div style={{ display: 'grid', gridTemplateColumns: cardData.cardBackTexture && cardData.cardBackTexture !== 'none' ? '2fr 1fr' : '1fr', gap: '8px' }}>
                            <InputGroup
                              id="cardback-texture"
                              label={t.cardBackOptions?.texture || "Texture"}
                              value={cardData.cardBackTexture || 'none'}
                              onChange={(v) => updateCardData('cardBackTexture', v)}
                              options={textureOptions}
                            />
                            {cardData.cardBackTexture && cardData.cardBackTexture !== 'none' && (
                              <InputGroup
                                id="cardback-texture-color"
                                label={t.labels.color}
                                type="color"
                                value={cardData.cardBackTextureColor || '#000000'}
                                onChange={(v) => updateCardData('cardBackTextureColor', v)}
                              />
                            )}
                          </div>
                        </div>
                      </div>
                    )}
                  </CollapsibleSection>

                  {/* Presets Section - Moved from style tab */}
                  <CollapsibleSection
                    title={t.labels.presets || "Presets"}
                    icon="‚ö°"
                    isOpen={openSection === 'presets'}
                    onToggle={() => setOpenSection(openSection === 'presets' ? null : 'presets')}
                  >
                    <div className="icon-presets" style={{ display: 'grid', gridTemplateColumns: 'repeat(6, 1fr)', gap: '8px' }}>
                      {Object.entries(ELEMENT_TYPES).map(([key, data]) => (
                        <button
                          key={key}
                          type="button"
                          className="preset-btn"
                          onClick={() => {
                            setCardData(prev => ({
                              ...prev,
                              customIcon: data.icon,
                              primaryColor: data.primary,
                              secondaryColor: data.secondary,
                              particleEmoji: ELEMENT_PARTICLES[key]?.emoji || '‚ú®',
                              particleAnimation: key.toLowerCase(),
                              type: key,
                              weakness: data.weakness,
                              resistance: data.resistance,
                              cardInnerBackground: 'rgba(255, 255, 255, 0.95)',
                              cardInnerColorMode: 'solid',
                              cardInnerSecondaryBackground: `${data.primary}10`,
                              borderColor: data.primary,
                              nameColor: '', hpColor: '', typeColor: '', descColor: '', statsColor: '', authorColor: '', textColor: '',
                              // Reset card back to use preset colors
                              cardBackPrimaryColor: '', cardBackSecondaryColor: '', cardBackGradientType: 'radial', cardBackGradientAngle: 135,
                              cardBackShowCenterIcon: true, cardBackShowCornerIcons: true, cardBackShowFrame: true,
                              cardBackTexture: 'none', cardBackTextureColor: '#000000'
                            }));
                            setAttacks(prev => prev.map(a => ({
                              ...a,
                              background: data.primary + '40',
                              secondaryBackground: data.secondary + '40',
                              colorMode: 'gradient'
                            })));
                          }}
                          title={t.elements[key] || key}
                          style={{
                            backgroundColor: data.primary + '20',
                            border: '1px solid ' + data.primary + '40',
                            borderRadius: '6px',
                            padding: '8px',
                            cursor: 'pointer',
                            fontSize: '1.2em',
                            transition: 'all 0.2s'
                          }}
                          onMouseEnter={(e) => {
                            e.currentTarget.style.backgroundColor = data.primary + '40';
                            e.currentTarget.style.transform = 'scale(1.05)';
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor = data.primary + '20';
                            e.currentTarget.style.transform = 'scale(1)';
                          }}
                        >
                          {data.icon}
                        </button>
                      ))}
                    </div>
                  </CollapsibleSection>

                  <CollapsibleSection
                    title={t.sections.particles || "Particles"}
                    icon="‚ú®"
                    isOpen={openSection === 'particles'}
                    onToggle={() => setOpenSection(openSection === 'particles' ? null : 'particles')}
                  >
                    <div className="grid-2">
                      <EmojiInput
                        label={t.labels.particleEmoji || "Particle Emoji"}
                        value={cardData.particleEmoji}
                        onChange={(v) => updateCardData('particleEmoji', v)}
                      />
                      <InputGroup
                        id="particle-animation"
                        label={t.labels.animation || "Animation"}
                        value={cardData.particleAnimation || 'fire'}
                        onChange={(v) => updateCardData('particleAnimation', v)}
                        options={PARTICLE_ANIMATIONS.map(anim => ({ value: anim.key, label: t.animations?.[anim.key] || anim.label }))}
                      />
                    </div>
                    <div style={{ marginTop: '12px' }}>
                      <Checkbox
                        id="show-particles"
                        label={t.checkboxes.showParticles}
                        checked={cardData.showParticles}
                        onChange={(v) => updateCardData('showParticles', v)}
                      />
                    </div>
                  </CollapsibleSection>

                </>
              )}

              {activeTab === 'colors' && (
                <>
                  {/* Card Style Section */}
                  <CollapsibleSection
                    title={t.sections.cardStyle || "Card Style"}
                    icon="üé®"
                    isOpen={openSection === 'cardStyle'}
                    onToggle={() => setOpenSection(openSection === 'cardStyle' ? null : 'cardStyle')}
                  >
                    <div className="grid-2" style={{ marginBottom: '12px' }}>
                      <EmojiInput
                        label={t.labels.element}
                        value={cardData.customIcon}
                        onChange={(v) => updateCardData('customIcon', v)}
                      />
                      <InputGroup
                        id="creature-stage"
                        label={t.labels.stage}
                        value={cardData.stage}
                        onChange={(v) => updateCardData('stage', v)}
                        options={stageOptions}
                      />
                    </div>
                    <div style={{ marginBottom: '12px', display: 'grid', gridTemplateColumns: cardData.texture && cardData.texture !== 'none' ? '2fr 1fr' : '1fr', gap: '8px' }}>
                      <InputGroup
                        id="card-texture"
                        label={t.labels.texture || "Texture"}
                        value={cardData.texture || 'none'}
                        onChange={(v) => updateCardData('texture', v)}
                        options={textureOptions}
                      />
                      {cardData.texture && cardData.texture !== 'none' && (
                        <InputGroup
                          id="texture-color"
                          label={t.labels.color}
                          type="color"
                          value={cardData.textureColor || '#000000'}
                          onChange={(v) => updateCardData('textureColor', v)}
                        />
                      )}
                    </div>
                    <div style={{ marginBottom: '12px' }}>
                      <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.backgroundStyle || "Background Style"}</label>
                      <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                        <button
                          className={`mode-toggle-btn ${cardData.colorMode === 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('colorMode', 'solid')}
                        >
                          {t.labels.solid || "Solid"}
                        </button>
                        <button
                          className={`mode-toggle-btn ${cardData.colorMode !== 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('colorMode', 'gradient')}
                        >
                          {t.labels.gradient || "Gradient"}
                        </button>
                      </div>
                      <div style={{ display: 'grid', gridTemplateColumns: cardData.colorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px', minHeight: '74px' }}>
                        <InputGroup
                          id="primary-color"
                          label={cardData.colorMode === 'solid' ? t.labels.backgroundColor : (t.labels.primaryColor || "Primary Color")}
                          type="color"
                          value={cardData.primaryColor}
                          onChange={(v) => updateCardData('primaryColor', v)}
                        />
                        {cardData.colorMode !== 'solid' && (
                          <InputGroup
                            id="secondary-color"
                            label={t.labels.secondaryColor || "Secondary Color"}
                            type="color"
                            value={cardData.secondaryColor}
                            onChange={(v) => updateCardData('secondaryColor', v)}
                          />
                        )}
                      </div>
                    </div>

                    <div style={{ marginBottom: '12px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '12px' }}>
                      <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.cardInner || "Card Inner Background"}</label>
                      <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                        <button
                          className={`mode-toggle-btn ${cardData.cardInnerColorMode === 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('cardInnerColorMode', 'solid')}
                        >
                          {t.labels.solid || "Solid"}
                        </button>
                        <button
                          className={`mode-toggle-btn ${cardData.cardInnerColorMode !== 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('cardInnerColorMode', 'gradient')}
                        >
                          {t.labels.gradient || "Gradient"}
                        </button>
                      </div>
                      <div style={{ display: 'grid', gridTemplateColumns: cardData.cardInnerColorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px' }}>
                        <InputGroup
                          id="inner-primary-color"
                          label={cardData.cardInnerColorMode === 'solid' ? (t.labels.backgroundColor || "Background") : (t.labels.primaryColor || "Primary")}
                          type="color"
                          value={cardData.cardInnerBackground || '#ffffff'}
                          onChange={(v) => updateCardData('cardInnerBackground', v)}
                        />
                        {cardData.cardInnerColorMode !== 'solid' && (
                          <InputGroup
                            id="inner-secondary-color"
                            label={t.labels.secondaryColor || "Secondary"}
                            type="color"
                            value={cardData.cardInnerSecondaryBackground || '#f5f5fa'}
                            onChange={(v) => updateCardData('cardInnerSecondaryBackground', v)}
                          />
                        )}
                      </div>
                    </div>
                    <InputGroup
                      id="card-border-color"
                      label={t.labels.borderColor}
                      type="color"
                      value={cardData.borderColor || '#ffd700'}
                      onChange={(v) => updateCardData('borderColor', v)}
                    />
                  </CollapsibleSection>

                  {/* Text Style Section */}
                  <CollapsibleSection
                    title={t.sections.textStyle || "Text Style"}
                    icon="üìù"
                    isOpen={openSection === 'textStyle'}
                    onToggle={() => setOpenSection(openSection === 'textStyle' ? null : 'textStyle')}
                  >
                    <div style={{ marginBottom: '20px' }}>
                      <InputGroup
                        id="card-font"
                        label={t.labels.font}
                        value={cardData.font}
                        onChange={(v) => updateCardData('font', v)}
                        options={fontOptions}
                      />
                    </div>

                    <div>
                      <TextSettingsGroup label={t.labels.name} colorKey="nameColor" sizeKey="nameSize" weightKey="nameWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.hp} colorKey="hpColor" sizeKey="hpSize" weightKey="hpWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.element + " / " + t.labels.stage} colorKey="typeColor" sizeKey="stageSize" weightKey="stageWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.abilityName || "Ability Name"} colorKey="moveNameColor" sizeKey="moveNameSize" weightKey="moveNameWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.abilityDesc || "Abilities Description"} colorKey="moveDescColor" sizeKey="moveDescSize" weightKey="moveDescWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.description} colorKey="descColor" sizeKey="descSize" weightKey="descWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.stats || "Stats"} colorKey="statsColor" sizeKey="statsSize" weightKey="statsWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.author} colorKey="authorColor" sizeKey="authorSize" weightKey="authorWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                    </div>
                  </CollapsibleSection>

                  {/* Ability Style Section */}
                  <CollapsibleSection
                    title={t.sections.abilityStyle || "Ability Style"}
                    icon="üé®"
                    isOpen={openSection === 'abilityStyle'}
                    onToggle={() => setOpenSection(openSection === 'abilityStyle' ? null : 'abilityStyle')}
                  >
                    {attacks.map((attack, idx) => (
                      <AttackStyleEditor
                        key={attack.id}
                        index={idx}
                        attack={attack}
                        typeIcon={typeIcon}
                        onUpdate={updateAttack}
                        t={t}
                      />
                    ))}
                  </CollapsibleSection>

                  {/* Display Options - Moved from visual tab */}
                  <CollapsibleSection
                    title={t.display.title}
                    icon="üëÅÔ∏è"
                    isOpen={openSection === 'appearance'}
                    onToggle={() => setOpenSection(openSection === 'appearance' ? null : 'appearance')}
                  >
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                      <Checkbox
                        id="show-hp"
                        label={t.checkboxes.showHP}
                        checked={cardData.showHP}
                        onChange={(v) => updateCardData('showHP', v)}
                      />
                      <Checkbox
                        id="show-weak-res"
                        label={t.checkboxes.showWeakRes}
                        checked={cardData.showWeakRes}
                        onChange={(v) => updateCardData('showWeakRes', v)}
                      />
                      <Checkbox
                        id="show-retreat"
                        label={t.checkboxes.showRetreat}
                        checked={cardData.showRetreat}
                        onChange={(v) => updateCardData('showRetreat', v)}
                      />
                      <Checkbox
                        id="show-desc"
                        label={t.checkboxes.showDescription}
                        checked={cardData.showDescription}
                        onChange={(v) => updateCardData('showDescription', v)}
                      />

                    </div>
                  </CollapsibleSection>

                </>
              )}
            </div>

            {showResetConfirm && (
              <div className="modal-overlay" onClick={() => setShowResetConfirm(false)} style={{ zIndex: 11000 }}>
                <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '400px' }}>
                  <div className="modal-header">
                    <h3 style={{ color: '#f44336' }}>‚ö†Ô∏è {t.sections?.reset || 'Reset'}</h3>
                  </div>
                  <div className="modal-body">
                    <p>{t.prompts.resetConfirm}</p>
                  </div>
                  <div className="modal-footer">
                    <button className="secondary-button" onClick={() => setShowResetConfirm(false)}>
                      {t.common.cancel}
                    </button>
                    <button
                      className="primary-button"
                      style={{ background: '#f44336' }}
                      onClick={() => {
                        setCardData(getInitialCardData(t));
                        setAttacks(getInitialAttacks(t));
                        setImage(null);
                        setImageSettings(INITIAL_IMAGE_SETTINGS);
                        setShowResetConfirm(false);
                      }}
                    >
                      {t.buttons.resetCard}
                    </button>
                  </div>
                </div>
              </div>
            )}

            <SaveModal
              isOpen={isSaveModalOpen}
              onClose={() => setIsSaveModalOpen(false)}
              onSave={handleSaveCard}
              defaultName={cardData.name}
              t={t}
            />
            <LoadModal
              isOpen={isLoadModalOpen}
              onClose={() => setIsLoadModalOpen(false)}
              onLoad={handleLoadCard}
              onDelete={handleDeleteCard}
              onDeleteAll={handleDeleteAllCards}
              cards={savedCards}
              t={t}
            />

            <JsonModal
              isOpen={isJsonModalOpen}
              onClose={() => setIsJsonModalOpen(false)}
              onImport={handleImportJSON}
              onExport={handleExportJSON}
              t={t}
            />

            <DownloadModal
              isOpen={isDownloadModalOpen}
              onClose={() => setIsDownloadModalOpen(false)}
              t={t}
              cardRef={cardRef}
              cardName={cardData.name || 'card'}
              isGifSupported={isGifSupported}
              isFlipped={isFlipped}
            />

            <DeckBuilderModal
              isOpen={isDeckBuilderOpen}
              onClose={() => setIsDeckBuilderOpen(false)}
              t={t}
              savedCards={savedCards}
              notify={notify}
            />

            <ConfirmModal
              isOpen={confirmState.isOpen}
              title={confirmState.title}
              message={confirmState.message}
              onConfirm={confirmState.onConfirm}
              onClose={() => setConfirmState(prev => ({ ...prev, isOpen: false }))}
              t={t}
            />

          </div></div></div >)
    }
    function CardCreator() {
      const [lang, setLang] = useState('en');
      const t = TRANSLATIONS[lang];
      const [isGifSupported, setIsGifSupported] = useState(true);

      useEffect(() => {
        // Detect if getDisplayMedia is supported (Mobile usually doesn't support it)
        const supported = !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia);
        setIsGifSupported(supported);
      }, []);

      return (
        <LanguageContext.Provider value={{ lang, setLang, t, isGifSupported }}>
          <NotificationProvider>
            <CardCreatorContent />
          </NotificationProvider>
        </LanguageContext.Provider>
      )
    }
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CardCreator />);


  </script>
</body>

</html>
