<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Creator</title>
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Html2Canvas -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Emoji Picker -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
  <link rel="stylesheet" href="styles.css">
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@400;700&family=Bangers&family=Cinzel:wght@400;700;900&family=Dancing+Script:wght@400;700&family=Nunito:wght@400;700;900&family=Orbitron:wght@400;700;900&family=Oswald:wght@400;700&family=Playfair+Display:wght@400;700;900&family=Poppins:wght@400;700;900&family=Roboto:wght@400;700;900&display=swap"
    rel="stylesheet">
</head>

<body>
  <div id="root"></div>

  <!-- GIF Instructions Modal -->
  <div id="gif-instructions-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h3>ğŸ“¹ High Quality GIF Capture (v2)</h3>
      </div>
      <div class="modal-body">
        <p>To get a perfect result, we need to capture the screen:</p>
        <div class="steps-list">
          <div class="step-item">
            <span class="step-number">1</span>
            <div id="gif-modal-step-1" class="step-text">Select the <strong>"Chrome Tab"</strong> tab.</div>
          </div>
          <div class="step-item">
            <span class="step-number">2</span>
            <div id="gif-modal-step-2" class="step-text">Choose <strong>this page</strong> from the list.</div>
          </div>
          <div class="step-item">
            <span class="step-number">3</span>
            <div id="gif-modal-step-3" class="step-text">Click <strong>"Share"</strong>.</div>
          </div>
        </div>
        <div class="gif-settings" style="margin-bottom: 20px; display: flex; gap: 15px;">
          <div class="setting-group" style="flex: 1;">
            <label id="gif-fps-label"
              style="display: block; color: #a0a0c0; font-size: 12px; margin-bottom: 5px; font-weight: 600;">FPS</label>
            <select id="gif-fps-select" class="gif-settings-select">
              <option value="15" id="gif-fps-normal">15 FPS (Normal)</option>
              <option value="24" id="gif-fps-cinema" selected>24 FPS (Cinema)</option>
              <option value="30" id="gif-fps-smooth">30 FPS (Smooth)</option>
              <option value="60" id="gif-fps-ultra">60 FPS (Ultra)</option>
            </select>
          </div>
          <div class="setting-group" style="flex: 1;">
            <label id="gif-quality-label"
              style="display: block; color: #a0a0c0; font-size: 12px; margin-bottom: 5px; font-weight: 600;">Quality
              (Height)</label>
            <select id="gif-scale-select" class="gif-settings-select">
              <option value="480" id="gif-quality-sd">480p (SD)</option>
              <option value="720" id="gif-quality-normal" selected>720p (HD)</option>
              <option value="1080" id="gif-quality-high">1080p (Full HD)</option>
              <option value="1440" id="gif-quality-qhd">1440p (QHD)</option>
              <option value="2160" id="gif-quality-ultra">4K (UHD)</option>
            </select>
          </div>
        </div>
        <div class="modal-note">
          <span class="note-icon">ğŸ’¡</span>
          <span>The mouse will be automatically hidden and the card cropped.</span>
        </div>
        <div class="modal-warning">
          <span class="note-icon">âš ï¸</span>
          <span>Using maximum settings (60 FPS / 4K) may take longer and use high CPU.</span>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancel-gif-btn" class="secondary-btn">Cancel</button>
        <button id="start-gif-btn" class="primary-btn">Start Capture</button>
      </div>
    </div>
  </div>

  <script type="text/babel">

    const { useState, useRef, useMemo, useCallback, useEffect, createContext, useContext } = React;
    const LANGUAGES = {
      en: { name: 'English', flag: 'ğŸ‡¬ğŸ‡§' }, fr: { name: 'FranÃ§ais', flag: 'ğŸ‡«ğŸ‡·' }, es: { name: 'EspaÃ±ol', flag: 'ğŸ‡ªğŸ‡¸' }, de: { name: 'Deutsch', flag: 'ğŸ‡©ğŸ‡ª' }, ru: { name: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹', flag: 'ğŸ‡·ğŸ‡º' }, ja: { name: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ' }, zh: { name: 'ä¸­æ–‡', flag: 'ğŸ‡¨ğŸ‡³' },
    };
    const TRANSLATIONS = {
      en: {
        gifModal: {
          title: "ğŸ“¹ High Quality GIF Capture",
          body: "To get a perfect result, we need to capture the screen:",
          step1: "Select the <strong>\"Tab\"</strong> option.",
          step2: "Choose <strong>this page</strong> from the list.",
          step3: "Click <strong>\"Share\"</strong>.",
          note: "The mouse will be automatically hidden and the card cropped.",
          warning: "Using maximum settings (60 FPS / 4K) may take longer and use high CPU.",
          fpsLabel: "FPS",
          qualityLabel: "Quality (Height)",
          fpsNormal: "15 FPS (Normal)",
          fpsCinema: "24 FPS (Cinema)",
          fpsSmooth: "30 FPS (Smooth)",
          fpsUltra: "60 FPS (Ultra)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "Cancel",
          start: "Start Capture", loadingLibs: "â³ Loading libs...", capturing: "ğŸ“¸ Capturing...", encoding: "âš™ï¸ Encoding..."
        },
        appTitle: 'Card Creator',
        appSubtitle: 'Create your own personalized collectible cards',
        hoverHint: 'âœ¨ Hover over the card to intensify the effect âœ¨',
        elements: { Fire: 'Fire', Water: 'Water', Nature: 'Nature', Electric: 'Electric', Mystic: 'Mystic', Fighting: 'Fighting', Shadow: 'Shadow', Metal: 'Metal', Light: 'Light', Dragon: 'Dragon', Ice: 'Ice', Neutral: 'Neutral' },
        effects: { none: { name: 'None', description: 'No effect' }, holographic: { name: 'Holographic', description: 'Classic rainbow effect' }, rainbow: { name: 'Rainbow', description: 'Animated multicolor gradient' }, gold: { name: 'Gold', description: 'Luxurious golden reflections' }, silver: { name: 'Silver', description: 'Metallic silver reflections' }, prismatic: { name: 'Prismatic', description: 'Refracting crystal effect' }, neon: { name: 'Neon', description: 'Vibrant neon glow' }, galaxy: { name: 'Galaxy', description: 'Starry cosmic effect' }, fire: { name: 'Flames', description: 'Animated flame effect' }, ice: { name: 'Frost', description: 'Sparkling ice effect' } },
        stages: ['Base', 'Stage 1', 'Stage 2', 'Special', 'Legendary', 'Mythic', 'Ultra'],
        rarities: { common: 'Common', uncommon: 'Uncommon', rare: 'Rare', epic: 'Epic', legendary: 'Legendary', mythic: 'Mythic' },
        sections: { image: 'Image', basicInfo: 'Basic Information', rarityEffects: 'Effects', abilities: 'Abilities', stats: 'Statistics', appearance: 'Appearance', cardStyle: 'Card Style', textStyle: 'Text Style', particles: 'Particles', abilityStyle: 'Ability Style', reset: 'Reset' },
        labels: { name: 'Name', hp: 'Hit Points', element: 'Element', stage: 'Stage', description: 'Description', author: 'Author', rarity: 'Rarity', effect: 'Effect', weakness: 'Weakness', resistance: 'Resistance', retreatCost: 'Retreat Cost', abilityName: 'Ability Name', damage: 'Damage', energyCost: 'Energy Cost', abilityDesc: 'Abilities Description', borderColor: 'Border Color', backgroundColor: 'Card Background', abilityBackground: 'Ability Background', textColor: 'Text Color', font: 'Font', size: 'Size', weight: 'Weight', zoom: 'Zoom', presets: 'Presets', backgroundStyle: 'Background Style', solid: 'Solid', gradient: 'Gradient', cardInner: 'Card Inner', primaryColor: 'Primary Color', secondaryColor: 'Secondary Color', nameColor: 'Name Color', hpColor: 'HP Color', typeColor: 'Type Color', descColor: 'Description Color', statsColor: 'Stats Color', authorColor: 'Author Color', particleEmoji: 'Particle Emoji', animation: 'Animation' },
        buttons: { addAbility: '+ Add Ability', remove: 'Remove', change: 'Change', recenter: 'Recenter', download: 'Download', autoRotate: '3D View', resetCard: 'ğŸ”„ Reset Card', save: 'Save', load: 'Load', deleteAll: 'Delete All' },
        checkboxes: { showHP: 'Show hit points', showWeakRes: 'Show weakness/resistance', showRetreat: 'Show retreat cost', showDescription: 'Show description', showTexture: 'Show texture pattern', showParticles: 'Show particles', showDamage: 'Show damage' },
        imageEditor: { dropHint: 'Drag & drop an image here', orClick: 'or click to select', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Loading...', unsupportedFormat: 'Unsupported format. Use PNG,JPG,GIF or WEBP.', fileTooLarge: 'File too large. Maximum 15MB.', searchPlaceholder: 'Type...' },
        download: { title: 'ğŸ“¥ Download', pngTitle: 'Transparent PNG image', jpgTitle: 'JPG image with background', gifTitle: 'Animated GIF (3 seconds)', webpTitle: 'WebP Image', htmlTitle: 'Interactive HTML file', capturing: 'â³ Capturing...', encoding: 'âš™ï¸ Encoding...' },
        card: { hp: 'HP', weakness: 'Weakness', resistance: 'Resistance', cost: 'Cost', illus: 'Illus.' },
        defaults: { newAbility: 'New Ability', cardName: 'My Creature', description: 'A mysterious creature with incredible powers.', author: 'Creator', attackName1: 'Fireball', attackDesc1: 'Flip a coin. If heads, the Defending PokÃ©mon is now Burned.', attackName2: 'Flamethrower', attackDesc2: 'Discard an Energy attached to this PokÃ©mon.' }, notifications: { success: 'Success', error: 'Error', info: 'Information', warning: 'Warning' },
        display: { title: 'Display Options' },
        tabs: { info: 'Info', content: 'Content', visual: 'Visual', style: 'Style', colors: 'Colors' },
        common: { cancel: 'Cancel', close: 'Close' },
        prompts: { resetConfirm: 'Reset all card data?', saveHint: 'Your card (text + image) will be saved locally.', saveSuccess: 'Card saved successfully!', loadConfirm: 'Load this card? Unsaved changes will be lost.', deleteConfirm: 'Delete this saved card?', deleteAllConfirm: 'Delete all saved cards? This cannot be undone.', allDeleted: 'All cards deleted', noSaves: 'No saved cards found.', quotaError: 'Storage full! Try deleting old cards.', saveError: 'Error saving card.', autoDeleteInfo: 'Saved cards are automatically deleted after 30 days.' },
        textures: { none: 'None', grid: 'Grid', scales: 'Scales', cross: 'Cross', stars: 'Stars', hexagons: 'Hexagons', lines: 'Lines', dots: 'Dots', waves: 'Waves', circuit: 'Circuit' },
        animations: { fire: 'Rising', water: 'Bubbles', nature: 'Floating', electric: 'Sparks', mystic: 'Magic', fighting: 'Impact', shadow: 'Fade', metal: 'Gears', light: 'Radiate', dragon: 'Majestic', ice: 'Snow', neutral: 'Subtle' }
      },
      fr: {
        gifModal: {
          title: "ğŸ“¹ Capture GIF Haute QualitÃ©",
          body: "Pour obtenir un rÃ©sultat parfait, nous devons capturer l'Ã©cran :",
          step1: "SÃ©lectionnez l'option <strong>\"Onglet\"</strong>.",
          step2: "Choisissez <strong>cette page</strong> dans la liste.",
          step3: "Cliquez sur <strong>\"Partager\"</strong>.",
          note: "La souris sera automatiquement masquÃ©e et la carte recadrÃ©e.",
          warning: "L'utilisation des paramÃ¨tres maximum (60 IPS / 4K) peut prendre plus de temps et utiliser beaucoup de CPU.",
          fpsLabel: "IPS",
          qualityLabel: "QualitÃ© (Hauteur)",
          fpsNormal: "15 IPS (Normal)",
          fpsCinema: "24 IPS (CinÃ©ma)",
          fpsSmooth: "30 IPS (Fluide)",
          fpsUltra: "60 IPS (Ultra)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "Annuler",
          start: "Lancer la capture", loadingLibs: "â³ Chargement...", capturing: "ğŸ“¸ Capture...", encoding: "âš™ï¸ Encodage..."
        },
        appTitle: 'Card Creator',
        appSubtitle: 'CrÃ©ez vos propres cartes Ã  collectionner personnalisÃ©es',
        hoverHint: 'âœ¨ Survolez la carte pour intensifier l\'effet âœ¨',
        elements: { Fire: 'Feu', Water: 'Eau', Nature: 'Nature', Electric: 'Ã‰lectrique', Mystic: 'Mystique', Fighting: 'Combat', Shadow: 'Ombre', Metal: 'MÃ©tal', Light: 'LumiÃ¨re', Dragon: 'Dragon', Ice: 'Glace', Neutral: 'Neutre' },
        effects: { none: { name: 'Aucun', description: 'Pas d\'effet' }, holographic: { name: 'Holographique', description: 'Effet arc-en-ciel classique' }, rainbow: { name: 'Arc-en-ciel', description: 'DÃ©gradÃ© multicolore animÃ©' }, gold: { name: 'DorÃ©', description: 'Reflets dorÃ©s luxueux' }, silver: { name: 'ArgentÃ©', description: 'Reflets argentÃ©s mÃ©talliques' }, prismatic: { name: 'Prismatique', description: 'Effet cristal rÃ©fractant' }, neon: { name: 'NÃ©on', description: 'Lueur nÃ©on vibrante' }, galaxy: { name: 'Galaxie', description: 'Effet cosmique Ã©toilÃ©' }, fire: { name: 'Flammes', description: 'Effet de flammes animÃ©es' }, ice: { name: 'GivrÃ©', description: 'Effet de glace scintillante' } },
        stages: ['Base', 'Ã‰volution 1', 'Ã‰volution 2', 'SpÃ©cial', 'LÃ©gendaire', 'Mythique', 'Ultra'],
        rarities: { common: 'Commune', uncommon: 'Peu commune', rare: 'Rare', epic: 'Ã‰pique', legendary: 'LÃ©gendaire', mythic: 'Mythique' },
        sections: { image: 'Image', basicInfo: 'Informations de base', rarityEffects: 'Effets', abilities: 'CapacitÃ©s', stats: 'Statistiques', appearance: 'Apparence', cardStyle: 'Style de carte', textStyle: 'Style du texte', particles: 'Particules', abilityStyle: 'Style des capacitÃ©s', reset: 'RÃ©initialiser' },
        labels: { name: 'Nom', hp: 'Points de vie', element: 'Ã‰lÃ©ment', stage: 'Stade', description: 'Description', author: 'Auteur', rarity: 'RaretÃ©', effect: 'Effet', weakness: 'Faiblesse', resistance: 'RÃ©sistance', retreatCost: 'CoÃ»t de retraite', abilityName: 'Nom de la capacitÃ©', damage: 'DÃ©gÃ¢ts', energyCost: 'CoÃ»t en Ã©nergie', abilityDesc: 'Description des capacitÃ©s', borderColor: 'Couleur de bordure', backgroundColor: 'Fond de carte', abilityBackground: 'Fond des capacitÃ©s', textColor: 'Couleur du texte', font: 'Police', size: 'Taille', weight: 'Graisse', zoom: 'Zoom', presets: 'PrÃ©rÃ©glages', backgroundStyle: 'Style de fond', solid: 'Uni', gradient: 'DÃ©gradÃ©', cardInner: 'IntÃ©rieur de la carte', primaryColor: 'Couleur principale', secondaryColor: 'Couleur secondaire', nameColor: 'Couleur du nom', hpColor: 'Couleur des PV', typeColor: 'Couleur du type', descColor: 'Couleur de description', statsColor: 'Couleur des stats', authorColor: 'Couleur de l\'auteur', particleEmoji: 'Emoji de particule', animation: 'Animation' },
        buttons: { addAbility: '+ Ajouter', remove: 'Supprimer', change: 'Changer', recenter: 'Recentrer', download: 'TÃ©lÃ©charger', autoRotate: 'AperÃ§u 3D', resetCard: 'ğŸ”„ RÃ©initialiser', save: 'Sauvegarder', load: 'Charger', deleteAll: 'Tout supprimer' },
        checkboxes: { showHP: 'Afficher les points de vie', showWeakRes: 'Afficher faiblesse/rÃ©sistance', showRetreat: 'Afficher le coÃ»t de retraite', showDescription: 'Afficher la description', showTexture: 'Afficher le motif', showParticles: 'Afficher les particules', showDamage: 'Afficher les dÃ©gÃ¢ts' },
        imageEditor: { dropHint: 'Glissez-dÃ©posez une image ici', orClick: 'ou cliquez pour sÃ©lectionner', formats: 'PNG,JPG,GIF,WEBP (max 15Mo)', loading: 'Chargement...', unsupportedFormat: 'Format non supportÃ©. Utilisez PNG,JPG,GIF ou WEBP.', fileTooLarge: 'Fichier trop volumineux. Maximum 15Mo.', searchPlaceholder: 'Tapez...' },
        download: { title: 'ğŸ“¥ TÃ©lÃ©charger', pngTitle: 'Image PNG transparente', jpgTitle: 'Image JPG avec fond', gifTitle: 'GIF animÃ© (3 secondes)', webpTitle: 'Image WebP', htmlTitle: 'Fichier HTML interactif', capturing: 'â³ Capture...', encoding: 'âš™ï¸ Encodage...' },
        card: { hp: 'PV', weakness: 'Faiblesse', resistance: 'RÃ©sistance', cost: 'CoÃ»t', illus: 'Illus.' },
        defaults: { newAbility: 'Nouvelle CapacitÃ©', cardName: 'Ma CrÃ©ature', description: 'Une crÃ©ature mystÃ©rieuse aux pouvoirs incroyables.', author: 'CrÃ©ateur', attackName1: 'Boule de Feu', attackDesc1: 'Lancez une piÃ¨ce. Si c\'est face, le PokÃ©mon DÃ©fenseur est maintenant BrÃ»lÃ©.', attackName2: 'Lance-Flammes', attackDesc2: 'DÃ©faussez une Ã‰nergie attachÃ©e Ã  ce PokÃ©mon.' }, notifications: { success: 'SuccÃ¨s', error: 'Erreur', info: 'Information', warning: 'Attention' },
        display: { title: 'Options d\'affichage' },
        tabs: { info: 'Infos', content: 'Contenu', visual: 'Visuel', style: 'Style', colors: 'Couleurs' },
        common: { cancel: 'Annuler', close: 'Fermer' },
        prompts: { resetConfirm: 'RÃ©initialiser toutes les donnÃ©es de la carte ?', saveHint: 'Votre carte (texte + image) sera sauvegardÃ©e localement.', saveSuccess: 'Carte sauvegardÃ©e avec succÃ¨s !', loadConfirm: 'Charger cette carte ? Les modifications non sauvegardÃ©es seront perdues.', deleteConfirm: 'Supprimer cette carte ?', deleteAllConfirm: 'Supprimer toutes les cartes ? Cette action est irrÃ©versible.', allDeleted: 'Toutes les cartes supprimÃ©es', noSaves: 'Aucune carte sauvegardÃ©e.', quotaError: 'Espace insuffisant ! Supprimez des anciennes cartes.', saveError: 'Erreur lors de la sauvegarde.', autoDeleteInfo: 'Les cartes sont supprimÃ©es aprÃ¨s 30 jours.' },
        textures: { none: 'Aucun', grid: 'Grille', scales: 'Ã‰cailles', cross: 'Croix', stars: 'Ã‰toiles', hexagons: 'Hexagones', lines: 'Lignes', dots: 'Points', waves: 'Vagues', circuit: 'Circuit' },
        animations: { fire: 'Montant', water: 'Bulles', nature: 'Flottant', electric: 'Ã‰tincelles', mystic: 'Magie', fighting: 'Impact', shadow: 'Fondu', metal: 'Engrenages', light: 'Rayonnement', dragon: 'Majestueux', ice: 'Neige', neutral: 'Subtil' }
      },
      es: {
        gifModal: {
          title: "ğŸ“¹ Captura GIF de Alta Calidad",
          body: "Para obtener un resultado perfecto, necesitamos capturar la pantalla:",
          step1: "Selecciona la opciÃ³n <strong>\"PestaÃ±a\"</strong>.",
          step2: "Elige <strong>esta pÃ¡gina</strong> de la lista.",
          step3: "Haz clic en <strong>\"Compartir\"</strong>.",
          note: "El ratÃ³n se ocultarÃ¡ automÃ¡ticamente y la carta se recortarÃ¡.",
          warning: "El uso de la configuraciÃ³n mÃ¡xima (60 FPS / 4K) puede tardar mÃ¡s y consumir mucha CPU.",
          fpsLabel: "FPS",
          qualityLabel: "Calidad (Altura)",
          fpsNormal: "15 FPS (Normal)",
          fpsCinema: "24 FPS (Cine)",
          fpsSmooth: "30 FPS (Fluido)",
          fpsUltra: "60 FPS (Ultra)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "Cancelar",
          start: "Iniciar Captura", loadingLibs: "â³ Cargando...", capturing: "ğŸ“¸ Capturando...", encoding: "âš™ï¸ Codificando..."
        },
        appTitle: 'Card Creator',
        appSubtitle: 'Crea tus propias cartas coleccionables personalizadas',
        hoverHint: 'âœ¨ Pasa el cursor sobre la carta para intensificar el efecto âœ¨',
        elements: { Fire: 'Fuego', Water: 'Agua', Nature: 'Naturaleza', Electric: 'ElÃ©ctrico', Mystic: 'MÃ­stico', Fighting: 'Lucha', Shadow: 'Sombra', Metal: 'Metal', Light: 'Luz', Dragon: 'DragÃ³n', Ice: 'Hielo', Neutral: 'Neutral' },
        effects: { none: { name: 'Ninguno', description: 'Sin efecto' }, holographic: { name: 'HologrÃ¡fico', description: 'Efecto arcoÃ­ris clÃ¡sico' }, rainbow: { name: 'ArcoÃ­ris', description: 'Degradado multicolor animado' }, gold: { name: 'Dorado', description: 'Reflejos dorados lujosos' }, silver: { name: 'Plateado', description: 'Reflejos metÃ¡licos plateados' }, prismatic: { name: 'PrismÃ¡tico', description: 'Efecto cristal refractante' }, neon: { name: 'NeÃ³n', description: 'Brillo neÃ³n vibrante' }, galaxy: { name: 'Galaxia', description: 'Efecto cÃ³smico estrellado' }, fire: { name: 'Llamas', description: 'Efecto de llamas animadas' }, ice: { name: 'Escarcha', description: 'Efecto de hielo brillante' } },
        stages: ['Base', 'Fase 1', 'Fase 2', 'Especial', 'Legendario', 'MÃ­tico', 'Ultra'],
        rarities: { common: 'ComÃºn', uncommon: 'Poco comÃºn', rare: 'Rara', epic: 'Ã‰pica', legendary: 'Legendaria', mythic: 'MÃ­tica' },
        sections: { image: 'Imagen', basicInfo: 'InformaciÃ³n bÃ¡sica', rarityEffects: 'Efectos', abilities: 'Habilidades', stats: 'EstadÃ­sticas', appearance: 'Apariencia', cardStyle: 'Estilo de carta', textStyle: 'Estilo de texto', particles: 'PartÃ­culas', abilityStyle: 'Estilo de habilidad', reset: 'Reiniciar' },
        labels: { name: 'Nombre', hp: 'Puntos de vida', element: 'Elemento', stage: 'Fase', description: 'DescripciÃ³n', author: 'Autor', rarity: 'Rareza', effect: 'Efecto', weakness: 'Debilidad', resistance: 'Resistencia', retreatCost: 'Coste de retirada', abilityName: 'Nombre de habilidad', damage: 'DaÃ±o', energyCost: 'Coste de energÃ­a', abilityDesc: 'DescripciÃ³n de habilidades', borderColor: 'Color del borde', backgroundColor: 'Fondo de carta', abilityBackground: 'Fondo de habilidad', textColor: 'Color del texto', font: 'Fuente', size: 'TamaÃ±o', weight: 'Peso', zoom: 'Zoom', presets: 'Preajustes', backgroundStyle: 'Estilo de fondo', solid: 'SÃ³lido', gradient: 'Degradado', cardInner: 'Interior de la carta', primaryColor: 'Color primario', secondaryColor: 'Color secundario', nameColor: 'Color del nombre', hpColor: 'Color de PV', typeColor: 'Color del tipo', descColor: 'Color de descripciÃ³n', statsColor: 'Color de estadÃ­sticas', authorColor: 'Color del autor', particleEmoji: 'Emoji de partÃ­cula', animation: 'AnimaciÃ³n' },
        buttons: { addAbility: '+ AÃ±adir', remove: 'Eliminar', change: 'Cambiar', recenter: 'Recentrar', download: 'Descargar', autoRotate: 'Vista 3D', resetCard: 'ğŸ”„ Reiniciar', save: 'Guardar', load: 'Cargar', deleteAll: 'Borrar todo' },
        checkboxes: { showHP: 'Mostrar puntos de vida', showWeakRes: 'Mostrar debilidad/resistencia', showRetreat: 'Mostrar coste de retirada', showDescription: 'Mostrar descripciÃ³n', showTexture: 'Mostrar patrÃ³n', showParticles: 'Mostrar partÃ­culas', showDamage: 'Mostrar daÃ±o' },
        imageEditor: { dropHint: 'Arrastra y suelta una imagen aquÃ­', orClick: 'o haz clic para seleccionar', formats: 'PNG,JPG,GIF,WEBP (mÃ¡x 15MB)', loading: 'Cargando...', unsupportedFormat: 'Formato no soportado. Use PNG,JPG,GIF o WEBP.', fileTooLarge: 'Archivo demasiado grande. MÃ¡ximo 15MB.', searchPlaceholder: 'Escriba...' },
        download: { title: 'ğŸ“¥ Descargar', pngTitle: 'Imagen PNG transparente', jpgTitle: 'Imagen JPG con fondo', gifTitle: 'GIF animado (3 segundos)', webpTitle: 'Imagen WebP', htmlTitle: 'Archivo HTML interactivo', capturing: 'â³ Capturando...', encoding: 'âš™ï¸ Codificando...' },
        card: { hp: 'PS', weakness: 'Debilidad', resistance: 'Resistencia', cost: 'Coste', illus: 'Illus.' },
        defaults: { newAbility: 'Nueva Habilidad', cardName: 'Mi Criatura', description: 'Una criatura misteriosa con poderes increÃ­bles.', author: 'Creador', attackName1: 'Bola de Fuego', attackDesc1: 'Lanza una moneda. Si sale cara, el PokÃ©mon Defensor pasa a estar Quemado.', attackName2: 'Lanzallamas', attackDesc2: 'Descarta una EnergÃ­a unida a este PokÃ©mon.' }, notifications: { success: 'Ã‰xito', error: 'Error', info: 'InformaciÃ³n', warning: 'Advertencia' },
        display: { title: 'Opciones de visualizaciÃ³n' },
        tabs: { info: 'Info', content: 'Contenido', visual: 'Visual', style: 'Estilo', colors: 'Colores' },
        common: { cancel: 'Cancelar', close: 'Cerrar' },
        prompts: { resetConfirm: 'Â¿Restablecer todos los datos de la carta?', saveHint: 'Tu carta (texto + imagen) se guardarÃ¡ localmente.', saveSuccess: 'Â¡Carta guardada con Ã©xito!', loadConfirm: 'Â¿Cargar esta carta? Se perderÃ¡n los cambios no guardados.', deleteConfirm: 'Â¿Eliminar esta carta guardada?', deleteAllConfirm: 'Â¿Eliminar todas las cartas? Esta acciÃ³n no se puede deshacer.', allDeleted: 'Todas las cartas eliminadas', noSaves: 'No se encontraron cartas guardadas.', quotaError: 'Â¡Almacenamiento lleno! Elimina cartas antiguas.', saveError: 'Error al guardar la carta.', autoDeleteInfo: 'Las cartas se borran tras 30 dÃ­as.' },
        textures: { none: 'Ninguno', grid: 'CuadrÃ­cula', scales: 'Escamas', cross: 'Cruz', stars: 'Estrellas', hexagons: 'HexÃ¡gonos', lines: 'LÃ­neas', dots: 'Puntos', waves: 'Olas', circuit: 'Circuito' },
        animations: { fire: 'Ascendente', water: 'Burbujas', nature: 'Flotante', electric: 'Chispas', mystic: 'Magia', fighting: 'Impacto', shadow: 'Desvanecer', metal: 'Engranajes', light: 'Resplandor', dragon: 'Majestuoso', ice: 'Nieve', neutral: 'Sutil' }
      },
      de: {
        gifModal: {
          title: "ğŸ“¹ Hochwertige GIF-Aufnahme",
          body: "FÃ¼r ein perfektes Ergebnis mÃ¼ssen wir den Bildschirm aufnehmen:",
          step1: "WÃ¤hlen Sie die Option <strong>\"Tab\"</strong>.",
          step2: "WÃ¤hlen Sie <strong>diese Seite</strong> aus der Liste.",
          step3: "Klicken Sie auf <strong>\"Teilen\"</strong>.",
          note: "Die Maus wird automatisch ausgeblendet und die Karte zugeschnitten.",
          warning: "Die Verwendung der maximalen Einstellungen (60 FPS / 4K) kann lÃ¤nger dauern und eine hohe CPU-Auslastung verursachen.",
          fpsLabel: "FPS",
          qualityLabel: "QualitÃ¤t (HÃ¶he)",
          fpsNormal: "15 FPS (Normal)",
          fpsCinema: "24 FPS (Kino)",
          fpsSmooth: "30 FPS (FlÃ¼ssig)",
          fpsUltra: "60 FPS (Ultra)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "Abbrechen",
          start: "Aufnahme starten", loadingLibs: "â³ Laden...", capturing: "ğŸ“¸ Aufnahme...", encoding: "âš™ï¸ Kodierung..."
        },
        appTitle: 'Card Creator',
        appSubtitle: 'Erstellen Sie Ihre eigenen personalisierten Sammelkarten',
        hoverHint: 'âœ¨ Fahren Sie mit der Maus Ã¼ber die Karte, um den Effekt zu verstÃ¤rken âœ¨',
        elements: { Fire: 'Feuer', Water: 'Wasser', Nature: 'Natur', Electric: 'Elektro', Mystic: 'Mystik', Fighting: 'Kampf', Shadow: 'Schatten', Metal: 'Metall', Light: 'Licht', Dragon: 'Drache', Ice: 'Eis', Neutral: 'Neutral' },
        effects: { none: { name: 'Keiner', description: 'Kein Effekt' }, holographic: { name: 'Holografisch', description: 'Klassischer Regenbogeneffekt' }, rainbow: { name: 'Regenbogen', description: 'Animierter mehrfarbiger Verlauf' }, gold: { name: 'Gold', description: 'LuxuriÃ¶se goldene Reflexionen' }, silver: { name: 'Silber', description: 'Metallische Silberreflexionen' }, prismatic: { name: 'Prismatisch', description: 'Brechender Kristalleffekt' }, neon: { name: 'Neon', description: 'Lebhaftes Neonleuchten' }, galaxy: { name: 'Galaxie', description: 'Sternenkosmischer Effekt' }, fire: { name: 'Flammen', description: 'Animierter Flammeneffekt' }, ice: { name: 'Frost', description: 'Funkelnder Eiseffekt' } },
        stages: ['Basis', 'Phase 1', 'Phase 2', 'Spezial', 'LegendÃ¤r', 'Mythisch', 'Ultra'],
        rarities: { common: 'GewÃ¶hnlich', uncommon: 'UngewÃ¶hnlich', rare: 'Selten', epic: 'Episch', legendary: 'LegendÃ¤r', mythic: 'Mythisch' },
        sections: { image: 'Bild', basicInfo: 'Grundinformationen', rarityEffects: 'Effekte', abilities: 'FÃ¤higkeiten', stats: 'Statistiken', appearance: 'Aussehen', cardStyle: 'Kartenstil', textStyle: 'Textstil', particles: 'Partikel', abilityStyle: 'FÃ¤higkeiten-Stil', reset: 'ZurÃ¼cksetzen' },
        labels: { name: 'Name', hp: 'Lebenspunkte', element: 'Element', stage: 'Phase', description: 'Beschreibung', author: 'Autor', rarity: 'Seltenheit', effect: 'Effekt', weakness: 'SchwÃ¤che', resistance: 'Resistenz', retreatCost: 'RÃ¼ckzugskosten', abilityName: 'FÃ¤higkeitsname', damage: 'Schaden', energyCost: 'Energiekosten', abilityDesc: 'FÃ¤higkeiten-Beschreibung', borderColor: 'Rahmenfarbe', backgroundColor: 'Kartenhintergrund', abilityBackground: 'FÃ¤higkeitshintergrund', textColor: 'Textfarbe', font: 'Schriftart', size: 'GrÃ¶ÃŸe', weight: 'Dicke', zoom: 'Zoom', presets: 'Voreinstellungen', backgroundStyle: 'Hintergrundstil', solid: 'Einfarbig', gradient: 'Verlauf', cardInner: 'Karteninneres', primaryColor: 'PrimÃ¤rfarbe', secondaryColor: 'SekundÃ¤rfarbe', nameColor: 'Namensfarbe', hpColor: 'LP-Farbe', typeColor: 'Typfarbe', descColor: 'Beschreibungsfarbe', statsColor: 'Statistikfarbe', authorColor: 'Autorenfarbe', particleEmoji: 'Partikel-Emoji', animation: 'Animation' },
        buttons: { addAbility: '+ HinzufÃ¼gen', remove: 'Entfernen', change: 'Ã„ndern', recenter: 'Zentrieren', download: 'Herunterladen', autoRotate: '3D-Ansicht', resetCard: 'ğŸ”„ ZurÃ¼cksetzen', save: 'Speichern', load: 'Laden', deleteAll: 'Alle lÃ¶schen' },
        checkboxes: { showHP: 'Lebenspunkte anzeigen', showWeakRes: 'SchwÃ¤che/Resistenz anzeigen', showRetreat: 'RÃ¼ckzugskosten anzeigen', showDescription: 'Beschreibung anzeigen', showTexture: 'Muster anzeigen', showParticles: 'Partikel anzeigen', showDamage: 'Schaden anzeigen' },
        imageEditor: { dropHint: 'Bild hier ablegen', orClick: 'oder klicken zum AuswÃ¤hlen', formats: 'PNG,JPG,GIF,WEBP (max 15MB)', loading: 'Laden...', unsupportedFormat: 'Nicht unterstÃ¼tztes Format. Verwenden Sie PNG,JPG,GIF oder WEBP.', fileTooLarge: 'Datei zu groÃŸ. Maximal 15MB.', searchPlaceholder: 'Tippen...' },
        download: { title: 'ğŸ“¥ Herunterladen', pngTitle: 'Transparentes PNG-Bild', jpgTitle: 'JPG-Bild mit Hintergrund', gifTitle: 'Animiertes GIF (3 Sekunden)', webpTitle: 'WebP-Bild', htmlTitle: 'Interaktive HTML-Datei', capturing: 'â³ Aufnahme...', encoding: 'âš™ï¸ Kodierung...' },
        card: { hp: 'KP', weakness: 'SchwÃ¤che', resistance: 'Resistenz', cost: 'Kosten', illus: 'Illus.' },
        defaults: { newAbility: 'Neue FÃ¤higkeit', cardName: 'Meine Kreatur', description: 'Eine geheimnisvolle Kreatur mit unglaublichen KrÃ¤ften.', author: 'SchÃ¶pfer', attackName1: 'Feuerball', attackDesc1: 'Wirf eine MÃ¼nze. Bei Kopf ist das verteidigende PokÃ©mon jetzt verbrannt.', attackName2: 'Flammenwurf', attackDesc2: 'Lege eine an dieses PokÃ©mon angelegte Energie auf deinen Ablagestapel.' }, notifications: { success: 'Erfolg', error: 'Fehler', info: 'Information', warning: 'Warnung' },
        display: { title: 'Anzeigeoptionen' },
        tabs: { info: 'Info', content: 'Inhalt', visual: 'Visuell', style: 'Stil', colors: 'Farben' },
        common: { cancel: 'Abbrechen', close: 'SchlieÃŸen' },
        prompts: { resetConfirm: 'Alle Kartendaten zurÃ¼cksetzen?', saveHint: 'Ihre Karte (Text + Bild) wird lokal gespeichert.', saveSuccess: 'Karte erfolgreich gespeichert!', loadConfirm: 'Diese Karte laden? Nicht gespeicherte Ã„nderungen gehen verloren.', deleteConfirm: 'Diese gespeicherte Karte lÃ¶schen?', deleteAllConfirm: 'Alle Karten lÃ¶schen? Dies kann nicht rÃ¼ckgÃ¤ngig gemacht werden.', allDeleted: 'Alle Karten gelÃ¶scht', noSaves: 'Keine gespeicherten Karten gefunden.', quotaError: 'Speicher voll! LÃ¶schen Sie alte Karten.', saveError: 'Fehler beim Speichern der Karte.', autoDeleteInfo: 'Karten werden nach 30 Tagen gelÃ¶scht.' },
        textures: { none: 'Keine', grid: 'Gitter', scales: 'Schuppen', cross: 'Kreuz', stars: 'Sterne', hexagons: 'Sechsecke', lines: 'Linien', dots: 'Punkte', waves: 'Wellen', circuit: 'Schaltung' },
        animations: { fire: 'Aufsteigend', water: 'Blasen', nature: 'Schwebend', electric: 'Funken', mystic: 'Magie', fighting: 'Einschlag', shadow: 'Verblassen', metal: 'ZahnrÃ¤der', light: 'Strahlen', dragon: 'MajestÃ¤tisch', ice: 'Schnee', neutral: 'Subtil' }
      },
      ru: {
        gifModal: {
          title: "ğŸ“¹ Ğ’Ñ‹ÑĞ¾ĞºĞ¾ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ğ°Ñ GIF-ÑÑŠĞµĞ¼ĞºĞ°",
          body: "Ğ”Ğ»Ñ Ğ¸Ğ´ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ° Ğ½Ğ°Ğ¼ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ñ‚ÑŒ ÑĞºÑ€Ğ°Ğ½:",
          step1: "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¾Ğ¿Ñ†Ğ¸Ñ <strong>\"Ğ’ĞºĞ»Ğ°Ğ´ĞºĞ°\"</strong>.",
          step2: "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ <strong>ÑÑ‚Ñƒ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ</strong> Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ°.",
          step3: "ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ <strong>\"ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ\"</strong>.",
          note: "ĞœÑ‹ÑˆÑŒ Ğ±ÑƒĞ´ĞµÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑĞºÑ€Ñ‹Ñ‚Ğ°, Ğ° ĞºĞ°Ñ€Ñ‚Ğ° Ğ¾Ğ±Ñ€ĞµĞ·Ğ°Ğ½Ğ°.",
          warning: "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº (60 FPS / 4K) Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ·Ğ°Ğ½ÑÑ‚ÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ñ€ĞµÑÑƒÑ€ÑĞ¾Ğ² Ğ¦ĞŸ.",
          fpsLabel: "FPS",
          qualityLabel: "ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ (Ğ’Ñ‹ÑĞ¾Ñ‚Ğ°)",
          fpsNormal: "15 FPS (ĞĞ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾)",
          fpsCinema: "24 FPS (ĞšĞ¸Ğ½Ğ¾)",
          fpsSmooth: "30 FPS (ĞŸĞ»Ğ°Ğ²Ğ½o)",
          fpsUltra: "60 FPS (Ğ£Ğ»ÑŒÑ‚Ñ€Ğ°)",
          qualitySD: "480p (SD)",
          qualityNormal: "720p (HD)",
          qualityHigh: "1080p (Full HD)",
          qualityQHD: "1440p (QHD)",
          qualityUltra: "4K (UHD)",
          cancel: "ĞÑ‚Ğ¼ĞµĞ½Ğ°",
          start: "ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚", loadingLibs: "â³ Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°...", capturing: "ğŸ“¸ Ğ—Ğ°Ñ…Ğ²Ğ°Ñ‚...", encoding: "âš™ï¸ ĞšĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ..."
        },
        appTitle: 'Card Creator',
        appSubtitle: 'Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ğ¹Ñ‚Ğµ ÑĞ²Ğ¾Ğ¸ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ¾Ğ»Ğ»ĞµĞºÑ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹',
        hoverHint: 'âœ¨ ĞĞ°Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ° ĞºĞ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ ÑƒÑĞ¸Ğ»Ğ¸Ñ‚ÑŒ ÑÑ„Ñ„ĞµĞºÑ‚ âœ¨',
        elements: { Fire: 'ĞĞ³Ğ¾Ğ½ÑŒ', Water: 'Ğ’Ğ¾Ğ´Ğ°', Nature: 'ĞŸÑ€Ğ¸Ñ€Ğ¾Ğ´Ğ°', Electric: 'Ğ­Ğ»ĞµĞºÑ‚Ñ€Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾', Mystic: 'ĞœĞ¸ÑÑ‚Ğ¸ĞºĞ°', Fighting: 'Ğ‘Ğ¾ĞµĞ²Ğ¾Ğ¹', Shadow: 'Ğ¢ĞµĞ½ÑŒ', Metal: 'ĞœĞµÑ‚Ğ°Ğ»Ğ»', Light: 'Ğ¡Ğ²ĞµÑ‚', Dragon: 'Ğ”Ñ€Ğ°ĞºĞ¾Ğ½', Ice: 'Ğ›Ñ‘Ğ´', Neutral: 'ĞĞµĞ¹Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹' },
        effects: { none: { name: 'ĞĞµÑ‚', description: 'Ğ‘ĞµĞ· ÑÑ„Ñ„ĞµĞºÑ‚Ğ°' }, holographic: { name: 'Ğ“Ğ¾Ğ»Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹', description: 'ĞšĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ñ€Ğ°Ğ´ÑƒĞ¶Ğ½Ñ‹Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚' }, rainbow: { name: 'Ğ Ğ°Ğ´ÑƒĞ³Ğ°', description: 'ĞĞ½Ğ¸Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ñ†Ğ²ĞµÑ‚Ğ½Ñ‹Ğ¹ Ğ³Ñ€Ğ°Ğ´Ğ¸ĞµĞ½Ñ‚' }, gold: { name: 'Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ¾', description: 'Ğ Ğ¾ÑĞºĞ¾ÑˆĞ½Ñ‹Ğµ Ğ·Ğ¾Ğ»Ğ¾Ñ‚Ñ‹Ğµ Ğ¾Ñ‚Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ' }, silver: { name: 'Ğ¡ĞµÑ€ĞµĞ±Ñ€Ğ¾', description: 'ĞœĞµÑ‚Ğ°Ğ»Ğ»Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑĞµÑ€ĞµĞ±Ñ€ÑĞ½Ñ‹Ğµ Ğ¾Ñ‚Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ' }, prismatic: { name: 'ĞŸÑ€Ğ¸Ğ·Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹', description: 'Ğ­Ñ„Ñ„ĞµĞºÑ‚ Ğ¿Ñ€ĞµĞ»Ğ¾Ğ¼Ğ»ÑÑÑ‰ĞµĞ³Ğ¾ ĞºÑ€Ğ¸ÑÑ‚Ğ°Ğ»Ğ»Ğ°' }, neon: { name: 'ĞĞµĞ¾Ğ½', description: 'Ğ¯Ñ€ĞºĞ¾Ğµ Ğ½ĞµĞ¾Ğ½Ğ¾Ğ²Ğ¾Ğµ ÑĞ²ĞµÑ‡ĞµĞ½Ğ¸Ğµ' }, galaxy: { name: 'Ğ“Ğ°Ğ»Ğ°ĞºÑ‚Ğ¸ĞºĞ°', description: 'Ğ—Ğ²Ñ‘Ğ·Ğ´Ğ½Ñ‹Ğ¹ ĞºĞ¾ÑĞ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚' }, fire: { name: 'ĞŸĞ»Ğ°Ğ¼Ñ', description: 'ĞĞ½Ğ¸Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚ Ğ¾Ğ³Ğ½Ñ' }, ice: { name: 'Ğ›Ñ‘Ğ´', description: 'Ğ¡Ğ²ĞµÑ€ĞºĞ°ÑÑ‰Ğ¸Ğ¹ Ğ»ĞµĞ´ÑĞ½Ğ¾Ğ¹ ÑÑ„Ñ„ĞµĞºÑ‚' } },
        stages: ['Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹', 'Ğ¡Ñ‚Ğ°Ğ´Ğ¸Ñ 1', 'Ğ¡Ñ‚Ğ°Ğ´Ğ¸Ñ 2', 'ĞÑĞ¾Ğ±Ñ‹Ğ¹', 'Ğ›ĞµĞ³ĞµĞ½Ğ´Ğ°Ñ€Ğ½Ñ‹Ğ¹', 'ĞœĞ¸Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹', 'Ğ£Ğ»ÑŒÑ‚Ñ€Ğ°'],
        rarities: { common: 'ĞĞ±Ñ‹Ñ‡Ğ½Ğ°Ñ', uncommon: 'ĞĞµĞ¾Ğ±Ñ‹Ñ‡Ğ½Ğ°Ñ', rare: 'Ğ ĞµĞ´ĞºĞ°Ñ', epic: 'Ğ­Ğ¿Ğ¸Ñ‡ĞµÑĞºĞ°Ñ', legendary: 'Ğ›ĞµĞ³ĞµĞ½Ğ´Ğ°Ñ€Ğ½Ğ°Ñ', mythic: 'ĞœĞ¸Ñ„Ğ¸Ñ‡ĞµÑĞºĞ°Ñ' },
        sections: { image: 'Ğ˜Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ', basicInfo: 'ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ', rarityEffects: 'Ğ­Ñ„Ñ„ĞµĞºÑ‚Ñ‹', abilities: 'Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸', stats: 'Ğ¥Ğ°Ñ€Ğ°ĞºÑ‚ĞµÑ€Ğ¸ÑÑ‚Ğ¸ĞºĞ¸', appearance: 'Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ Ğ²Ğ¸Ğ´', cardStyle: 'Ğ¡Ñ‚Ğ¸Ğ»ÑŒ ĞºĞ°Ñ€Ñ‚Ñ‹', textStyle: 'Ğ¡Ñ‚Ğ¸Ğ»ÑŒ Ñ‚ĞµĞºÑÑ‚Ğ°', particles: 'Ğ§Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹', abilityStyle: 'Ğ¡Ñ‚Ğ¸Ğ»ÑŒ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚ĞµĞ¹', reset: 'Ğ¡Ğ±Ñ€Ğ¾Ñ' },
        labels: { name: 'Ğ˜Ğ¼Ñ', hp: 'ĞÑ‡ĞºĞ¸ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ', element: 'Ğ­Ğ»ĞµĞ¼ĞµĞ½Ñ‚', stage: 'Ğ¡Ñ‚Ğ°Ğ´Ğ¸Ñ', description: 'ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ', author: 'ĞĞ²Ñ‚Ğ¾Ñ€', rarity: 'Ğ ĞµĞ´ĞºĞ¾ÑÑ‚ÑŒ', effect: 'Ğ­Ñ„Ñ„ĞµĞºÑ‚', weakness: 'Ğ¡Ğ»Ğ°Ğ±Ğ¾ÑÑ‚ÑŒ', resistance: 'Ğ¡Ğ¾Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ»ĞµĞ½Ğ¸Ğµ', retreatCost: 'Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ñ', abilityName: 'ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸', damage: 'Ğ£Ñ€Ğ¾Ğ½', energyCost: 'Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ ÑĞ½ĞµÑ€Ğ³Ğ¸Ğ¸', abilityDesc: 'ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚ĞµĞ¹', borderColor: 'Ğ¦Ğ²ĞµÑ‚ Ñ€Ğ°Ğ¼ĞºĞ¸', backgroundColor: 'Ğ¤Ğ¾Ğ½ ĞºĞ°Ñ€Ñ‚Ñ‹', abilityBackground: 'Ğ¤Ğ¾Ğ½ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸', textColor: 'Ğ¦Ğ²ĞµÑ‚ Ñ‚ĞµĞºÑÑ‚Ğ°', font: 'Ğ¨Ñ€Ğ¸Ñ„Ñ‚', size: 'Ğ Ğ°Ğ·Ğ¼ĞµÑ€', weight: 'Ğ’ĞµÑ', zoom: 'ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±', presets: 'ĞŸÑ€ĞµĞ´ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸', backgroundStyle: 'Ğ¡Ñ‚Ğ¸Ğ»ÑŒ Ñ„Ğ¾Ğ½Ğ°', solid: 'Ğ¡Ğ¿Ğ»Ğ¾ÑˆĞ½Ğ¾Ğ¹', gradient: 'Ğ“Ñ€Ğ°Ğ´Ğ¸ĞµĞ½Ñ‚', cardInner: 'Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ÑÑ Ñ‡Ğ°ÑÑ‚ÑŒ ĞºĞ°Ñ€Ñ‚Ñ‹', primaryColor: 'ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ²ĞµÑ‚', secondaryColor: 'Ğ’Ñ‚Ğ¾Ñ€Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ñ†Ğ²ĞµÑ‚', nameColor: 'Ğ¦Ğ²ĞµÑ‚ Ğ¸Ğ¼ĞµĞ½Ğ¸', hpColor: 'Ğ¦Ğ²ĞµÑ‚ ĞĞ—', typeColor: 'Ğ¦Ğ²ĞµÑ‚ Ñ‚Ğ¸Ğ¿Ğ°', descColor: 'Ğ¦Ğ²ĞµÑ‚ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ', statsColor: 'Ğ¦Ğ²ĞµÑ‚ Ñ…Ğ°Ñ€-Ğº', authorColor: 'Ğ¦Ğ²ĞµÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ°', particleEmoji: 'Ğ­Ğ¼Ğ¾Ğ´Ğ·Ğ¸ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ†', animation: 'ĞĞ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ñ' },
        buttons: { addAbility: '+ Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ', remove: 'Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ', change: 'Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ', recenter: 'Ğ¦ĞµĞ½Ñ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ', download: 'Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ', autoRotate: '3D-Ğ²Ğ¸Ğ´', resetCard: 'ğŸ”„ Ğ¡Ğ±Ñ€Ğ¾Ñ', save: 'Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ', load: 'Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ', deleteAll: 'Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ' },
        checkboxes: { showHP: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¾Ñ‡ĞºĞ¸ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ', showWeakRes: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ»Ğ°Ğ±Ğ¾ÑÑ‚ÑŒ/ÑĞ¾Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ»ĞµĞ½Ğ¸Ğµ', showRetreat: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ñ', showDescription: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ', showTexture: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑÑ‚ÑƒÑ€Ñƒ', showParticles: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ†Ñ‹', showDamage: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑƒÑ€Ğ¾Ğ½' },
        imageEditor: { dropHint: 'ĞŸĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚Ğµ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑÑĞ´Ğ°', orClick: 'Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°', formats: 'PNG,JPG,GIF,WEBP (Ğ¼Ğ°ĞºÑ 15ĞœĞ‘)', loading: 'Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°...', unsupportedFormat: 'ĞĞµĞ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµĞ¼Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ PNG,JPG,GIF Ğ¸Ğ»Ğ¸ WEBP.', fileTooLarge: 'Ğ¤Ğ°Ğ¹Ğ» ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹. ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 15ĞœĞ‘.', searchPlaceholder: 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ...' },
        download: { title: 'ğŸ“¥ Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ', pngTitle: 'ĞŸÑ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾Ğµ PNG Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ', jpgTitle: 'JPG Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ñ Ñ„Ğ¾Ğ½Ğ¾Ğ¼', gifTitle: 'ĞĞ½Ğ¸Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ GIF (3 ÑĞµĞºÑƒĞ½Ğ´Ñ‹)', webpTitle: 'WebP Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ', htmlTitle: 'Ğ˜Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ HTML Ñ„Ğ°Ğ¹Ğ»', capturing: 'â³ Ğ—Ğ°Ñ…Ğ²Ğ°Ñ‚...', encoding: 'âš™ï¸ ĞšĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ...' },
        card: { hp: 'ĞĞ—', weakness: 'Ğ¡Ğ»Ğ°Ğ±Ğ¾ÑÑ‚ÑŒ', resistance: 'Ğ¡Ğ¾Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ»ĞµĞ½Ğ¸Ğµ', cost: 'Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ', illus: 'Ğ¥ÑƒĞ´.' },
        defaults: { newAbility: 'ĞĞ¾Ğ²Ğ°Ñ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚ÑŒ', cardName: 'ĞœĞ¾Ñ‘ Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾', description: 'Ğ¢Ğ°Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾ Ñ Ğ½ĞµĞ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ñ‹Ğ¼Ğ¸ ÑĞ¸Ğ»Ğ°Ğ¼Ğ¸.', author: 'Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ĞµĞ»ÑŒ', attackName1: 'ĞĞ³Ğ½ĞµĞ½Ğ½Ñ‹Ğ¹ ÑˆĞ°Ñ€', attackDesc1: 'ĞŸĞ¾Ğ´Ğ±Ñ€Ğ¾ÑÑŒÑ‚Ğµ Ğ¼Ğ¾Ğ½ĞµÑ‚Ñƒ. Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹Ğ¿Ğ°Ğ´ĞµÑ‚ Ğ¾Ñ€ĞµĞ», Ğ—Ğ°Ñ‰Ğ¸Ñ‰Ğ°ÑÑ‰Ğ¸Ğ¹ÑÑ Ğ¿Ğ¾ĞºĞµĞ¼Ğ¾Ğ½ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ğ±Ğ¾Ğ¶Ğ¶ĞµĞ½.', attackName2: 'ĞĞ³Ğ½ĞµĞ¼ĞµÑ‚', attackDesc2: 'Ğ¡Ğ±Ñ€Ğ¾ÑÑŒÑ‚Ğµ Ğ­Ğ½ĞµÑ€Ğ³Ğ¸Ñ, Ğ¿Ñ€Ğ¸ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ½ÑƒÑ Ğº ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾ĞºĞµĞ¼Ğ¾Ğ½Ñƒ.' }, notifications: { success: 'Ğ£ÑĞ¿ĞµÑ…', error: 'ĞÑˆĞ¸Ğ±ĞºĞ°', info: 'Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ', warning: 'ĞŸÑ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ' },
        display: { title: 'ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ' },
        tabs: { info: 'Ğ˜Ğ½Ñ„Ğ¾', content: 'Ğ¡Ğ¾Ğ´ĞµÑ€Ğ¶Ğ°Ğ½Ğ¸Ğµ', visual: 'Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»', style: 'Ğ¡Ñ‚Ğ¸Ğ»ÑŒ', colors: 'Ğ¦Ğ²ĞµÑ‚Ğ°' },
        common: { cancel: 'ĞÑ‚Ğ¼ĞµĞ½Ğ°', close: 'Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ' },
        prompts: { resetConfirm: 'Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹?', saveHint: 'Ğ’Ğ°ÑˆĞ° ĞºĞ°Ñ€Ñ‚Ğ° (Ñ‚ĞµĞºÑÑ‚ + Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ) Ğ±ÑƒĞ´ĞµÑ‚ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ° Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾.', saveSuccess: 'ĞšĞ°Ñ€Ñ‚Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ°!', loadConfirm: 'Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ ÑÑ‚Ñƒ ĞºĞ°Ñ€Ñ‚Ñƒ? ĞĞµÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ñ‹.', deleteConfirm: 'Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ ÑÑ‚Ñƒ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½ÑƒÑ ĞºĞ°Ñ€Ñ‚Ñƒ?', deleteAllConfirm: 'Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ ĞºĞ°Ñ€Ñ‚Ñ‹? Ğ­Ñ‚Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ.', allDeleted: 'Ğ’ÑĞµ ĞºĞ°Ñ€Ñ‚Ñ‹ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ñ‹', noSaves: 'Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹.', quotaError: 'Ğ¥Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾! Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚Ğµ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹.', saveError: 'ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ ĞºĞ°Ñ€Ñ‚Ñ‹.', autoDeleteInfo: 'ĞšĞ°Ñ€Ñ‚Ñ‹ ÑƒĞ´Ğ°Ğ»ÑÑÑ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· 30 Ğ´Ğ½ĞµĞ¹.' },
        textures: { none: 'ĞĞµÑ‚', grid: 'Ğ¡ĞµÑ‚ĞºĞ°', scales: 'Ğ§ĞµÑˆÑƒÑ', cross: 'ĞšÑ€ĞµÑÑ‚', stars: 'Ğ—Ğ²ĞµĞ·Ğ´Ñ‹', hexagons: 'Ğ¨ĞµÑÑ‚Ğ¸ÑƒĞ³Ğ¾Ğ»ÑŒĞ½Ğ¸ĞºĞ¸', lines: 'Ğ›Ğ¸Ğ½Ğ¸Ğ¸', dots: 'Ğ¢Ğ¾Ñ‡ĞºĞ¸', waves: 'Ğ’Ğ¾Ğ»Ğ½Ñ‹', circuit: 'Ğ¡Ñ…ĞµĞ¼Ğ°' },
        animations: { fire: 'Ğ’Ğ¾ÑÑ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğ¹', water: 'ĞŸÑƒĞ·Ñ‹Ñ€Ğ¸', nature: 'ĞŸĞ°Ñ€ÑÑ‰Ğ¸Ğ¹', electric: 'Ğ˜ÑĞºÑ€Ñ‹', mystic: 'ĞœĞ°Ğ³Ğ¸Ñ', fighting: 'Ğ£Ğ´Ğ°Ñ€', shadow: 'Ğ—Ğ°Ñ‚ÑƒÑ…Ğ°Ğ½Ğ¸Ğµ', metal: 'Ğ¨ĞµÑÑ‚ĞµÑ€ĞµĞ½ĞºĞ¸', light: 'Ğ¡Ğ¸ÑĞ½Ğ¸Ğµ', dragon: 'Ğ’ĞµĞ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹', ice: 'Ğ¡Ğ½ĞµĞ³', neutral: 'Ğ¢Ğ¾Ğ½ĞºĞ¸Ğ¹' }
      },
      ja: {
        gifModal: {
          title: "ğŸ“¹ é«˜å“è³ªGIFã‚­ãƒ£ãƒ—ãƒãƒ£",
          body: "å®Œç’§ãªçµæœã‚’å¾—ã‚‹ãŸã‚ã«ã€ç”»é¢ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š",
          step1: "<strong>ã€Œã‚¿ãƒ–ã€</strong>ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¾ã™ã€‚",
          step2: "ãƒªã‚¹ãƒˆã‹ã‚‰<strong>ã“ã®ãƒšãƒ¼ã‚¸</strong>ã‚’é¸æŠã—ã¾ã™ã€‚",
          step3: "<strong>ã€Œå…±æœ‰ã€</strong>ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚",
          note: "ãƒã‚¦ã‚¹ã¯è‡ªå‹•çš„ã«éè¡¨ç¤ºã«ãªã‚Šã€ã‚«ãƒ¼ãƒ‰ã¯åˆ‡ã‚Šå–ã‚‰ã‚Œã¾ã™ã€‚",
          warning: "æœ€å¤§è¨­å®šï¼ˆ60 FPS / 4Kï¼‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€æ™‚é–“ãŒã‹ã‹ã‚Šã€CPUä½¿ç”¨ç‡ãŒé«˜ããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚",
          fpsLabel: "FPS",
          qualityLabel: "å“è³ª (é«˜ã•)",
          fpsNormal: "15 FPS (é€šå¸¸)",
          fpsCinema: "24 FPS (ã‚·ãƒãƒ)",
          fpsSmooth: "30 FPS (ã‚¹ãƒ ãƒ¼ã‚º)",
          fpsUltra: "60 FPS (ã‚¦ãƒ«ãƒˆãƒ©)",
          qualitySD: "480p (æ¨™æº–)",
          qualityNormal: "720p (é«˜ç”»è³ª)",
          qualityHigh: "1080p (ãƒ•ãƒ«HD)",
          qualityQHD: "1440p (2K)",
          qualityUltra: "4K (è¶…é«˜ç”»è³ª)",
          cancel: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
          start: "ã‚­ãƒ£ãƒ—ãƒãƒ£é–‹å§‹", loadingLibs: "â³ èª­ã¿è¾¼ã¿ä¸­...", capturing: "ğŸ“¸ ã‚­ãƒ£ãƒ—ãƒãƒ£ä¸­...", encoding: "âš™ï¸ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­..."
        },
        appTitle: 'Card Creator',
        appSubtitle: 'ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã‚ˆã†',
        hoverHint: 'âœ¨ ã‚«ãƒ¼ãƒ‰ã«ãƒã‚¦ã‚¹ã‚’ä¹—ã›ã‚‹ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå¼·ããªã‚Šã¾ã™ âœ¨',
        elements: { Fire: 'ç‚', Water: 'æ°´', Nature: 'è‡ªç„¶', Electric: 'é›»æ°—', Mystic: 'ç¥ç§˜', Fighting: 'æ ¼é—˜', Shadow: 'é—‡', Metal: 'é‹¼', Light: 'å…‰', Dragon: 'ãƒ‰ãƒ©ã‚´ãƒ³', Ice: 'æ°·', Neutral: 'ç„¡' },
        effects: { none: { name: 'ãªã—', description: 'ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã—' }, holographic: { name: 'ãƒ›ãƒ­ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯', description: 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯ãªè™¹è‰²ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' }, rainbow: { name: 'ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼', description: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ©ãƒ¼ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³' }, gold: { name: 'ã‚´ãƒ¼ãƒ«ãƒ‰', description: 'è±ªè¯ãªé‡‘è‰²ã®åå°„' }, silver: { name: 'ã‚·ãƒ«ãƒãƒ¼', description: 'ãƒ¡ã‚¿ãƒªãƒƒã‚¯ãªéŠ€è‰²ã®åå°„' }, prismatic: { name: 'ãƒ—ãƒªã‚ºãƒãƒ†ã‚£ãƒƒã‚¯', description: 'å±ˆæŠ˜ã™ã‚‹ã‚¯ãƒªã‚¹ã‚¿ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' }, neon: { name: 'ãƒã‚ªãƒ³', description: 'é®®ã‚„ã‹ãªãƒã‚ªãƒ³ã®è¼ã' }, galaxy: { name: 'ã‚®ãƒ£ãƒ©ã‚¯ã‚·ãƒ¼', description: 'æ˜Ÿç©ºã®å®‡å®™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' }, fire: { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ', description: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' }, ice: { name: 'ãƒ•ãƒ­ã‚¹ãƒˆ', description: 'ãã‚‰ã‚ãæ°·ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' } },
        stages: ['ãƒ™ãƒ¼ã‚·ãƒƒã‚¯', 'ã‚¹ãƒ†ãƒ¼ã‚¸1', 'ã‚¹ãƒ†ãƒ¼ã‚¸2', 'ã‚¹ãƒšã‚·ãƒ£ãƒ«', 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼', 'ãƒŸã‚·ãƒƒã‚¯', 'ã‚¦ãƒ«ãƒˆãƒ©'],
        rarities: { common: 'ã‚³ãƒ¢ãƒ³', uncommon: 'ã‚¢ãƒ³ã‚³ãƒ¢ãƒ³', rare: 'ãƒ¬ã‚¢', epic: 'ã‚¨ãƒ”ãƒƒã‚¯', legendary: 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼', mythic: 'ãƒŸã‚·ãƒƒã‚¯' },
        sections: { image: 'ç”»åƒ', basicInfo: 'åŸºæœ¬æƒ…å ±', rarityEffects: 'ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ', abilities: 'æŠ€', stats: 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹', appearance: 'å¤–è¦³', cardStyle: 'ã‚«ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«', textStyle: 'ãƒ†ã‚­ã‚¹ãƒˆã‚¹ã‚¿ã‚¤ãƒ«', particles: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«', abilityStyle: 'æŠ€ã®ã‚¹ã‚¿ã‚¤ãƒ«', reset: 'ãƒªã‚»ãƒƒãƒˆ' },
        labels: { name: 'åå‰', hp: 'HP', element: 'ã‚¿ã‚¤ãƒ—', stage: 'ã‚¹ãƒ†ãƒ¼ã‚¸', description: 'èª¬æ˜', author: 'ä½œè€…', rarity: 'ãƒ¬ã‚¢ãƒªãƒ†ã‚£', effect: 'ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ', weakness: 'å¼±ç‚¹', resistance: 'æŠµæŠ—åŠ›', retreatCost: 'ã«ã’ã‚‹ã‚³ã‚¹ãƒˆ', abilityName: 'æŠ€å', damage: 'ãƒ€ãƒ¡ãƒ¼ã‚¸', energyCost: 'ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚³ã‚¹ãƒˆ', abilityDesc: 'æŠ€ã®èª¬æ˜', borderColor: 'æ ã®è‰²', backgroundColor: 'ã‚«ãƒ¼ãƒ‰ã®èƒŒæ™¯', abilityBackground: 'æŠ€ã®èƒŒæ™¯', textColor: 'æ–‡å­—è‰²', font: 'ãƒ•ã‚©ãƒ³ãƒˆ', size: 'ã‚µã‚¤ã‚º', weight: 'å¤ªã•', zoom: 'ã‚ºãƒ¼ãƒ ', presets: 'ãƒ—ãƒªã‚»ãƒƒãƒˆ', backgroundStyle: 'èƒŒæ™¯ã‚¹ã‚¿ã‚¤ãƒ«', solid: 'å˜è‰²', gradient: 'ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³', cardInner: 'ã‚«ãƒ¼ãƒ‰å†…å´', primaryColor: 'ãƒ¡ã‚¤ãƒ³ã‚«ãƒ©ãƒ¼', secondaryColor: 'ã‚µãƒ–ã‚«ãƒ©ãƒ¼', nameColor: 'åå‰ã®è‰²', hpColor: 'HPã®è‰²', typeColor: 'ã‚¿ã‚¤ãƒ—ã®è‰²', descColor: 'èª¬æ˜ã®è‰²', statsColor: 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®è‰²', authorColor: 'ä½œè€…ã®è‰²', particleEmoji: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«çµµæ–‡å­—', animation: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³' },
        buttons: { addAbility: '+ è¿½åŠ ', remove: 'å‰Šé™¤', change: 'å¤‰æ›´', recenter: 'ä¸­å¤®æƒãˆ', download: 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰', autoRotate: '3Dãƒ“ãƒ¥ãƒ¼', resetCard: 'ğŸ”„ ãƒªã‚»ãƒƒãƒˆ', save: 'ä¿å­˜', load: 'èª­ã¿è¾¼ã¿', deleteAll: 'ã™ã¹ã¦å‰Šé™¤' },
        checkboxes: { showHP: 'HPã‚’è¡¨ç¤º', showWeakRes: 'å¼±ç‚¹/æŠµæŠ—åŠ›ã‚’è¡¨ç¤º', showRetreat: 'ã«ã’ã‚‹ã‚³ã‚¹ãƒˆã‚’è¡¨ç¤º', showDescription: 'èª¬æ˜ã‚’è¡¨ç¤º', showTexture: 'ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¡¨ç¤º', showParticles: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¡¨ç¤º', showDamage: 'ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è¡¨ç¤º' },
        imageEditor: { dropHint: 'ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—', orClick: 'ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ', formats: 'PNG,JPG,GIF,WEBP (æœ€å¤§15MB)', loading: 'èª­ã¿è¾¼ã¿ä¸­...', unsupportedFormat: 'ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å½¢å¼ã§ã™ã€‚PNGã€JPGã€GIFã€WEBPã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚', fileTooLarge: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤§ãã™ãã¾ã™ã€‚æœ€å¤§15MBã§ã™ã€‚', searchPlaceholder: 'å…¥åŠ›...' },
        download: { title: 'ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰', pngTitle: 'é€éPNGç”»åƒ', jpgTitle: 'èƒŒæ™¯ä»˜ãJPGç”»åƒ', gifTitle: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³GIFï¼ˆ3ç§’ï¼‰', webpTitle: 'WebPç”»åƒ', htmlTitle: 'ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–HTMLãƒ•ã‚¡ã‚¤ãƒ«', capturing: 'â³ ã‚­ãƒ£ãƒ—ãƒãƒ£ä¸­...', encoding: 'âš™ï¸ ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ä¸­...' },
        card: { hp: 'HP', weakness: 'å¼±ç‚¹', resistance: 'æŠµæŠ—åŠ›', cost: 'ã‚³ã‚¹ãƒˆ', illus: 'ã‚¤ãƒ©ã‚¹ãƒˆ' },
        defaults: { newAbility: 'æ–°ã—ã„æŠ€', cardName: 'ãƒã‚¤ãƒ»ã‚¯ãƒªãƒ¼ãƒãƒ£ãƒ¼', description: 'ä¿¡ã˜ã‚‰ã‚Œãªã„ã»ã©ã®åŠ›ã‚’æŒã¤ç¥ç§˜çš„ãªç”Ÿãç‰©ã€‚', author: 'ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼', attackName1: 'ç«ã®ç‰', attackDesc1: 'ã‚³ã‚¤ãƒ³ã‚’1å›æŠ•ã’ã‚‹ã€‚ã‚ªãƒ¢ãƒ†ãªã‚‰ã€ç›¸æ‰‹ã®ãƒãƒˆãƒ«ãƒã‚±ãƒ¢ãƒ³ã‚’ã‚„ã‘ã©ã«ã™ã‚‹ã€‚', attackName2: 'ã‹ãˆã‚“ã»ã†ã—ã‚ƒ', attackDesc2: 'ã“ã®ãƒã‚±ãƒ¢ãƒ³ã«ã¤ã„ã¦ã„ã‚‹ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’1å€‹é¸ã³ã€ãƒˆãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã€‚' }, notifications: { success: 'æˆåŠŸ', error: 'ã‚¨ãƒ©ãƒ¼', info: 'æƒ…å ±', warning: 'è­¦å‘Š' },
        display: { title: 'è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³' },
        tabs: { info: 'æƒ…å ±', content: 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„', visual: 'ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«', style: 'ã‚¹ã‚¿ã‚¤ãƒ«', colors: 'è‰²' },
        common: { cancel: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«', close: 'é–‰ã˜ã‚‹' },
        prompts: { resetConfirm: 'ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ', saveHint: 'ã‚«ãƒ¼ãƒ‰ï¼ˆãƒ†ã‚­ã‚¹ãƒˆ + ç”»åƒï¼‰ãŒãƒ­ãƒ¼ã‚«ãƒ«ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚', saveSuccess: 'ã‚«ãƒ¼ãƒ‰ãŒæ­£å¸¸ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸï¼', loadConfirm: 'ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿæœªä¿å­˜ã®å¤‰æ›´ã¯å¤±ã‚ã‚Œã¾ã™ã€‚', deleteConfirm: 'ã“ã®ä¿å­˜æ¸ˆã¿ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ', deleteAllConfirm: 'ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚', allDeleted: 'ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ', noSaves: 'ä¿å­˜æ¸ˆã¿ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚', quotaError: 'ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒã„ã£ã±ã„ã§ã™ï¼å¤ã„ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚', saveError: 'ã‚«ãƒ¼ãƒ‰ã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', autoDeleteInfo: 'ä¿å­˜ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã¯30æ—¥å¾Œã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚' },
        textures: { none: 'ãªã—', grid: 'ã‚°ãƒªãƒƒãƒ‰', scales: 'é±—', cross: 'ã‚¯ãƒ­ã‚¹', stars: 'æ˜Ÿ', hexagons: 'ãƒ˜ã‚­ã‚µã‚´ãƒ³', lines: 'ãƒ©ã‚¤ãƒ³', dots: 'ãƒ‰ãƒƒãƒˆ', waves: 'ã‚¦ã‚§ãƒ¼ãƒ–', circuit: 'å›è·¯' },
        animations: { fire: 'ä¸Šæ˜‡', water: 'æ³¡', nature: 'æµ®éŠ', electric: 'ç«èŠ±', mystic: 'é­”æ³•', fighting: 'è¡æ’ƒ', shadow: 'ãƒ•ã‚§ãƒ¼ãƒ‰', metal: 'æ­¯è»Š', light: 'æ”¾å°„', dragon: 'å¨å³', ice: 'é›ª', neutral: 'å¾®ç´°' }
      },
      zh: {
        gifModal: {
          title: "ğŸ“¹ é«˜è´¨é‡GIFæ•è·",
          body: "ä¸ºäº†è·å¾—å®Œç¾çš„æ•ˆæœï¼Œæˆ‘ä»¬éœ€è¦æ•è·å±å¹•ï¼š",
          step1: "é€‰æ‹© <strong>ã€Œæ ‡ç­¾é¡µã€</strong> é€‰é¡¹ã€‚",
          step2: "ä»åˆ—è¡¨ä¸­é€‰æ‹© <strong>æ­¤é¡µé¢</strong>ã€‚",
          step3: "ç‚¹å‡» <strong>ã€Œåˆ†äº«ã€</strong>ã€‚",
          note: "é¼ æ ‡å°†è‡ªåŠ¨éšè—ï¼Œå¡ç‰‡å°†è¢«è£å‰ªã€‚",
          warning: "ä½¿ç”¨æœ€å¤§è®¾ç½®ï¼ˆ60 FPS / 4Kï¼‰å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´å¹¶å ç”¨å¤§é‡CPUã€‚",
          fpsLabel: "FPS",
          qualityLabel: "è´¨é‡ (é«˜åº¦)",
          fpsNormal: "15 FPS (æ­£å¸¸)",
          fpsCinema: "24 FPS (ç”µå½±)",
          fpsSmooth: "30 FPS (æµç•…)",
          fpsUltra: "60 FPS (è¶…é«˜)",
          qualitySD: "480p (æ ‡æ¸…)",
          qualityNormal: "720p (é«˜æ¸…)",
          qualityHigh: "1080p (å…¨é«˜æ¸…)",
          qualityQHD: "1440p (2Kè¶…æ¸…)",
          qualityUltra: "4K (è¶…é«˜æ¸…)",
          cancel: "å–æ¶ˆ",
          start: "å¼€å§‹æ•è·", loadingLibs: "â³ åŠ è½½ä¸­...", capturing: "ğŸ“¸ æ•è·ä¸­...", encoding: "âš™ï¸ ç¼–ç ä¸­..."
        },
        appTitle: 'Card Creator',
        appSubtitle: 'åˆ›å»ºæ‚¨è‡ªå·±çš„ä¸ªæ€§åŒ–æ”¶è—å¡',
        hoverHint: 'âœ¨ å°†é¼ æ ‡æ‚¬åœåœ¨å¡ç‰‡ä¸Šä»¥å¢å¼ºæ•ˆæœ âœ¨',
        elements: { Fire: 'ç«', Water: 'æ°´', Nature: 'è‡ªç„¶', Electric: 'ç”µ', Mystic: 'ç¥ç§˜', Fighting: 'æ ¼æ–—', Shadow: 'æš—', Metal: 'é’¢', Light: 'å…‰', Dragon: 'é¾™', Ice: 'å†°', Neutral: 'æ— ' },
        effects: { none: { name: 'æ— ', description: 'æ— æ•ˆæœ' }, holographic: { name: 'å…¨æ¯', description: 'ç»å…¸å½©è™¹æ•ˆæœ' }, rainbow: { name: 'å½©è™¹', description: 'åŠ¨ç”»å¤šè‰²æ¸å˜' }, gold: { name: 'é‡‘è‰²', description: 'å¥¢åé‡‘è‰²åå°„' }, silver: { name: 'é“¶è‰²', description: 'é‡‘å±é“¶è‰²åå°„' }, prismatic: { name: 'æ£±é•œ', description: 'æŠ˜å°„æ°´æ™¶æ•ˆæœ' }, neon: { name: 'éœ“è™¹', description: 'é²œè‰³éœ“è™¹å…‰èŠ’' }, galaxy: { name: 'æ˜Ÿç³»', description: 'æ˜Ÿç©ºå®‡å®™æ•ˆæœ' }, fire: { name: 'ç«ç„°', description: 'åŠ¨ç”»ç«ç„°æ•ˆæœ' }, ice: { name: 'å†°éœœ', description: 'é—ªçƒå†°æ™¶æ•ˆæœ' } },
        stages: ['åŸºç¡€', 'é˜¶æ®µ1', 'é˜¶æ®µ2', 'ç‰¹æ®Š', 'ä¼ è¯´', 'ç¥è¯', 'ç©¶æ'],
        rarities: { common: 'æ™®é€š', uncommon: 'ç¨€æœ‰', rare: 'çè´µ', epic: 'å²è¯—', legendary: 'ä¼ è¯´', mythic: 'ç¥è¯' },
        sections: { image: 'å›¾ç‰‡', basicInfo: 'åŸºæœ¬ä¿¡æ¯', rarityEffects: 'æ•ˆæœ', abilities: 'æŠ€èƒ½', stats: 'å±æ€§', appearance: 'å¤–è§‚', cardStyle: 'å¡ç‰‡æ ·å¼', textStyle: 'æ–‡æœ¬æ ·å¼', particles: 'ç²’å­ç³»ç»Ÿ', abilityStyle: 'æŠ€èƒ½æ ·å¼', reset: 'é‡ç½®' },
        labels: { name: 'åç§°', hp: 'ç”Ÿå‘½å€¼', element: 'å±æ€§', stage: 'é˜¶æ®µ', description: 'æè¿°', author: 'ä½œè€…', rarity: 'ç¨€æœ‰åº¦', effect: 'æ•ˆæœ', weakness: 'å¼±ç‚¹', resistance: 'æŠ—æ€§', retreatCost: 'æ’¤é€€æ¶ˆè€—', abilityName: 'æŠ€èƒ½åç§°', damage: 'ä¼¤å®³', energyCost: 'èƒ½é‡æ¶ˆè€—', abilityDesc: 'æŠ€èƒ½æè¿°', borderColor: 'è¾¹æ¡†é¢œè‰²', backgroundColor: 'å¡ç‰‡èƒŒæ™¯', abilityBackground: 'æŠ€èƒ½èƒŒæ™¯', textColor: 'æ–‡å­—é¢œè‰²', font: 'å­—ä½“', size: 'å¤§å°', weight: 'ç²—ç»†', zoom: 'ç¼©æ”¾', backgroundStyle: 'èƒŒæ™¯æ ·å¼', solid: 'çº¯è‰²', gradient: 'æ¸å˜', cardInner: 'å¡ç‰‡å†…éƒ¨', primaryColor: 'ä¸»è‰²', secondaryColor: 'å‰¯è‰²', presets: 'é¢„è®¾', nameColor: 'åç§°é¢œè‰²', hpColor: 'ç”Ÿå‘½å€¼é¢œè‰²', typeColor: 'å±æ€§é¢œè‰²', descColor: 'æè¿°é¢œè‰²', statsColor: 'å±æ€§é¢œè‰²', authorColor: 'ä½œè€…é¢œè‰²', particleEmoji: 'ç²’å­è¡¨æƒ…', animation: 'åŠ¨ç”»' },
        buttons: { addAbility: '+ æ·»åŠ ', remove: 'åˆ é™¤', change: 'æ›´æ”¹', recenter: 'å±…ä¸­', download: 'ä¸‹è½½', autoRotate: '3Dè§†å›¾', resetCard: 'ğŸ”„ é‡ç½®', save: 'ä¿å­˜', load: 'åŠ è½½', deleteAll: 'å…¨éƒ¨åˆ é™¤' },
        checkboxes: { showHP: 'æ˜¾ç¤ºç”Ÿå‘½å€¼', showWeakRes: 'æ˜¾ç¤ºå¼±ç‚¹/æŠ—æ€§', showRetreat: 'æ˜¾ç¤ºæ’¤é€€æ¶ˆè€—', showDescription: 'æ˜¾ç¤ºæè¿°', showTexture: 'æ˜¾ç¤ºçº¹ç†', showParticles: 'æ˜¾ç¤ºç²’å­', showDamage: 'æ˜¾ç¤ºä¼¤å®³' },
        imageEditor: { dropHint: 'å°†å›¾ç‰‡æ‹–æ”¾åˆ°è¿™é‡Œ', orClick: 'æˆ–ç‚¹å‡»é€‰æ‹©', formats: 'PNG,JPG,GIF,WEBP (æœ€å¤§15MB)', loading: 'åŠ è½½ä¸­...', unsupportedFormat: 'ä¸æ”¯æŒçš„æ ¼å¼ã€‚è¯·ä½¿ç”¨PNGã€JPGã€GIFæˆ–WEBPã€‚', fileTooLarge: 'æ–‡ä»¶å¤ªå¤§ã€‚æœ€å¤§15MBã€‚', searchPlaceholder: 'è¾“å…¥...' },
        download: { title: 'ğŸ“¥ ä¸‹è½½', pngTitle: 'é€æ˜PNGå›¾ç‰‡', jpgTitle: 'å¸¦èƒŒæ™¯çš„JPGå›¾ç‰‡', gifTitle: 'åŠ¨ç”»GIFï¼ˆ3ç§’ï¼‰', webpTitle: 'WebPå›¾ç‰‡', htmlTitle: 'äº¤äº’å¼HTMLæ–‡ä»¶', capturing: 'â³ æ•è·ä¸­...', encoding: 'âš™ï¸ ç¼–ç ä¸­...' },
        card: { hp: 'HP', weakness: 'å¼±ç‚¹', resistance: 'æŠ—æ€§', cost: 'æ¶ˆè€—', illus: 'ç”»å¸ˆ' },
        defaults: { newAbility: 'æ–°æŠ€èƒ½', cardName: 'æˆ‘çš„ç”Ÿç‰©', description: 'å…·æœ‰ä¸å¯æ€è®®åŠ›é‡çš„ç¥ç§˜ç”Ÿç‰©ã€‚', author: 'åˆ›ä½œè€…', attackName1: 'ç«çƒ', attackDesc1: 'æŠ•æ·ç¡¬å¸ã€‚å¦‚æœæ˜¯æ­£é¢ï¼Œé˜²å®ˆå®å¯æ¢¦ç°åœ¨è¢«çƒ§ä¼¤ã€‚', attackName2: 'å–·å°„ç«ç„°', attackDesc2: 'ä¸¢å¼ƒè¯¥å®å¯æ¢¦èº«ä¸Šçš„ä¸€ä¸ªèƒ½é‡ã€‚' }, notifications: { success: 'æˆåŠŸ', error: 'é”™è¯¯', info: 'ä¿¡æ¯', warning: 'è­¦å‘Š' },
        display: { title: 'æ˜¾ç¤ºé€‰é¡¹' },
        tabs: { info: 'ä¿¡æ¯', content: 'å†…å®¹', visual: 'è§†è§‰', style: 'æ ·å¼', colors: 'é¢œè‰²' },
        common: { cancel: 'å–æ¶ˆ', close: 'å…³é—­' },
        prompts: { resetConfirm: 'é‡ç½®æ‰€æœ‰å¡ç‰‡æ•°æ®ï¼Ÿ', saveHint: 'æ‚¨çš„å¡ç‰‡ï¼ˆæ–‡å­— + å›¾ç‰‡ï¼‰å°†ä¿å­˜åœ¨æœ¬åœ°ã€‚', saveSuccess: 'å¡ç‰‡ä¿å­˜æˆåŠŸï¼', loadConfirm: 'åŠ è½½æ­¤å¡ç‰‡ï¼Ÿæœªä¿å­˜çš„æ›´æ”¹å°†ä¸¢å¤±ã€‚', deleteConfirm: 'åˆ é™¤æ­¤å·²ä¿å­˜çš„å¡ç‰‡ï¼Ÿ', deleteAllConfirm: 'åˆ é™¤æ‰€æœ‰å¡ç‰‡ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚', allDeleted: 'æ‰€æœ‰å¡ç‰‡å·²åˆ é™¤', noSaves: 'æœªæ‰¾åˆ°å·²ä¿å­˜çš„å¡ç‰‡ã€‚', quotaError: 'å­˜å‚¨ç©ºé—´å·²æ»¡ï¼è¯·åˆ é™¤æ—§å¡ç‰‡ã€‚', saveError: 'ä¿å­˜å¡ç‰‡æ—¶å‡ºé”™ã€‚', autoDeleteInfo: 'å¡ç‰‡å°†åœ¨30å¤©åè‡ªåŠ¨åˆ é™¤ã€‚' },
        textures: { none: 'æ— ', grid: 'ç½‘æ ¼', scales: 'é³ç‰‡', cross: 'åå­—', stars: 'æ˜Ÿæ˜Ÿ', hexagons: 'å…­è¾¹å½¢', lines: 'çº¿æ¡', dots: 'ç‚¹é˜µ', waves: 'æ³¢æµª', circuit: 'ç”µè·¯' },
        animations: { fire: 'ä¸Šå‡', water: 'æ°”æ³¡', nature: 'æ¼‚æµ®', electric: 'ç«èŠ±', mystic: 'é­”æ³•', fighting: 'å†²å‡»', shadow: 'æ·¡å…¥æ·¡å‡º', metal: 'é½¿è½®', light: 'è¾å°„', dragon: 'å¨ä¸¥', ice: 'é›ª', neutral: 'å¾®å¦™' }
      },
    };
    const LanguageContext = createContext();
    const useLanguage = () => {
      const context = useContext(LanguageContext);
      if (!context) {
        throw new Error('useLanguage must be used within a LanguageProvider')
      }
      return context
    };

    // --- Notification System ---
    const NotificationContext = createContext();

    const NotificationToast = ({ notification, onClose }) => {
      useEffect(() => {
        if (notification.duration) {
          const timer = setTimeout(() => {
            onClose(notification.id);
          }, notification.duration);
          return () => clearTimeout(timer);
        }
      }, [notification, onClose]);

      const icons = {
        success: 'âœ…',
        error: 'âŒ',
        info: 'â„¹ï¸',
        warning: 'âš ï¸'
      };

      return (
        <div className={`notification-toast ${notification.type}`} onClick={() => onClose(notification.id)}>
          <div className="notification-icon">{icons[notification.type] || 'â„¹ï¸'}</div>
          <div className="notification-content">
            <div className="notification-title">{notification.title}</div>
            <div className="notification-message">{notification.message}</div>
          </div>
          <button className="notification-close" onClick={(e) => { e.stopPropagation(); onClose(notification.id); }}>
            &times;
          </button>
        </div>
      );
    };

    const NotificationProvider = ({ children }) => {
      const { t } = useLanguage();
      const [notifications, setNotifications] = useState([]);

      const notify = useCallback((message, type = 'info', title = '', duration = 4000) => {
        const id = Date.now();
        const defaultTitles = {
          success: t.notifications?.success || 'Success',
          error: t.notifications?.error || 'Error',
          info: t.notifications?.info || 'Information',
          warning: t.notifications?.warning || 'Warning'
        };
        setNotifications(prev => [...prev, {
          id,
          message,
          type,
          title: title || defaultTitles[type],
          duration
        }]);
      }, []);

      const removeNotification = useCallback((id) => {
        setNotifications(prev => prev.filter(n => n.id !== id));
      }, []);

      const contextValue = useMemo(() => ({ notify }), [notify]);

      return (
        <NotificationContext.Provider value={contextValue}>
          {children}
          <div className="notification-container">
            {notifications.map(n => (
              <NotificationToast key={n.id} notification={n} onClose={removeNotification} />
            ))}
          </div>
        </NotificationContext.Provider>
      );
    };

    const useNotification = () => {
      const context = useContext(NotificationContext);
      if (!context) {
        throw new Error('useNotification must be used within a NotificationProvider');
      }
      return context;
    };
    const CARD_LIMITS = {
      HP_MIN: 0, HP_MAX: 999, DAMAGE_MIN: 0, DAMAGE_MAX: 9999, COST_MIN: 0, COST_MAX: 6, RETREAT_MIN: 0, RETREAT_MAX: 5, NAME_MAX_LENGTH: 25, DESC_MAX_LENGTH: 150, ATTACK_DESC_MAX_LENGTH: 80, AUTHOR_MAX_LENGTH: 30, MAX_FILE_SIZE: 25 * 1024 * 1024, // 25MB
      ZOOM_MIN: 1, ZOOM_MAX: 3,
    };
    const ELEMENT_TYPES = {
      Fire: { icon: 'ğŸ”¥', primary: '#FF6B35', secondary: '#FFE066', weakness: 'ğŸ’§', resistance: 'ğŸŒ¿' },
      Water: { icon: 'ğŸ’§', primary: '#4FC3F7', secondary: '#E1F5FE', weakness: 'âš¡', resistance: 'ğŸ”¥' },
      Nature: { icon: 'ğŸŒ¿', primary: '#66BB6A', secondary: '#C8E6C9', weakness: 'ğŸ”¥', resistance: 'ğŸ’§' },
      Electric: { icon: 'âš¡', primary: '#FFEE58', secondary: '#FFF9C4', weakness: 'ğŸ‘Š', resistance: 'âš™ï¸' },
      Mystic: { icon: 'ğŸ”®', primary: '#BA68C8', secondary: '#F3E5F5', weakness: 'ğŸŒ‘', resistance: 'ğŸ‘Š' },
      Fighting: { icon: 'ğŸ‘Š', primary: '#D84315', secondary: '#FFAB91', weakness: 'ğŸ”®', resistance: 'ğŸŒ‘' },
      Shadow: { icon: 'ğŸŒ‘', primary: '#5D4037', secondary: '#A1887F', weakness: 'âœ¨', resistance: 'ğŸ”®' },
      Metal: { icon: 'âš™ï¸', primary: '#90A4AE', secondary: '#ECEFF1', weakness: 'ğŸ”¥', resistance: 'ğŸŒ¿' },
      Light: { icon: 'âœ¨', primary: '#FFD54F', secondary: '#FFF8E1', weakness: 'ğŸŒ‘', resistance: 'ğŸ”®' },
      Dragon: { icon: 'ğŸ‰', primary: '#7E57C2', secondary: '#D1C4E9', weakness: 'â„ï¸', resistance: 'ğŸ”¥' },
      Ice: { icon: 'â„ï¸', primary: '#4DD0E1', secondary: '#E0F7FA', weakness: 'ğŸ”¥', resistance: 'ğŸ’§' },
      Neutral: { icon: 'â­', primary: '#BDBDBD', secondary: '#F5F5F5', weakness: 'ğŸ‘Š', resistance: 'ğŸ‘»' },
    };
    const ELEMENT_KEYS = Object.keys(ELEMENT_TYPES);

    const STAGES = ['Base', 'Stage1', 'Stage2', 'Special', 'Legendary', 'Mythic', 'Ultra'];

    const ELEMENT_TEXTURES = {
      Fire: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5c-5 10-15 15-15 25 0 8 7 15 15 15s15-7 15-15c0-10-10-15-15-25z' fill='%23ff6b3520' /%3E%3Cpath d='M30 15c-3 6-9 9-9 15 0 5 4 9 9 9s9-4 9-9c0-6-6-9-9-15z' fill='%23ff450015' /%3E%3C/svg%3E")`, Water: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='15' cy='15' r='8' fill='%2300bcd420' /%3E%3Ccircle cx='45' cy='35' r='6' fill='%232196f315' /%3E%3Ccircle cx='25' cy='45' r='10' fill='%2303a9f418' /%3E%3Cpath d='M5 30 Q15 25 25 30 T45 30 T60 30' stroke='%2300bcd415' fill='none' stroke-width='2'/%3E%3C/svg%3E")`, Nature: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5 Q35 15 30 25 Q25 15 30 5z' fill='%234caf5020' /%3E%3Cpath d='M15 30 Q25 35 20 45 Q15 35 15 30z' fill='%238bc34a18' /%3E%3Cpath d='M45 25 Q50 35 45 45 Q40 35 45 25z' fill='%234caf5015' /%3E%3Ccircle cx='10' cy='50' r='3' fill='%234caf5012' /%3E%3C/svg%3E")`, Electric: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0 L25 25 L35 20 L20 60 L25 30 L15 35 Z' fill='%23ffeb3b15' /%3E%3Cpath d='M50 10 L48 20 L52 18 L45 35' stroke='%23ffc10710' fill='none' stroke-width='2'/%3E%3Ccircle cx='10' cy='45' r='2' fill='%23ffeb3b20' /%3E%3C/svg%3E")`, Mystic: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='30,5 32,15 40,10 35,18 45,20 35,22 40,30 32,25 30,35 28,25 20,30 25,22 15,20 25,18 20,10 28,15' fill='%239c27b015' /%3E%3Ccircle cx='10' cy='50' r='4' fill='%23e91e6310' /%3E%3Ccircle cx='50' cy='45' r='3' fill='%239c27b012' /%3E%3C/svg%3E")`, Fighting: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 10 L50 50' stroke='%23f4433615' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M50 10 L10 50' stroke='%23ff572215' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M30 5 L30 55' stroke='%23f4433610' stroke-width='3'/%3E%3Cpath d='M5 30 L55 30' stroke='%23f4433610' stroke-width='3'/%3E%3C/svg%3E")`, Shadow: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cellipse cx='30' cy='50' rx='20' ry='8' fill='%2300000015' /%3E%3Cellipse cx='15' cy='30' rx='10' ry='5' fill='%2300000010' /%3E%3Cellipse cx='45' cy='20' rx='12' ry='6' fill='%2300000012' /%3E%3Cpath d='M20 10 Q30 20 25 35 Q35 25 40 40' stroke='%2300000008' fill='none' stroke-width='3'/%3E%3C/svg%3E")`, Metal: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='5' y='5' width='20' height='20' rx='2' fill='none' stroke='%2360606015' stroke-width='2'/%3E%3Crect x='35' y='35' width='20' height='20' rx='2' fill='none' stroke='%2360606015' stroke-width='2'/%3E%3Ccircle cx='15' cy='15' r='3' fill='%2390909020' /%3E%3Ccircle cx='45' cy='45' r='3' fill='%2390909020' /%3E%3Ccircle cx='45' cy='15' r='2' fill='%2360606015' /%3E%3Ccircle cx='15' cy='45' r='2' fill='%2360606015' /%3E%3C/svg%3E")`, Light: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='30' cy='30' r='15' fill='%23fff59d10' /%3E%3Cpath d='M30 5 L30 15 M30 45 L30 55 M5 30 L15 30 M45 30 L55 30 M12 12 L19 19 M41 41 L48 48 M12 48 L19 41 M41 19 L48 12' stroke='%23ffeb3b15' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E")`, Dragon: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 20 Q20 15 30 20 Q40 15 50 20 L50 35 Q40 40 30 35 Q20 40 10 35 Z' fill='%23673ab720' /%3E%3Cpath d='M10 35 Q20 30 30 35 Q40 30 50 35 L50 50 Q40 55 30 50 Q20 55 10 50 Z' fill='%23673ab715' /%3E%3Cpath d='M10 5 Q20 0 30 5 Q40 0 50 5 L50 20 Q40 25 30 20 Q20 25 10 20 Z' fill='%23673ab712' /%3E%3C/svg%3E")`, Ice: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5 L30 55 M15 15 L45 45 M45 15 L15 45' stroke='%2381d4fa20' stroke-width='2'/%3E%3Cpath d='M30 20 L25 15 M30 20 L35 15 M30 40 L25 45 M30 40 L35 45' stroke='%2329b6f618' stroke-width='2'/%3E%3Cpolygon points='30,25 33,30 30,35 27,30' fill='%2381d4fa15' /%3E%3C/svg%3E")`, Neutral: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='30' cy='30' r='20' fill='none' stroke='%2390909010' stroke-width='1'/%3E%3Ccircle cx='30' cy='30' r='10' fill='none' stroke='%2390909008' stroke-width='1'/%3E%3C/svg%3E")`,
    };
    /* Textures SVG Patterns */
    const CARD_TEXTURES = {
      none: '',
      grid: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='grid' width='20' height='20' patternUnits='userSpaceOnUse'%3E%3Cpath d='M20 0L0 0 0 20' fill='none' stroke='black' stroke-width='2'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23grid)'/%3E%3C/svg%3E")`,
      scales: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='scales' width='20' height='10' patternUnits='userSpaceOnUse'%3E%3Cpath d='M0 10 Q10 20 20 10 M10 0 Q20 10 30 0 M-10 0 Q0 10 10 0' fill='none' stroke='black' stroke-width='2'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23scales)'/%3E%3C/svg%3E")`,
      cross: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='cross' width='20' height='20' patternUnits='userSpaceOnUse'%3E%3Cpath d='M10 5v10M5 10h10' fill='none' stroke='black' stroke-width='3' stroke-linecap='round'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23cross)'/%3E%3C/svg%3E")`,
      stars: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='stars' width='30' height='30' patternUnits='userSpaceOnUse'%3E%3Cpath d='M15 5l3 7 7 3-7 3-3 7-3-7-7-3 7-3z' fill='black'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23stars)'/%3E%3C/svg%3E")`,
      hexagons: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='hex' width='28' height='49' patternUnits='userSpaceOnUse'%3E%3Cpath d='M14 0l14 8.1v16.2l-14 8.1L0 24.3V8.1z' fill='none' stroke='black' stroke-width='2'/%3E%3Cpath d='M14 49V32.4' stroke='black' stroke-width='2'/%3E%3Cpath d='M0 8.1L-14 0m28 0l14 8.1' stroke='black' stroke-width='2'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23hex)'/%3E%3C/svg%3E")`,
      lines: `url("data:image/svg+xml,%3Csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3Cpattern id='lines' width='20' height='20' patternUnits='userSpaceOnUse' patternTransform='rotate(45)'%3E%3Cline x1='0' y1='0' x2='0' y2='20' stroke='black' stroke-width='3'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23lines)'/%3E%3C/svg%3E")`,
      dots: `url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='10' cy='10' r='2.5' fill='black'/%3E%3C/svg%3E")`,
      waves: `url("data:image/svg+xml,%3Csvg width='100' height='20' viewBox='0 0 100 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M21.184 20c.357-.13.72-.264 1.088-.402l1.768-.661C33.64 15.347 39.647 14 50 14c10.271 0 15.362 1.222 24.629 4.928.955.383 1.869.74 2.75 1.072h6.225c-2.51-.73-5.139-1.691-8.233-2.928C65.888 13.278 60.562 12 50 12c-10.626 0-16.855 1.397-26.66 5.063l-1.767.662c-2.475.923-4.66 1.674-6.724 2.275h6.335zm0-20C13.258 2.892 8.077 4 0 4V2c5.744 0 9.951-.574 14.85-2h6.334zM77.38 0C85.239 2.966 90.502 4 100 4V2c-6.842 0-11.386-.542-16.326-2h-6.292zM0 14c8.44 0 13.718-1.21 22.272-4.402l1.768-.661C33.64 5.347 39.647 4 50 4c10.271 0 15.362 1.222 24.629 4.928C84.112 12.722 89.438 14 100 14v-2c-10.271 0-15.362-1.222-24.629-4.928C65.888 3.278 60.562 2 50 2 39.374 2 33.145 3.397 23.34 7.063l-1.767.662C13.223 10.84 8.163 12 0 12v2z' fill='black' fill-rule='evenodd'/%3E%3C/svg%3E")`,
      circuit: `url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 10 L20 10 L20 30 L50 30 L50 10 M80 10 L80 40 L60 40 M10 80 L30 80 L30 60 L60 60 L60 80 M90 90 L80 90 L80 70 L50 70' fill='none' stroke='black' stroke-width='2'/%3E%3Ccircle cx='20' cy='30' r='3' fill='black'/%3E%3Ccircle cx='60' cy='40' r='3' fill='black'/%3E%3Ccircle cx='30' cy='60' r='3' fill='black'/%3E%3Ccircle cx='80' cy='70' r='3' fill='black'/%3E%3C/svg%3E")`,
    };
    const ELEMENT_PARTICLES = {
      Fire: { emoji: 'ğŸ”¥', alt: ['ğŸ”¥', 'âœ¨'], count: 12, speed: 'fast', direction: 'up' },
      Water: { emoji: 'ğŸ’§', alt: ['ğŸ«§', 'ğŸ’¦'], count: 12, speed: 'slow', direction: 'up' },
      Nature: { emoji: 'ğŸƒ', alt: ['ğŸŒ¿', 'ğŸŒ¸'], count: 11, speed: 'medium', direction: 'float' },
      Electric: { emoji: 'âš¡', alt: ['âš¡', 'â­'], count: 9, speed: 'fast', direction: 'random' },
      Mystic: { emoji: 'ğŸ”®', alt: ['âœ¨', 'ğŸ’«'], count: 10, speed: 'slow', direction: 'float' },
      Fighting: { emoji: 'ğŸ’¥', alt: ['ğŸ’¢', 'âš¡'], count: 8, speed: 'fast', direction: 'random' },
      Shadow: { emoji: 'ğŸŒ‘', alt: ['ğŸ’€', 'ğŸ‘»'], count: 7, speed: 'slow', direction: 'down' },
      Metal: { emoji: 'âš™ï¸', alt: ['â›“ï¸', 'ğŸ”©'], count: 6, speed: 'slow', direction: 'float' },
      Light: { emoji: 'âœ¨', alt: ['â­', 'ğŸŒŸ'], count: 12, speed: 'medium', direction: 'radial' },
      Dragon: { emoji: 'ğŸ‰', alt: ['ğŸ’', 'ğŸ”¥'], count: 6, speed: 'medium', direction: 'float' },
      Ice: { emoji: 'â„ï¸', alt: ['â…', 'ğŸ’'], count: 14, speed: 'slow', direction: 'down' },
      Neutral: { emoji: 'âœ¦', alt: ['âšª', 'â—†'], count: 5, speed: 'slow', direction: 'float' },
    };
    const FONTS = [
      { id: 'nunito', name: 'Nunito', family: "'Nunito', sans-serif" },
      { id: 'poppins', name: 'Poppins', family: "'Poppins', sans-serif" },
      { id: 'roboto', name: 'Roboto', family: "'Roboto', sans-serif" },
      { id: 'oswald', name: 'Oswald', family: "'Oswald', sans-serif" },
      { id: 'playfair', name: 'Playfair Display', family: "'Playfair Display', serif" },
      { id: 'bangers', name: 'Bangers', family: "'Bangers', cursive" },
      { id: 'cinzel', name: 'Cinzel', family: "'Cinzel', serif" },
      { id: 'dancing', name: 'Dancing Script', family: "'Dancing Script', cursive" },
      { id: 'orbitron', name: 'Orbitron', family: "'Orbitron', sans-serif" },
      { id: 'amatic', name: 'Amatic SC', family: "'Amatic SC', cursive" },
    ];
    const PARTICLE_ANIMATIONS = [
      { key: 'fire', label: 'Rising (Fire)' },
      { key: 'water', label: 'Bubbles (Water)' },
      { key: 'nature', label: 'Floating (Nature)' },
      { key: 'electric', label: 'Sparks (Electric)' },
      { key: 'mystic', label: 'Magic (Mystic)' },
      { key: 'fighting', label: 'Impact (Fighting)' },
      { key: 'shadow', label: 'Fade (Shadow)' },
      { key: 'metal', label: 'Gears (Metal)' },
      { key: 'light', label: 'Radiate (Light)' },
      { key: 'dragon', label: 'Majestic (Dragon)' },
      { key: 'ice', label: 'Snow (Ice)' },
      { key: 'neutral', label: 'Subtle (Neutral)' }
    ];
    const getInitialCardData = (t) => ({
      name: t.defaults.cardName, hp: 120, type: 'Fire', stage: 'Base', weakness: 'ğŸ’§', resistance: 'ğŸŒ¿', retreatCost: 2, description: t.defaults.description, author: t.defaults.author, font: 'nunito', borderColor: '', backgroundColor: '', abilityBackground: 'rgba(255, 255, 255, 0.7)', textColor: '', nameColor: '', hpColor: '', typeColor: '', descColor: '', statsColor: '', authorColor: '', showHP: true, showWeakRes: true, showRetreat: true, showDescription: true, showParticles: true,
      colorMode: 'solid', primaryColor: '#ff6b35', secondaryColor: '#ff9e80', customIcon: 'ğŸ”¥', particleEmoji: 'ğŸ”¥', particleAnimation: 'fire',
      cardInnerBackground: 'rgba(255, 255, 255, 0.95)', cardInnerColorMode: 'solid', cardInnerSecondaryBackground: '#f5f5fa',
      texture: 'none',
      /* Typography Defaults */
      nameSize: 16, nameWeight: '700', hpSize: 18, hpWeight: '700', stageSize: 9, stageWeight: '700', descSize: 8, descWeight: '400', statsSize: 8, statsWeight: '400', authorSize: 6, authorWeight: '400', moveNameSize: 12, moveNameWeight: '700', moveDescSize: 8, moveDescWeight: '400',
    });
    const getInitialAttacks = (t) => ([
      { id: '1', name: t.defaults.attackName1, damage: 60, cost: 2, desc: t.defaults.attackDesc1, showDamage: true, background: 'rgba(255, 255, 255, 0.7)', colorMode: 'solid', secondaryBackground: '#ffffff' },
      { id: '2', name: t.defaults.attackName2, damage: 90, cost: 3, desc: t.defaults.attackDesc2, showDamage: true, background: 'rgba(255, 255, 255, 0.7)', colorMode: 'solid', secondaryBackground: '#ffffff' },
    ]);
    const INITIAL_IMAGE_SETTINGS = {
      zoom: 1, offsetX: 0, offsetY: 0,
    };
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const parseIntSafe = (value, fallback = 0) => {
      const parsed = parseInt(value, 10);
      return isNaN(parsed) ? fallback : parsed
    };
    const parseFloatSafe = (value, fallback = 0) => {
      const parsed = parseFloat(value);
      return isNaN(parsed) ? fallback : parsed
    };
    const generateId = () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const useThrottle = (callback, delay) => {
      const lastCall = useRef(0);
      const callbackRef = useRef(callback);
      callbackRef.current = callback;
      return useCallback((...args) => {
        const now = Date.now();
        if (now - lastCall.current >= delay) {
          lastCall.current = now;
          callbackRef.current(...args)
        }
      }, [delay])
    };

    const downloadAsImage = async (element, filename, format = 'png', targetHeight = 1080) => {
      if (!element) return;
      try {
        if (!window.html2canvas) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        // 1. Create a clean container for the clone
        const container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.top = '-10000px';
        container.style.left = '-10000px';
        container.style.zIndex = '-1';
        container.style.zoom = '1'; // Force no zoom
        container.style.width = 'auto';
        container.style.height = 'auto';
        document.body.appendChild(container);

        // 2. Clone the element
        const clone = element.cloneNode(true);

        // 3. Reset styles on the clone to ensure perfect capture
        clone.style.transform = 'none';
        clone.style.margin = '0';
        clone.style.zoom = '1';
        clone.style.position = 'relative';
        clone.style.boxShadow = 'none'; // Remove shadow to avoid border artifacts if that's the issue
        // If the user wants the shadow, we can comment the line above, but "borders" usually implies unwanted shadow area.
        // Let's assume we want a clean cut of the card content.
        // Re-reading: "le dÃ©coupage n'est pas bon" -> likely unwanted extra space.

        // For JPG, we keep the rounded corners but fill the background with white
        // This avoids black artifacts while preserving the card shape
        // The user will see white corners, which is the standard behavior for rounded images in JPG


        container.appendChild(clone);

        // 4. Calculate scale based on the CLEAN clone
        // We wait a microtask to let DOM update (though synchronous append usually works)
        const rect = clone.getBoundingClientRect();
        const scale = targetHeight / rect.height;

        const backgroundColor = format === 'jpg' ? '#ffffff' : null;

        const canvas = await html2canvas(clone, {
          backgroundColor: backgroundColor,
          scale: scale,
          useCORS: true,
          allowTaint: true,
          logging: false,
          removeContainer: true
        });

        // 5. Cleanup
        document.body.removeChild(container);

        const link = document.createElement('a');
        link.download = `${filename}.${format}`;
        link.href = canvas.toDataURL(`image/${format === 'jpg' ? 'jpeg' : format}`, 0.9);
        link.click();
      } catch (err) {
        console.error('Download failed:', err);
      }
    };
    const downloadAsPNG = (el, fn) => downloadAsImage(el, fn, 'png', 1080);
    const downloadAsJPG = (el, fn) => downloadAsImage(el, fn, 'jpg', 1080);
    const downloadAsWebP = (el, fn) => downloadAsImage(el, fn, 'webp', 1080);


    const downloadAsGIF = async (cardElement, filename = 'card', duration = 3000, fps = 15, t, onStatusChange) => {
      if (!cardElement) return false;

      try {
        // 1. Show instructions modal and wait for user confirmation
        const { stream, fps: selectedFps, targetHeight: selectedScale } = await new Promise((resolve, reject) => {
          const modal = document.getElementById('gif-instructions-modal');
          const startBtn = document.getElementById('start-gif-btn');
          const cancelBtn = document.getElementById('cancel-gif-btn');

          // Update modal text with translations
          const translations = t || (typeof TRANSLATIONS !== 'undefined' ? TRANSLATIONS['en'] : null);

          if (translations && translations.gifModal) {
            const gm = translations.gifModal;
            const titleEl = modal.querySelector('h3');
            if (titleEl) titleEl.textContent = gm.title;

            const bodyEl = modal.querySelector('p');
            if (bodyEl) bodyEl.textContent = gm.body;

            const step1 = modal.querySelector('#gif-modal-step-1');
            if (step1) step1.innerHTML = gm.step1;
            const step2 = modal.querySelector('#gif-modal-step-2');
            if (step2) step2.innerHTML = gm.step2;
            const step3 = modal.querySelector('#gif-modal-step-3');
            if (step3) step3.innerHTML = gm.step3;

            const noteEl = modal.querySelector('.modal-note span:last-child');
            if (noteEl) noteEl.textContent = gm.note;

            const warningEl = modal.querySelector('.modal-warning span:last-child');
            if (warningEl && gm.warning) warningEl.textContent = gm.warning;

            const fpsLabel = modal.querySelector('#gif-fps-label');
            if (fpsLabel && gm.fpsLabel) fpsLabel.textContent = gm.fpsLabel;

            const qualityLabel = modal.querySelector('#gif-quality-label');
            if (qualityLabel && gm.qualityLabel) qualityLabel.textContent = gm.qualityLabel;

            const fpsNormal = modal.querySelector('#gif-fps-normal');
            if (fpsNormal && gm.fpsNormal) fpsNormal.textContent = gm.fpsNormal;
            const fpsCinema = modal.querySelector('#gif-fps-cinema');
            if (fpsCinema && gm.fpsCinema) fpsCinema.textContent = gm.fpsCinema;
            const fpsSmooth = modal.querySelector('#gif-fps-smooth');
            if (fpsSmooth && gm.fpsSmooth) fpsSmooth.textContent = gm.fpsSmooth;
            const fpsUltra = modal.querySelector('#gif-fps-ultra');
            if (fpsUltra && gm.fpsUltra) fpsUltra.textContent = gm.fpsUltra;

            const qualitySD = modal.querySelector('#gif-quality-sd');
            if (qualitySD && gm.qualitySD) qualitySD.textContent = gm.qualitySD;
            const qualityNormal = modal.querySelector('#gif-quality-normal');
            if (qualityNormal && gm.qualityNormal) qualityNormal.textContent = gm.qualityNormal;
            const qualityHigh = modal.querySelector('#gif-quality-high');
            if (qualityHigh && gm.qualityHigh) qualityHigh.textContent = gm.qualityHigh;
            const qualityQHD = modal.querySelector('#gif-quality-qhd');
            if (qualityQHD && gm.qualityQHD) qualityQHD.textContent = gm.qualityQHD;
            const qualityUltra = modal.querySelector('#gif-quality-ultra');
            if (qualityUltra && gm.qualityUltra) qualityUltra.textContent = gm.qualityUltra;

            if (cancelBtn) cancelBtn.textContent = gm.cancel;
            if (startBtn) startBtn.textContent = gm.start;
          }

          modal.style.display = 'flex';

          const cleanup = () => {
            modal.style.display = 'none';
            startBtn.removeEventListener('click', onStart);
            cancelBtn.removeEventListener('click', onCancel);
          };

          const onStart = async () => {
            const selectedFps = parseInt(document.getElementById('gif-fps-select').value) || 15;
            const selectedHeight = parseInt(document.getElementById('gif-scale-select').value) || 720;

            cleanup();
            try {
              const s = await navigator.mediaDevices.getDisplayMedia({
                video: {
                  displaySurface: 'browser',
                  cursor: 'never',
                  width: { ideal: 3840 }, // Request 4K resolution
                  height: { ideal: 2160 }
                },
                audio: false,
                preferCurrentTab: true
              });
              resolve({ stream: s, fps: selectedFps, targetHeight: selectedHeight });
            } catch (err) {
              reject(err);
            }
          };

          const onCancel = () => {
            cleanup();
            reject(new Error('User cancelled'));
          };

          startBtn.addEventListener('click', onStart);
          cancelBtn.addEventListener('click', onCancel);
        });

        // Add capturing class to freeze layout and hide cursor
        document.body.classList.add('is-capturing');
        document.documentElement.classList.add('is-capturing');

        // Create overlay to block mouse
        const overlay = document.createElement('div');
        overlay.id = 'capture-overlay';

        // Brute-force block all mouse events
        const blockEvent = (e) => {
          e.preventDefault();
          e.stopPropagation();
          return false;
        };
        ['mousemove', 'mousedown', 'mouseup', 'click', 'contextmenu', 'dblclick', 'wheel', 'mouseover', 'mouseout'].forEach(event => {
          overlay.addEventListener(event, blockEvent, { capture: true, passive: false });
        });

        document.body.appendChild(overlay);
        if (document.activeElement) document.activeElement.blur(); // Remove focus

        if (onStatusChange) onStatusChange(t?.gifModal?.loadingLibs || 'â³ Loading libs...');

        // 2. Load dependencies
        if (!window.GIF) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        // 3. Setup Video & Canvas
        const video = document.createElement('video');
        video.srcObject = stream;
        video.play();

        // Wait for video dimensions and layout stabilization
        await new Promise(r => video.onloadedmetadata = r);
        await new Promise(r => setTimeout(r, 1000)); // Longer warmup for layout shift

        if (onStatusChange) onStatusChange(t?.gifModal?.capturing || 'ğŸ“¸ Capturing...');

        const workerBlob = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js')
          .then(r => r.blob());
        const workerUrl = URL.createObjectURL(workerBlob);

        // Since we fixed the card to center (50% 50%), we crop the center of the video
        // We target the .game-card specifically to be precise
        const gameCard = document.querySelector('.game-card');
        const rect = gameCard.getBoundingClientRect();

        // Inset to crop tighter on the card edges (0 = exact fit)
        const inset = 0;

        const scaleX = video.videoWidth / window.innerWidth;
        const scaleY = video.videoHeight / window.innerHeight;

        // Calculate crop size based on card size minus inset
        const cropW = (rect.width - inset * 2) * scaleX;
        const cropH = (rect.height - inset * 2) * scaleY;

        // Use the actual card position with inset adjustment
        const cropX = (rect.left + inset) * scaleX;
        const cropY = (rect.top + inset) * scaleY;

        // Apply user selected height standard
        const finalH = selectedScale; // selectedScale is actually targetHeight now
        const aspectRatio = cropW / cropH;
        const finalW = Math.round(finalH * aspectRatio);

        const gif = new GIF({
          workers: 2,
          quality: 1, // Best quality
          workerScript: workerUrl,
          width: finalW,
          height: finalH
        });

        const canvas = document.createElement('canvas');
        canvas.width = finalW;
        canvas.height = finalH;
        const ctx = canvas.getContext('2d');

        // 4. Capture Loop & Promise Wrapper
        return new Promise((resolve, reject) => {
          const frameInterval = 1000 / selectedFps;
          const totalFrames = (duration / 1000) * selectedFps;
          let frameCount = 0;

          const finishCapture = () => {
            // Stop stream
            stream.getTracks().forEach(track => track.stop());
            document.body.classList.remove('is-capturing');
            document.documentElement.classList.remove('is-capturing');
            if (overlay) overlay.remove();

            if (onStatusChange) onStatusChange(t?.download?.encoding || 'âš™ï¸ Encoding...');

            gif.on('finished', (blob) => {
              const link = document.createElement('a');
              link.download = filename + '.gif';
              link.href = URL.createObjectURL(blob);
              link.click();

              URL.revokeObjectURL(workerUrl);
              resolve(true);
            });

            gif.render();
          };

          const captureInterval = setInterval(() => {
            if (frameCount >= totalFrames) {
              clearInterval(captureInterval);
              finishCapture();
              return;
            }

            // Draw cropped video frame to canvas (Center crop) with scaling
            ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, finalW, finalH);
            gif.addFrame(canvas, { copy: true, delay: frameInterval });

            frameCount++;
            if (onStatusChange) onStatusChange(`ğŸ“¸ ${Math.round((frameCount / totalFrames) * 100)}%`);
          }, frameInterval);
        });

      } catch (error) {
        console.error('GIF Error:', error);
        document.body.classList.remove('is-capturing');
        document.documentElement.classList.remove('is-capturing');
        const overlay = document.getElementById('capture-overlay');
        if (overlay) overlay.remove();
        throw error; // Re-throw to be handled by caller
      }
    };
    // --- IndexedDB Helper (FluxDB) ---
    const db = {
      dbName: 'CardCreatorDB',
      version: 1,
      storeName: 'cards',

      open() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.version);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              db.createObjectStore(this.storeName, { keyPath: 'id' });
            }
          };
        });
      },

      async save(card) {
        // Sanitize name before saving
        const sanitizedCard = { ...card, name: sanitize(card.name) };
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.put(sanitizedCard);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
        });
      },

      async getAll() {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result.sort((a, b) => b.timestamp - a.timestamp)); // Newest first
        });
      },

      async delete(id) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.delete(id);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      },

      async cleanupOld(maxAgeDays = 30) {
        const db = await this.open();
        const maxAge = maxAgeDays * 24 * 60 * 60 * 1000; // Convert days to ms
        const now = Date.now();

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            const cards = request.result;
            const oldCards = cards.filter(card => (now - card.timestamp) > maxAge);

            oldCards.forEach(card => {
              store.delete(card.id);
            });

            resolve(oldCards.length);
          };
        });
      },

      async deleteAll() {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.clear();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      }
    };

    const sanitize = (str) => {
      if (!str) return '';
      return String(str).replace(/[<>]/g, ''); // Basic tag stripping
    };

    // --- Save/Load Components ---
    const SaveModal = ({ isOpen, onClose, onSave, defaultName, t }) => {
      const [name, setName] = useState(defaultName);
      useEffect(() => setName(defaultName), [defaultName]);

      if (!isOpen) return null;

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content" onClick={e => e.stopPropagation()}>
            <div className="modal-header">
              <h3>ğŸ’¾ {t.buttons.save || 'Save Card'}</h3>
            </div>
            <div className="modal-body">
              <div className="modal-note">
                <span className="note-icon">â„¹ï¸</span>
                <span>{t.prompts.saveHint || 'Your card (text + image) will be saved locally.'}</span>
              </div>
              <div style={{ marginTop: '15px', marginBottom: '20px' }}>
                <InputGroup
                  id="save-name"
                  label={t.labels.name}
                  value={name}
                  onChange={setName}
                  maxLength={50}
                />
              </div>
            </div>
            <div className="modal-footer">
              <button className="secondary-button" onClick={onClose}>{t.common.cancel}</button>
              <button className="primary-button" onClick={() => onSave(name)}>{t.buttons.save}</button>
            </div>
          </div>
        </div>
      );
    };

    const ConfirmModal = ({ isOpen, onClose, onConfirm, title, message, t }) => {
      if (!isOpen) return null;
      return (
        <div className="modal-overlay" onClick={onClose} style={{ zIndex: 11000 }}>
          <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '400px' }}>
            <div className="modal-header">
              <h3 style={{ color: '#f44336' }}>âš ï¸ {title}</h3>
            </div>
            <div className="modal-body">
              <p>{message}</p>
            </div>
            <div className="modal-footer">
              <button className="secondary-button" onClick={onClose}>{t.common.cancel}</button>
              <button className="primary-button" style={{ background: '#f44336' }} onClick={onConfirm}>{t.buttons.remove || 'Confirm'}</button>
            </div>
          </div>
        </div>
      );
    };

    const LoadModal = ({ isOpen, onClose, onLoad, onDelete, onDeleteAll, cards, t }) => {
      if (!isOpen) return null;

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content load-modal" onClick={e => e.stopPropagation()}>
            <div className="modal-header">
              <h3>ğŸ“‚ {t.buttons.load || 'Load Card'}</h3>
            </div>
            <div className="modal-note" style={{ margin: '0 0 15px 0' }}>
              <span className="note-icon">ğŸ•</span>
              <span>{t.prompts.autoDeleteInfo || 'Saved cards are automatically deleted after 30 days.'}</span>
            </div>
            <div className="modal-body" style={{ overflowY: 'auto', paddingRight: '5px' }}>

              {cards.length === 0 ? (
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '40px', gap: '15px', textAlign: 'center' }}>
                  <div style={{ fontSize: '40px', opacity: 0.8 }}>ğŸ“­</div>
                  <div style={{ fontWeight: 600, color: '#888' }}>{t.prompts.noSaves || 'No saved cards found.'}</div>
                </div>
              ) : (
                <div className="saved-cards-grid">
                  {cards.map(card => (
                    <div key={card.id} className="saved-card-item" onClick={() => onLoad(card)} title={t.buttons.load}>
                      <button
                        className="delete-card-btn"
                        onClick={(e) => { e.stopPropagation(); onDelete(card.id); }}
                        title={t.buttons.remove}
                      >
                        &times;
                      </button>
                      <div className="saved-card-preview" style={{ backgroundImage: `url(${card.thumbnail || card.image})`, backgroundSize: 'cover', backgroundPosition: 'top center' }}>
                        {!card.image && !card.thumbnail && <span style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', fontSize: '3em' }}>ğŸƒ</span>}
                      </div>
                      <div className="saved-card-info">
                        <div className="saved-card-name">{card.name}</div>
                        <div className="saved-card-date">{new Date(card.timestamp).toLocaleDateString()} â€¢ {new Date(card.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
            <div className="modal-footer" style={{ marginTop: '20px', justifyContent: 'flex-end', gap: '12px' }}>
              <button className="secondary-button" onClick={onClose}>{t.common.close || 'Close'}</button>
              {cards.length > 0 && (
                <button className="primary-button" style={{ background: '#f44336' }} onClick={onDeleteAll}>
                  ğŸ—‘ï¸ {t.buttons.deleteAll || 'Delete All'}
                </button>
              )}
            </div>
          </div>
        </div>
      );
    };

    const InputGroup = React.memo(({
      id, label, type = 'text', value, onChange, min, max, step, maxLength, rows, options, style, className = '', disabled = false,
    }) => {
      const inputId = `input-${id}`;
      const handleChange = useCallback((e) => {
        onChange(e.target.value)
      }, [onChange]);
      const renderInput = () => {
        const commonProps = { id: inputId, value, onChange: handleChange, disabled };
        if (options) {
          return (<select {...commonProps}>
            {options.map(opt => (<option key={opt.value} value={opt.value}>
              {opt.label}
            </option>))}
          </select>)
        }
        if (rows) {
          return (<textarea
            {...commonProps}
            rows={rows}
            maxLength={maxLength}
            style={{ resize: 'none' }}
          />)
        }
        if (type === 'color') {
          const isHex = /^#[0-9A-Fa-f]{6}$/.test(value);
          const colorInputValue = isHex ? value : '#000000';
          return (<div className="color-input-wrapper"><input
            {...commonProps}
            value={colorInputValue}
            type="color"
            className="color-input"
          /><input
              type="text"
              value={value}
              onChange={handleChange}
              placeholder="#RRGGBB"
              className="color-text-input"
              maxLength={7}
            /></div>)
        }
        return (<input
          {...commonProps}
          type={type}
          min={min}
          max={max}
          step={step}
          maxLength={maxLength}
        />)
      };
      return (<div className={`input-group ${className}`} style={style}><label htmlFor={inputId}>{label}</label>
        {renderInput()}
      </div>)
    });
    InputGroup.displayName = 'InputGroup';
    const Checkbox = React.memo(({ id, label, checked, onChange }) => {
      const inputId = `checkbox-${id}`;
      return (<div className="checkbox-group"><input
        type="checkbox"
        id={inputId}
        checked={checked}
        onChange={(e) => onChange(e.target.checked)}
      /><label htmlFor={inputId}>{label}</label></div>)
    });
    Checkbox.displayName = 'Checkbox';
    const EmojiInput = React.memo(({ label, value, onChange }) => {
      const { t } = useLanguage();
      const [isOpen, setIsOpen] = useState(false);
      const wrapperRef = useRef(null);
      const pickerRef = useRef(null);

      useEffect(() => {
        const handleClickOutside = (event) => {
          if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
            setIsOpen(false);
          }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, []);

      useEffect(() => {
        if (isOpen && pickerRef.current) {
          const picker = pickerRef.current;
          const handleEmojiClick = (event) => {
            onChange(event.detail.unicode);
            setIsOpen(false);
          };
          picker.addEventListener('emoji-click', handleEmojiClick);
          return () => picker.removeEventListener('emoji-click', handleEmojiClick);
        }
      }, [isOpen, onChange]);

      return (
        <div className="input-group" ref={wrapperRef}>
          <label>{label}</label>
          <div className="emoji-input-wrapper" style={{ position: 'relative' }}>
            <button
              type="button"
              className="emoji-btn"
              onClick={() => setIsOpen(!isOpen)}
              style={{
                width: '100%',
                padding: '8px',
                textAlign: 'left',
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '6px',
                color: '#fff',
                cursor: 'pointer',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                height: '42px'
              }}
            >
              <span style={{ fontSize: '1.2em' }}>{value || 'â“'}</span>
              <span style={{ fontSize: '0.8em', opacity: 0.7 }}>â–¼</span>
            </button>
            {isOpen && (
              <div className="emoji-picker-wrapper">
                <emoji-picker ref={pickerRef} class="dark"></emoji-picker>
              </div>
            )}
          </div>
        </div>
      );
    });
    EmojiInput.displayName = 'EmojiInput';
    const AttackInfoEditor = React.memo(({
      index, attack, typeIcon, onUpdate, onRemove, canRemove, t,
    }) => {
      const handleChange = useCallback((field, value) => {
        onUpdate(index, { ...attack, [field]: value })
      }, [index, attack, onUpdate]);
      const handleNumericChange = useCallback((field, value, min, max) => {
        const parsed = parseIntSafe(value, min);
        handleChange(field, clamp(parsed, min, max))
      }, [handleChange]);
      return (<div className="attack-editor"><div className="attack-header-edit"><h3 className="attack-title">
        {typeIcon} {t.sections.abilities} {index + 1}
      </h3>
        {canRemove && (<button
          type="button"
          className="remove-attack-btn"
          onClick={() => onRemove(index)}
          aria-label={t.buttons.remove}
        >
          âœ•
        </button>)}
      </div><div className="attack-grid"><InputGroup
        id={`attack-${attack.id}-name`}
        label={t.labels.abilityName}
        value={attack.name}
        onChange={(v) => handleChange('name', v)}
        maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
      /><InputGroup
            id={`attack-${attack.id}-damage`}
            label={t.labels.damage}
            type="number"
            value={attack.damage}
            onChange={(v) => handleNumericChange('damage', v, CARD_LIMITS.DAMAGE_MIN, CARD_LIMITS.DAMAGE_MAX)}
          /><InputGroup
            id={`attack-${attack.id}-cost`}
            label={t.labels.energyCost}
            type="number"
            value={attack.cost}
            onChange={(v) => handleNumericChange('cost', v, CARD_LIMITS.COST_MIN, CARD_LIMITS.COST_MAX)}
            min={CARD_LIMITS.COST_MIN}
            max={CARD_LIMITS.COST_MAX}
          /></div><InputGroup
          id={`attack-${attack.id}-desc`}
          label={t.labels.abilityDesc}
          value={attack.desc}
          onChange={(v) => handleChange('desc', v)}
          maxLength={CARD_LIMITS.ATTACK_DESC_MAX_LENGTH}
        /><Checkbox
          id={`attack-${attack.id}-show-damage`}
          label={t.checkboxes.showDamage || 'Afficher les dÃ©gÃ¢ts'}
          checked={attack.showDamage !== false}
          onChange={(v) => handleChange('showDamage', v)}
        />
      </div>)
    });
    AttackInfoEditor.displayName = 'AttackInfoEditor';

    const AttackStyleEditor = React.memo(({
      index, attack, typeIcon, onUpdate, t,
    }) => {
      const handleChange = useCallback((field, value) => {
        onUpdate(index, { ...attack, [field]: value })
      }, [index, attack, onUpdate]);
      return (<div className="attack-editor" style={{ marginBottom: '12px', padding: '12px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px' }}>
        <div className="attack-header-edit" style={{ marginBottom: '8px' }}>
          <h3 className="attack-title" style={{ fontSize: '14px', opacity: 0.8 }}>
            {typeIcon} {attack.name || `${t.sections.abilities} ${index + 1}`}
          </h3>
        </div>
        <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.backgroundStyle || "Background Style"}</label>
        <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
          <button
            className={`mode-toggle-btn ${attack.colorMode === 'solid' ? 'active' : ''}`}
            onClick={() => handleChange('colorMode', 'solid')}
          >
            {t.labels.solid || "Solid"}
          </button>
          <button
            className={`mode-toggle-btn ${attack.colorMode !== 'solid' ? 'active' : ''}`}
            onClick={() => handleChange('colorMode', 'gradient')}
          >
            {t.labels.gradient || "Gradient"}
          </button>
        </div>
        <div style={{ display: 'grid', gridTemplateColumns: attack.colorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px', minHeight: '74px' }}>
          <InputGroup
            id={`attack-${attack.id}-bg`}
            label={attack.colorMode === 'solid' ? (t.labels.backgroundColor || "Background") : (t.labels.primaryColor || "Primary")}
            type="color"
            value={attack.background || 'rgba(255, 255, 255, 0.7)'}
            onChange={(v) => handleChange('background', v)}
          />
          {attack.colorMode !== 'solid' && (
            <InputGroup
              id={`attack-${attack.id}-sec-bg`}
              label={t.labels.secondaryColor || "Secondary"}
              type="color"
              value={attack.secondaryBackground || '#ffffff'}
              onChange={(v) => handleChange('secondaryBackground', v)}
            />
          )}
        </div>
      </div>)
    });
    AttackStyleEditor.displayName = 'AttackStyleEditor';


    const ImageEditor = React.memo(({
      image, settings, onSettingsChange, isLoading, error, onUpload, onClear, t,
    }) => {
      const fileInputRef = useRef(null);
      const containerRef = useRef(null);
      const [isDragging, setIsDragging] = useState(false);
      const [isPanning, setIsPanning] = useState(false);
      const panStart = useRef({ x: 0, y: 0 });
      const offsetStart = useRef({ x: 0, y: 0 });
      const handleDragOver = useCallback((e) => {
        e.preventDefault();
        if (!isPanning) setIsDragging(true)
      }, [isPanning]);
      const handleDragLeave = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false)
      }, []);
      const handleDrop = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false);
        const file = e.dataTransfer.files[0];
        if (file) onUpload(file)
      }, [onUpload]);
      const handleClick = useCallback(() => {
        if (!image) fileInputRef.current?.click()
      }, [image]);
      const handleFileChange = useCallback((e) => {
        const file = e.target.files?.[0];
        if (file) onUpload(file);
        e.target.value = ''
      }, [onUpload]);
      const handleZoomChange = useCallback((value) => {
        const zoom = parseFloatSafe(value, 1);
        const clampedZoom = clamp(zoom, CARD_LIMITS.ZOOM_MIN, CARD_LIMITS.ZOOM_MAX);
        onSettingsChange({
          ...settings, zoom: clampedZoom, offsetX: clamp(settings.offsetX, -(clampedZoom - 1) * 50 - 30, (clampedZoom - 1) * 50 + 30), offsetY: clamp(settings.offsetY, -(clampedZoom - 1) * 50 - 30, (clampedZoom - 1) * 50 + 30)
        })
      }, [settings, onSettingsChange]);
      const handlePanStart = useCallback((e) => {
        if (!image) return;
        e.preventDefault();
        setIsPanning(true);
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        panStart.current = { x: clientX, y: clientY };
        offsetStart.current = { x: settings.offsetX, y: settings.offsetY }
      }, [image, settings.offsetX, settings.offsetY]);
      const handlePanMove = useCallback((e) => {
        if (!isPanning) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const deltaX = clientX - panStart.current.x;
        const deltaY = clientY - panStart.current.y;
        const maxOffset = (settings.zoom - 1) * 50 + 30;
        const newOffsetX = clamp(offsetStart.current.x + deltaX, -maxOffset, maxOffset);
        const newOffsetY = clamp(offsetStart.current.y + deltaY, -maxOffset, maxOffset);
        onSettingsChange({
          zoom: settings.zoom, offsetX: newOffsetX, offsetY: newOffsetY
        })
      }, [isPanning, settings.zoom, onSettingsChange]);
      const handlePanEnd = useCallback(() => {
        setIsPanning(false)
      }, []);
      const handleReset = useCallback(() => {
        onSettingsChange(INITIAL_IMAGE_SETTINGS)
      }, [onSettingsChange]);
      return (<div className="image-editor"><div className="image-editor-header">
        {image && (<div className="image-actions"><button type="button" onClick={() => fileInputRef.current?.click()} className="small-btn">
          {t.buttons.change}
        </button><button type="button" onClick={handleReset} className="small-btn">
            {t.buttons.recenter}
          </button><button type="button" onClick={onClear} className="small-btn danger">
            {t.buttons.remove}
          </button></div>)}
      </div><div
        ref={containerRef}
        className={`image-preview-container ${isDragging ? 'dragging' : ''} ${error ? 'error' : ''} ${image ? 'has-image' : ''}`}
        onClick={handleClick}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onMouseDown={image ? handlePanStart : undefined}
        onMouseMove={image ? handlePanMove : undefined}
        onMouseUp={handlePanEnd}
        onMouseLeave={handlePanEnd}
        onTouchStart={image ? handlePanStart : undefined}
        onTouchMove={image ? handlePanMove : undefined}
        onTouchEnd={handlePanEnd}
        role={image ? "application" : "button"}
        tabIndex={0}
        aria-label={t.imageEditor.dropHint}
      ><input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            accept="image/png,image/jpeg,image/gif,image/webp"
            style={{ display: 'none' }}
            aria-hidden="true"
          />
          {image ? (<div
            className="image-preview"
            style={{
              backgroundImage: `url(${image})`, backgroundSize: `${settings.zoom * 100}%`, backgroundPosition: `calc(50% + ${settings.offsetX}px) calc(50% + ${settings.offsetY}px)`, backgroundRepeat: 'no-repeat'
            }}
          >
            {isPanning && <div className="pan-overlay">â†”</div>}
          </div>) : (<div className="upload-placeholder"><div className="upload-icon">{isLoading ? 'â³' : 'ğŸ“·'}</div><div className="upload-text">
            {isLoading ? t.imageEditor.loading : error ? error : t.imageEditor.dropHint}
          </div><div className="upload-hint">{t.imageEditor.formats}</div></div>)}
        </div>
        {image && (<div className="image-controls"><div className="zoom-control"><label htmlFor="zoom-slider">{t.labels.zoom}:{(settings.zoom * 100).toFixed(0)}%</label><input
          id="zoom-slider"
          type="range"
          min={CARD_LIMITS.ZOOM_MIN}
          max={CARD_LIMITS.ZOOM_MAX}
          step={0.05}
          value={settings.zoom}
          onChange={(e) => handleZoomChange(e.target.value)}
        /></div></div>)}
      </div>)
    });
    ImageEditor.displayName = 'ImageEditor';

    const Card = React.memo(({
      cardData, attacks, image, imageSettings, mousePos, isHovering, cardRef, onMouseMove, onMouseEnter, onMouseLeave, autoRotate, t
    }) => {
      const typeData = ELEMENT_TYPES[cardData.type] || ELEMENT_TYPES.Neutral;
      const weaknessIcon = ELEMENT_TYPES[cardData.weakness]?.icon || cardData.weakness || 'â“';
      const resistanceIcon = ELEMENT_TYPES[cardData.resistance]?.icon || cardData.resistance || 'â“';
      const fontData = FONTS.find(f => f.id === cardData.font) || FONTS[0];
      const borderColor = cardData.borderColor || '#ffd700';
      const textColor = cardData.textColor || '#1a1a2e';

      // Use custom icon if available, otherwise fallback to type icon
      const displayIcon = cardData.customIcon || typeData.icon;

      const cardStyle = useMemo(() => {
        const capturing = document.body.classList.contains('is-capturing');
        return {
          transform: (isHovering && !capturing) ? `perspective(1000px) rotateY(${(mousePos.x - 0.5) * 15}deg) rotateX(${(0.5 - mousePos.y) * 15}deg) scale(1.02)` : 'perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)',
          transition: autoRotate ? 'none' : 'transform 0.12s ease-out'
        }
      }, [isHovering, mousePos.x, mousePos.y, autoRotate]);



      const imageStyle = useMemo(() => {
        const primary = cardData.primaryColor || typeData.primary;
        const baseStyle = { borderColor: primary };
        if (image) {
          return {
            ...baseStyle, backgroundImage: `url(${image})`, backgroundSize: `${imageSettings.zoom * 100}%`, backgroundPosition: `calc(50% + ${imageSettings.offsetX}px) calc(50% + ${imageSettings.offsetY}px)`, backgroundRepeat: 'no-repeat'
          }
        }
        const secondary = cardData.secondaryColor || typeData.secondary;
        return {
          ...baseStyle, background: `linear-gradient(135deg, ${primary}40, ${secondary}40)`
        }
      }, [image, imageSettings, typeData.primary, typeData.secondary, cardData.primaryColor, cardData.secondaryColor]);

      const cardGradient = useMemo(() => {
        // If manual background color is set (from Appearance tab), use it
        if (cardData.backgroundColor) {
          return cardData.backgroundColor;
        }
        // Otherwise use the Card Style settings
        const primary = cardData.primaryColor || typeData.primary;
        const secondary = cardData.secondaryColor || typeData.secondary;

        if (cardData.colorMode === 'solid') {
          return primary;
        }
        return `linear-gradient(135deg, ${primary} 0%, ${secondary} 50%, ${primary} 100%)`;
      }, [cardData.backgroundColor, cardData.colorMode, cardData.primaryColor, cardData.secondaryColor, typeData.primary, typeData.secondary]);

      // Particle settings
      const particleEmoji = cardData.particleEmoji || ELEMENT_PARTICLES[cardData.type]?.emoji || 'âœ¨';
      const particleCount = ELEMENT_PARTICLES[cardData.type]?.count || 6;
      const particleAnim = cardData.particleAnimation || 'float';

      return (<div
        ref={cardRef}
        className="card-container"
        style={cardStyle}
        onMouseMove={onMouseMove}
        onMouseEnter={onMouseEnter}
        onMouseLeave={onMouseLeave}
      ><div
        className="game-card"
        style={{
          background: cardGradient, borderColor: borderColor, fontFamily: fontData.family,
        }}
      >
          {/* Texture Layer */}
          {cardData.texture && cardData.texture !== 'none' && (
            <div className="texture-layer" style={{
              WebkitMaskImage: CARD_TEXTURES[cardData.texture],
              maskImage: CARD_TEXTURES[cardData.texture],
              backgroundColor: cardData.textureColor || '#000000'
            }}></div>
          )}

          {/* Inner card frame */}
          <div className="card-inner" style={{
            color: textColor,
            backgroundImage: cardData.cardInnerColorMode === 'gradient'
              ? `linear-gradient(180deg, ${cardData.cardInnerBackground}, ${cardData.cardInnerSecondaryBackground})`
              : 'none',
            backgroundColor: cardData.cardInnerColorMode === 'gradient' ? 'transparent' : cardData.cardInnerBackground
          }}>
            {/* Header */}
            <div className="card-header"><div className="card-header-left"><span className="stage-badge" style={{ background: cardData.primaryColor || typeData.primary, color: cardData.typeColor || 'inherit', fontSize: `${cardData.stageSize}px`, fontWeight: cardData.stageWeight }}>
              {t.stages[STAGES.indexOf(cardData.stage)] || cardData.stage}
            </span><span className="creature-name" style={{ color: cardData.nameColor || 'inherit', fontSize: `${cardData.nameSize}px`, fontWeight: cardData.nameWeight }}>{cardData.name}</span></div>
              {cardData.showHP && (<div className="card-header-right"><span className="hp-value" style={{ color: cardData.hpColor || 'inherit', fontSize: `${cardData.hpSize}px`, fontWeight: cardData.hpWeight }}>{t.card.hp} {cardData.hp}</span><span className="type-icon">{displayIcon}</span></div>)}
            </div>
            {/* Image */}
            <div className="card-image" style={imageStyle}>
              {!image && (<span className="placeholder-icon">{displayIcon}</span>)}
            </div>
            {/* Description bar */}
            {cardData.showDescription && cardData.description && (<div className="card-description" style={{ color: cardData.descColor || 'inherit', fontSize: `${cardData.descSize}px`, fontWeight: cardData.descWeight, lineHeight: cardData.descHeight || 1.3 }}>{cardData.description}</div>)}
            {/* Attacks */}
            <div className="attacks-container">
              {attacks.map((attack) => (
                <div key={attack.id} className="attack-card" style={{
                  backgroundImage: attack.colorMode === 'gradient'
                    ? `linear-gradient(180deg, ${attack.background}, ${attack.secondaryBackground})`
                    : 'none',
                  backgroundColor: attack.colorMode === 'gradient' ? 'transparent' : (attack.background || cardData.abilityBackground),
                  backgroundRepeat: 'no-repeat',
                  backgroundPosition: 'top center',
                  backgroundSize: '100% 102%'
                }}><div className="attack-header"><div className="attack-cost">
                  {[...Array(Math.max(0, Math.min(10, attack.cost)))].map((_, i) => (<span key={i} className="energy-icon">{displayIcon}</span>))}
                </div><span className="attack-name" style={{ color: cardData.moveNameColor || cardData.descColor || 'inherit', fontSize: `${cardData.moveNameSize}px`, fontWeight: cardData.moveNameWeight }}>{attack.name}</span>{attack.showDamage !== false && <span className="attack-damage" style={{ color: cardData.moveNameColor || cardData.descColor || 'inherit', fontSize: `${Number(cardData.moveNameSize) + 2}px`, fontWeight: cardData.moveNameWeight }}>{attack.damage}</span>}</div>
                  {attack.desc && <div className="attack-desc" style={{ color: cardData.moveDescColor || cardData.descColor || 'inherit', fontSize: `${cardData.moveDescSize}px`, fontWeight: cardData.moveDescWeight }}>{attack.desc}</div>}
                </div>))}
            </div>
            {/* Footer */}
            <div className="card-footer" style={{ '--stats-color': cardData.statsColor || undefined, color: cardData.statsColor || 'inherit', fontSize: `${cardData.statsSize}px`, fontWeight: cardData.statsWeight }}>
              {cardData.showWeakRes && (<div className="footer-stats"><div className="stat"><span className="stat-label">{t.card.weakness} </span><span className="stat-icon">{weaknessIcon}</span><span className="stat-value weakness"> Ã—2</span></div><div className="stat"><span className="stat-label">{t.card.resistance} </span><span className="stat-icon">{resistanceIcon}</span><span className="stat-value resistance"> -30</span></div></div>)}
              {cardData.showRetreat && (<div className="retreat-cost"><span className="stat-label">{t.card.cost} </span>
                {[...Array(Math.max(0, cardData.retreatCost))].map((_, i) => (<span key={i} className="retreat-icon">âšª</span>))}
              </div>)}
            </div>
            {/* Author */}
            <div className="card-author" style={{ color: cardData.authorColor || 'inherit', fontSize: `${cardData.authorSize}px`, fontWeight: cardData.authorWeight }}>
              {t.card.illus} {cardData.author} â€¢ Card Creator
            </div></div>

          {/* Particles layer */}
          {cardData.showParticles && (<div className={`particles-layer particles-${particleAnim}`}>
            {[...Array(particleCount)].map((_, i) => (<span
              key={i}
              className={`particle particle-${i % 3}`}
              style={{
                left: `${3 + (i * 31) % 94}%`,
                top: `${2 + (i * 37) % 96}%`,
                animationDelay: `${i * 0.5}s`,
                fontSize: `${10 + (i * 5) % 15}px`,
                position: 'absolute'
              }}
            >
              {particleEmoji}
            </span>))}
          </div>)}
        </div></div>)
    });

    Card.displayName = 'Card';
    const CollapsibleSection = React.memo(({ title, icon, children, defaultOpen = true, isOpen: controlledIsOpen, onToggle }) => {
      const [internalIsOpen, setInternalIsOpen] = useState(defaultOpen);
      const isControlled = controlledIsOpen !== undefined;
      const isOpen = isControlled ? controlledIsOpen : internalIsOpen;

      const handleToggle = () => {
        if (isControlled) {
          onToggle && onToggle();
        } else {
          setInternalIsOpen(!internalIsOpen);
        }
      };

      return (<div className={`collapsible-section ${isOpen ? 'open' : ''}`}><button
        type="button"
        className="collapsible-header"
        onClick={handleToggle}
        aria-expanded={isOpen}
      ><span>{icon} {title}</span><span className="collapse-icon">{isOpen ? 'â–¼' : 'â–¶'}</span></button>
        {isOpen && <div className="collapsible-content">{children}</div>}
      </div>)
    });
    CollapsibleSection.displayName = 'CollapsibleSection';

    const TextSettingsGroup = React.memo(({ label, colorKey, sizeKey, weightKey, cardData, updateCardData, t, showColor = true }) => {
      const [isOpen, setIsOpen] = useState(false);
      const currentColor = cardData[colorKey] || cardData.textColor || '#1a1a2e';

      return (
        <div className="text-settings-group" style={{ marginBottom: '8px', background: 'rgba(255,255,255,0.03)', borderRadius: '8px', overflow: 'hidden' }}>
          <button
            type="button"
            onClick={() => setIsOpen(!isOpen)}
            style={{
              width: '100%',
              padding: '10px 12px',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              background: 'none',
              border: 'none',
              color: 'white',
              cursor: 'pointer',
              textAlign: 'left'
            }}
          >
            <span style={{ fontSize: '13px', fontWeight: 600, opacity: 0.9 }}>{label}</span>
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>

              <span style={{ fontSize: '10px', opacity: 0.5, transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>â–¼</span>
            </div>
          </button>

          {isOpen && (
            <div style={{ padding: '12px', paddingTop: '0' }}>
              <div style={{ display: 'grid', gap: '12px' }}>
                {showColor && (
                  <InputGroup
                    id={`${colorKey}-input`}
                    label={t.labels.textColor}
                    type="color"
                    value={currentColor}
                    onChange={(v) => updateCardData(colorKey, v)}
                  />
                )}
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                  {sizeKey && (
                    <InputGroup
                      id={`${sizeKey}-input`}
                      label={t.labels.size}
                      type="number"
                      value={cardData[sizeKey]}
                      onChange={(v) => updateCardData(sizeKey, Number(v))}
                    />
                  )}
                  {weightKey && (
                    <div className="input-group">
                      <label htmlFor={`${weightKey}-input`}>{t.labels.weight}</label>
                      <select
                        id={`${weightKey}-input`}
                        value={cardData[weightKey]}
                        onChange={(e) => updateCardData(weightKey, e.target.value)}
                        style={{ width: '100%' }}
                      >
                        <option value="400">Normal</option>
                        <option value="700">Bold</option>
                        <option value="900">Black</option>
                      </select>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      );
    });

    function CardCreatorContent() {
      const { lang, setLang, t, isGifSupported } = useContext(LanguageContext);
      const { notify } = useNotification();
      const [cardData, setCardData] = useState(() => getInitialCardData(t));
      const [attacks, setAttacks] = useState(() => getInitialAttacks(t));
      const [image, setImage] = useState(null);
      const [imageSettings, setImageSettings] = useState(INITIAL_IMAGE_SETTINGS);
      const [imageLoading, setImageLoading] = useState(false);
      const [imageError, setImageError] = useState(null);
      const [mousePos, setMousePos] = useState({ x: 0.5, y: 0.5 });
      const [isHovering, setIsHovering] = useState(false);
      const [autoRotate, setAutoRotate] = useState(true);
      const [activeTab, setActiveTab] = useState('visual');
      const [openSection, setOpenSection] = useState('image'); // Default open section for visual tab
      const [showResetConfirm, setShowResetConfirm] = useState(false);

      // Save/Load State
      const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
      const [isLoadModalOpen, setIsLoadModalOpen] = useState(false);
      const [savedCards, setSavedCards] = useState([]);
      const [isLoading, setIsLoading] = useState(false); // Local loading state for save/load operations

      // Confirm Modal State
      const [confirmState, setConfirmState] = useState({ isOpen: false, title: '', message: '', onConfirm: null });
      const openConfirm = (title, message, onConfirm) => {
        setConfirmState({ isOpen: true, title, message, onConfirm });
      };

      const openLoadModal = async () => {
        try {
          // Auto-delete cards older than 30 days
          await db.cleanupOld(30);
          const cards = await db.getAll();
          setSavedCards(cards);
          setIsLoadModalOpen(true);
        } catch (err) {
          console.error('Error loading cards:', err);
          notify(t.prompts.saveError || 'Could not load cards', 'error');
        }
      };

      const handleSaveCard = async (saveName) => {
        setIsLoading(true);
        try {
          const cardElement = document.querySelector('.game-card');
          const canvas = await html2canvas(cardElement, {
            scale: 0.5,
            backgroundColor: null,
            logging: false,
            useCORS: true
          });
          const thumbnail = canvas.toDataURL('image/jpeg', 0.7);

          const newCard = {
            id: crypto.randomUUID(),
            timestamp: Date.now(),
            name: saveName || cardData.name || 'Untitled',
            cardData,
            attacks,
            image: image,
            thumbnail: thumbnail
          };

          await db.save(newCard);
          setIsSaveModalOpen(false);
          notify(t.prompts.saveSuccess || 'Card saved successfully!', 'success');
        } catch (err) {
          console.error('Save failed:', err);
          if (err.name === 'QuotaExceededError') {
            notify(t.prompts.quotaError || 'Storage full!', 'error');
          } else {
            notify(t.notifications?.saveError || 'Error saving card.', 'error');
          }
        } finally {
          setIsLoading(false);
        }
      };

      const handleLoadCard = (savedCard) => {
        setCardData({ ...getInitialCardData(t), ...savedCard.cardData });
        setAttacks(savedCard.attacks);
        setImage(savedCard.image || null);
        setIsLoadModalOpen(false);
        notify(t.notifications?.cardLoaded || 'Card loaded!', 'success');
      };

      const handleDeleteCard = async (id) => {
        openConfirm(
          t.buttons.remove,
          t.prompts.deleteConfirm || "Delete this saved card?",
          async () => {
            try {
              await db.delete(id);
              const cards = await db.getAll();
              setSavedCards(cards);
              setConfirmState(prev => ({ ...prev, isOpen: false }));
              notify(t.notifications?.cardDeleted || 'Card deleted', 'info');
            } catch (err) {
              console.error(err);
              notify(t.notifications?.deleteError || 'Failed to delete card', 'error');
            }
          }
        );
      };

      const handleDeleteAllCards = () => {
        openConfirm(
          t.buttons.deleteAll || 'Delete All',
          t.prompts.deleteAllConfirm || 'Delete all saved cards? This cannot be undone.',
          async () => {
            try {
              await db.deleteAll();
              setSavedCards([]);
              setConfirmState(prev => ({ ...prev, isOpen: false }));
              notify(t.notifications?.allDeleted || 'All cards deleted', 'info');
            } catch (err) {
              console.error(err);
              notify(t.notifications?.deleteError || 'Failed to delete cards', 'error');
            }
          }
        );
      };
      const cardRef = useRef(null);
      const autoRotateRef = useRef(null);
      useEffect(() => {
        const modal = document.getElementById('gif-instructions-modal');
        if (modal && t && t.gifModal) {
          const gm = t.gifModal;
          const titleEl = modal.querySelector('h3');
          if (titleEl) titleEl.textContent = gm.title;

          const bodyEl = modal.querySelector('p');
          if (bodyEl) bodyEl.textContent = gm.body;

          const step1 = modal.querySelector('#gif-modal-step-1');
          if (step1) step1.innerHTML = gm.step1;
          const step2 = modal.querySelector('#gif-modal-step-2');
          if (step2) step2.innerHTML = gm.step2;
          const step3 = modal.querySelector('#gif-modal-step-3');
          if (step3) step3.innerHTML = gm.step3;

          const noteEl = modal.querySelector('.modal-note span:last-child');
          if (noteEl) noteEl.textContent = gm.note;

          const warningEl = modal.querySelector('.modal-warning span:last-child');
          if (warningEl && gm.warning) warningEl.textContent = gm.warning;

          const fpsLabel = modal.querySelector('#gif-fps-label');
          if (fpsLabel && gm.fpsLabel) fpsLabel.textContent = gm.fpsLabel;

          const qualityLabel = modal.querySelector('#gif-quality-label');
          if (qualityLabel && gm.qualityLabel) qualityLabel.textContent = gm.qualityLabel;

          const fpsNormal = modal.querySelector('#gif-fps-normal');
          if (fpsNormal && gm.fpsNormal) fpsNormal.textContent = gm.fpsNormal;
          const fpsCinema = modal.querySelector('#gif-fps-cinema');
          if (fpsCinema && gm.fpsCinema) fpsCinema.textContent = gm.fpsCinema;
          const fpsSmooth = modal.querySelector('#gif-fps-smooth');
          if (fpsSmooth && gm.fpsSmooth) fpsSmooth.textContent = gm.fpsSmooth;
          const fpsUltra = modal.querySelector('#gif-fps-ultra');
          if (fpsUltra && gm.fpsUltra) fpsUltra.textContent = gm.fpsUltra;

          const qualitySD = modal.querySelector('#gif-quality-sd');
          if (qualitySD && gm.qualitySD) qualitySD.textContent = gm.qualitySD;
          const qualityNormal = modal.querySelector('#gif-quality-normal');
          if (qualityNormal && gm.qualityNormal) qualityNormal.textContent = gm.qualityNormal;
          const qualityHigh = modal.querySelector('#gif-quality-high');
          if (qualityHigh && gm.qualityHigh) qualityHigh.textContent = gm.qualityHigh;
          const qualityQHD = modal.querySelector('#gif-quality-qhd');
          if (qualityQHD && gm.qualityQHD) qualityQHD.textContent = gm.qualityQHD;
          const qualityUltra = modal.querySelector('#gif-quality-ultra');
          if (qualityUltra && gm.qualityUltra) qualityUltra.textContent = gm.qualityUltra;

          const cancelBtn = document.getElementById('cancel-gif-btn');
          if (cancelBtn) cancelBtn.textContent = gm.cancel;
          const startBtn = document.getElementById('start-gif-btn');
          if (startBtn) startBtn.textContent = gm.start;
        }
      }, [t]);

      useEffect(() => {
        const capturing = document.body.classList.contains('is-capturing');
        if (autoRotate && !capturing) {
          let angle = 0;
          setIsHovering(true); // Active l'effet 3D
          autoRotateRef.current = setInterval(() => {
            angle += 0.025; // Mouvement plus lent et fluide
            const x = 0.5 + Math.sin(angle) * 0.35;
            const y = 0.5 + Math.sin(angle * 2) * 0.25;
            setMousePos({ x, y })
          }, 40)
        } else {
          if (autoRotateRef.current) {
            clearInterval(autoRotateRef.current);
            autoRotateRef.current = null
          }
          setIsHovering(false);
          setMousePos({ x: 0.5, y: 0.5 })
        }
        return () => {
          if (autoRotateRef.current) {
            clearInterval(autoRotateRef.current)
          }
        }
      }, [autoRotate]);
      const handleMouseEnterManual = useCallback(() => {
        if (document.body.classList.contains('is-capturing')) return;
        if (autoRotate && autoRotateRef.current) {
          clearInterval(autoRotateRef.current);
          autoRotateRef.current = null
        }
        setIsHovering(true)
      }, [autoRotate]);
      const handleMouseLeaveManual = useCallback(() => {
        if (document.body.classList.contains('is-capturing')) return;
        if (autoRotate) {
          let angle = 0;
          autoRotateRef.current = setInterval(() => {
            angle += 0.025;
            const x = 0.5 + Math.sin(angle) * 0.35;
            const y = 0.5 + Math.sin(angle * 2) * 0.25;
            setMousePos({ x, y })
          }, 40);
          setIsHovering(true); // Garder l'effet 3D actif
        } else {
          setIsHovering(false);
          setMousePos({ x: 0.5, y: 0.5 })
        }
      }, [autoRotate]);
      const updateCardData = useCallback((field, value) => {
        setCardData(prev => ({ ...prev, [field]: value }))
      }, []);
      const updateCardDataNumeric = useCallback((field, value, min, max) => {
        const parsed = parseIntSafe(value, min);
        setCardData(prev => ({ ...prev, [field]: clamp(parsed, min, max) }))
      }, []);
      const updateAttack = useCallback((index, newAttack) => {
        setAttacks(prev => prev.map((a, i) => i === index ? newAttack : a))
      }, []);
      const addAttack = useCallback(() => {
        if (attacks.length >= 3) return;
        setAttacks(prev => [...prev, { id: generateId(), name: t.defaults.newAbility, damage: 50, cost: 2, desc: '', showDamage: true, background: 'rgba(255, 255, 255, 0.7)', colorMode: 'solid', secondaryBackground: '#ffffff' }])
      }, [attacks.length, t]);
      const removeAttack = useCallback((index) => {
        if (attacks.length <= 1) return;
        setAttacks(prev => prev.filter((_, i) => i !== index))
      }, [attacks.length]);
      const processImageFile = useCallback((file) => {
        if (!file) return;
        const validTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
        if (!validTypes.includes(file.type)) {
          setImageError(t.imageEditor.unsupportedFormat);
          return
        }
        if (file.size > CARD_LIMITS.MAX_FILE_SIZE) {
          setImageError(t.imageEditor.fileTooLarge);
          return
        }
        setImageLoading(true);
        setImageError(null);
        const reader = new FileReader();
        reader.onload = (e) => {
          setImage(e.target.result);
          setImageSettings(INITIAL_IMAGE_SETTINGS);
          setImageLoading(false)
        };
        reader.onerror = () => {
          setImageError('Error');
          setImageLoading(false)
        };
        reader.readAsDataURL(file)
      }, [t]);
      const clearImage = useCallback(() => {
        setImage(null);
        setImageSettings(INITIAL_IMAGE_SETTINGS);
        setImageError(null)
      }, []);
      const handleMouseMoveThrottled = useCallback((e) => {
        if (document.body.classList.contains('is-capturing')) return;
        if (!cardRef.current) return;
        const rect = cardRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        setMousePos({ x: clamp(x, 0, 1), y: clamp(y, 0, 1) })
      }, []);
      const handleMouseMove = useThrottle(handleMouseMoveThrottled, 16);
      const typeOptions = useMemo(() => ELEMENT_KEYS.map(type => ({
        value: type, label: `${ELEMENT_TYPES[type].icon} ${t.elements[type] || type}`
      })),
        [t]);
      const stageOptions = useMemo(() => STAGES.map((stage, index) => ({
        value: stage, label: t.stages[index] || stage
      })),
        [t]);
      const fontOptions = useMemo(() => FONTS.map(font => ({ value: font.id, label: font.name })),
        []);
      const textureOptions = useMemo(() => Object.keys(CARD_TEXTURES).map(key => ({
        value: key, label: t.textures?.[key] || key
      })), [t]);
      const typeIcon = ELEMENT_TYPES[cardData.type]?.icon || 'â­';
      return (<div className="app-container">
        <div className="header-controls">
          <div className="header-btn-group">
            <button className="header-btn save" onClick={() => setIsSaveModalOpen(true)} title={t.buttons.save || 'Save'}>
              ğŸ’¾ <span className="btn-text">{t.buttons.save || 'Save'}</span>
            </button>
            <button className="header-btn load" onClick={openLoadModal} title={t.buttons.load || 'Load'}>
              ğŸ“‚ <span className="btn-text">{t.buttons.load || 'Load'}</span>
            </button>
          </div>
          <select
            value={lang}
            onChange={(e) => setLang(e.target.value)}
            className="lang-select"
          >
            {Object.entries(LANGUAGES).map(([code, { name, flag }]) => (
              <option key={code} value={code}>
                {name}
              </option>
            ))}
          </select>
        </div>
        <h1 className="title">âœ¨ {t.appTitle} âœ¨</h1><p className="subtitle">{t.appSubtitle}</p>
        <div className="main-layout">
          <div className="card-preview">
            {/* Card Preview */}
            <Card
              cardData={cardData}
              attacks={attacks}
              image={image}
              imageSettings={imageSettings}
              mousePos={mousePos}
              isHovering={isHovering}
              cardRef={cardRef}
              onMouseMove={handleMouseMove}
              onMouseEnter={handleMouseEnterManual}
              onMouseLeave={handleMouseLeaveManual}
              autoRotate={autoRotate}
              t={t}
            /><p className="hover-hint">{t.hoverHint}</p>
            {/* Auto Rotate Button */}
            <button
              className={`auto-rotate-btn ${autoRotate ? 'active' : ''}`}
              onClick={() => setAutoRotate(!autoRotate)}
            >
              {autoRotate ? 'â¸ï¸' : 'â–¶ï¸'} {t.buttons.autoRotate || "Vue 3D"}
            </button>
            {/* Download & Reset Group - Matches width */}
            <div style={{ display: 'flex', flexDirection: 'column', width: 'fit-content', alignItems: 'stretch', marginTop: '24px' }}>
              <div className="download-section" style={{ width: '100%', boxSizing: 'border-box', marginTop: 0 }}>
                <p className="download-title" style={{ marginTop: 0 }}>{t.download.title}</p>
                <div className="download-buttons">
                  <button
                    className="download-btn download-png"
                    onClick={() => downloadAsPNG(cardRef.current, cardData.name || 'card')}
                    title={t.download.pngTitle}
                  >
                    ğŸ–¼ï¸ PNG
                  </button>
                  <button
                    className="download-btn download-jpg"
                    onClick={() => downloadAsJPG(cardRef.current, cardData.name || 'card')}
                    title={t.download.jpgTitle}
                  >
                    ğŸ“· JPG
                  </button>
                  <button
                    className="download-btn download-webp"
                    onClick={() => downloadAsWebP(cardRef.current, cardData.name || 'card')}
                    title={t.download.webpTitle}
                  >
                    ğŸŒ WebP
                  </button>
                  {isGifSupported && (
                    <button
                      className="download-btn download-gif"
                      onClick={async (e) => {
                        const btn = e.currentTarget;
                        const originalText = btn.textContent;

                        try {
                          btn.textContent = t.download.capturing;
                          btn.disabled = true;
                          await downloadAsGIF(
                            cardRef.current,
                            cardData.name || 'card',
                            3000,
                            10,
                            t,
                            (text) => { btn.textContent = text; }
                          );
                        } catch (err) {
                          // Silent catch
                        } finally {
                          btn.textContent = originalText;
                          btn.disabled = false;
                        }
                      }}
                      title={t.download.gifTitle}
                    >
                      ğŸ¬ GIF
                    </button>
                  )}

                </div>
              </div>

              {/* Reset Button */}
              <div style={{ marginTop: '10px' }}>
                <button
                  className="no-capture"
                  onClick={() => {
                    setShowResetConfirm(true);
                  }}
                  style={{ width: '100%', padding: '12px', background: 'rgba(244, 67, 54, 0.1)', color: '#f44336', border: '1px solid rgba(244, 67, 54, 0.2)', borderRadius: '8px', cursor: 'pointer', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px', transition: 'all 0.2s' }}
                  onMouseOver={(e) => { e.currentTarget.style.background = 'rgba(244, 67, 54, 0.2)'; }}
                  onMouseOut={(e) => { e.currentTarget.style.background = 'rgba(244, 67, 54, 0.1)'; }}
                >
                  {t.buttons.resetCard}
                </button>
              </div>
            </div>
          </div>
          {/* Editor Panel */}
          <div className="editor-panel">
            <div className="editor-tabs">
              <button
                className={`tab-btn ${activeTab === 'visual' ? 'active' : ''}`}
                onClick={() => { setActiveTab('visual'); setOpenSection('image'); }}
              >
                ğŸ“· {t.tabs.visual}
              </button>
              <button
                className={`tab-btn ${activeTab === 'content' ? 'active' : ''}`}
                onClick={() => { setActiveTab('content'); setOpenSection('basicInfo'); }}
              >
                ğŸ“ {t.tabs.content || t.tabs.info}
              </button>
              <button
                className={`tab-btn ${activeTab === 'colors' ? 'active' : ''}`}
                onClick={() => { setActiveTab('colors'); setOpenSection('cardStyle'); }}
              >
                ğŸ¨ {t.tabs.colors || t.tabs.style}
              </button>

            </div>

            <div className="tab-content">
              {activeTab === 'content' && (
                <>
                  <CollapsibleSection
                    title={t.sections.basicInfo}
                    icon="ğŸ“"
                    isOpen={openSection === 'basicInfo'}
                    onToggle={() => setOpenSection(openSection === 'basicInfo' ? null : 'basicInfo')}
                  >
                    <div className="grid-2">
                      <InputGroup
                        id="creature-name"
                        label={t.labels.name}
                        value={cardData.name}
                        onChange={(v) => updateCardData('name', v)}
                        maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
                      />
                      <InputGroup
                        id="creature-hp"
                        label={t.labels.hp}
                        type="number"
                        value={cardData.hp}
                        onChange={(v) => updateCardDataNumeric('hp', v, CARD_LIMITS.HP_MIN, CARD_LIMITS.HP_MAX)}
                        min={CARD_LIMITS.HP_MIN}
                        max={CARD_LIMITS.HP_MAX}
                      />
                    </div>
                    <InputGroup
                      id="creature-stage"
                      label={t.labels.stage}
                      value={cardData.stage}
                      onChange={(v) => updateCardData('stage', v)}
                      options={stageOptions}
                    />
                    <InputGroup
                      id="creature-description"
                      label={t.labels.description}
                      value={cardData.description}
                      onChange={(v) => updateCardData('description', v)}
                      rows={2}
                      maxLength={CARD_LIMITS.DESC_MAX_LENGTH}
                    />
                    <InputGroup
                      id="creature-author"
                      label={t.labels.author}
                      value={cardData.author}
                      onChange={(v) => updateCardData('author', v)}
                      maxLength={CARD_LIMITS.AUTHOR_MAX_LENGTH}
                    />
                  </CollapsibleSection>


                  <CollapsibleSection
                    title={t.sections.abilities || "Abilities Info"}
                    icon="âš”ï¸"
                    isOpen={openSection === 'abilitiesInfo'}
                    onToggle={() => setOpenSection(openSection === 'abilitiesInfo' ? null : 'abilitiesInfo')}
                  >
                    {attacks.map((attack, idx) => (
                      <AttackInfoEditor
                        key={attack.id}
                        index={idx}
                        attack={attack}
                        typeIcon={typeIcon}
                        onUpdate={updateAttack}
                        onRemove={removeAttack}
                        canRemove={attacks.length > 1}
                        t={t}
                      />
                    ))}
                    <button
                      type="button"
                      className="add-attack-btn"
                      onClick={addAttack}
                      disabled={attacks.length >= 3}
                    >
                      {t.buttons.addAbility} {attacks.length >= 3 && '(max 3)'}
                    </button>
                  </CollapsibleSection>

                  <CollapsibleSection
                    title={t.sections.stats}
                    icon="ğŸ“Š"
                    isOpen={openSection === 'stats'}
                    onToggle={() => setOpenSection(openSection === 'stats' ? null : 'stats')}
                  >
                    <div className="grid-3">
                      <EmojiInput
                        label={t.labels.weakness}
                        value={cardData.weakness}
                        onChange={(v) => updateCardData('weakness', v)}
                      />
                      <EmojiInput
                        label={t.labels.resistance}
                        value={cardData.resistance}
                        onChange={(v) => updateCardData('resistance', v)}
                      />
                      <InputGroup
                        id="creature-retreat"
                        label={t.labels.retreatCost}
                        type="number"
                        value={cardData.retreatCost}
                        onChange={(v) => updateCardDataNumeric('retreatCost', v, CARD_LIMITS.RETREAT_MIN, CARD_LIMITS.RETREAT_MAX)}
                        min={CARD_LIMITS.RETREAT_MIN}
                        max={CARD_LIMITS.RETREAT_MAX}
                      />
                    </div>
                  </CollapsibleSection>

                </>
              )}


              {activeTab === 'visual' && (
                <>
                  <CollapsibleSection
                    title={t.sections.image}
                    icon="ğŸ“·"
                    isOpen={openSection === 'image'}
                    onToggle={() => setOpenSection(openSection === 'image' ? null : 'image')}
                  >
                    <ImageEditor
                      image={image}
                      settings={imageSettings}
                      onSettingsChange={setImageSettings}
                      isLoading={imageLoading}
                      error={imageError}
                      onUpload={processImageFile}
                      onClear={clearImage}
                      t={t}
                    />
                  </CollapsibleSection>

                  {/* Presets Section - Moved from style tab */}
                  <CollapsibleSection
                    title={t.labels.presets || "Presets"}
                    icon="âš¡"
                    isOpen={openSection === 'presets'}
                    onToggle={() => setOpenSection(openSection === 'presets' ? null : 'presets')}
                  >
                    <div className="icon-presets" style={{ display: 'grid', gridTemplateColumns: 'repeat(6, 1fr)', gap: '8px' }}>
                      {Object.entries(ELEMENT_TYPES).map(([key, data]) => (
                        <button
                          key={key}
                          type="button"
                          className="preset-btn"
                          onClick={() => {
                            setCardData(prev => ({
                              ...prev,
                              customIcon: data.icon,
                              primaryColor: data.primary,
                              secondaryColor: data.secondary,
                              particleEmoji: ELEMENT_PARTICLES[key]?.emoji || 'âœ¨',
                              particleAnimation: key.toLowerCase(),
                              type: key,
                              weakness: data.weakness,
                              resistance: data.resistance,
                              cardInnerBackground: 'rgba(255, 255, 255, 0.95)',
                              cardInnerColorMode: 'solid',
                              cardInnerSecondaryBackground: `${data.primary}10`,
                              borderColor: data.primary,
                              nameColor: '', hpColor: '', typeColor: '', descColor: '', statsColor: '', authorColor: '', textColor: ''
                            }));
                            setAttacks(prev => prev.map(a => ({
                              ...a,
                              background: data.primary + '40',
                              secondaryBackground: data.secondary + '40',
                              colorMode: 'gradient'
                            })));
                          }}
                          title={t.elements[key] || key}
                          style={{
                            backgroundColor: data.primary + '20',
                            border: '1px solid ' + data.primary + '40',
                            borderRadius: '6px',
                            padding: '8px',
                            cursor: 'pointer',
                            fontSize: '1.2em',
                            transition: 'all 0.2s'
                          }}
                          onMouseEnter={(e) => {
                            e.currentTarget.style.backgroundColor = data.primary + '40';
                            e.currentTarget.style.transform = 'scale(1.05)';
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor = data.primary + '20';
                            e.currentTarget.style.transform = 'scale(1)';
                          }}
                        >
                          {data.icon}
                        </button>
                      ))}
                    </div>
                  </CollapsibleSection>

                  <CollapsibleSection
                    title={t.sections.particles || "Particles"}
                    icon="âœ¨"
                    isOpen={openSection === 'particles'}
                    onToggle={() => setOpenSection(openSection === 'particles' ? null : 'particles')}
                  >
                    <div className="grid-2">
                      <EmojiInput
                        label={t.labels.particleEmoji || "Particle Emoji"}
                        value={cardData.particleEmoji}
                        onChange={(v) => updateCardData('particleEmoji', v)}
                      />
                      <InputGroup
                        id="particle-animation"
                        label={t.labels.animation || "Animation"}
                        value={cardData.particleAnimation || 'fire'}
                        onChange={(v) => updateCardData('particleAnimation', v)}
                        options={PARTICLE_ANIMATIONS.map(anim => ({ value: anim.key, label: t.animations?.[anim.key] || anim.label }))}
                      />
                    </div>
                    <div style={{ marginTop: '12px' }}>
                      <Checkbox
                        id="show-particles"
                        label={t.checkboxes.showParticles}
                        checked={cardData.showParticles}
                        onChange={(v) => updateCardData('showParticles', v)}
                      />
                    </div>
                  </CollapsibleSection>

                </>
              )}

              {activeTab === 'colors' && (
                <>
                  {/* Card Style Section */}
                  <CollapsibleSection
                    title={t.sections.cardStyle || "Card Style"}
                    icon="ğŸ¨"
                    isOpen={openSection === 'cardStyle'}
                    onToggle={() => setOpenSection(openSection === 'cardStyle' ? null : 'cardStyle')}
                  >
                    <div className="grid-2" style={{ marginBottom: '12px' }}>
                      <EmojiInput
                        label={t.labels.element}
                        value={cardData.customIcon}
                        onChange={(v) => updateCardData('customIcon', v)}
                      />
                      <InputGroup
                        id="creature-stage"
                        label={t.labels.stage}
                        value={cardData.stage}
                        onChange={(v) => updateCardData('stage', v)}
                        options={stageOptions}
                      />
                    </div>
                    <div style={{ marginBottom: '12px', display: 'grid', gridTemplateColumns: cardData.texture && cardData.texture !== 'none' ? '2fr 1fr' : '1fr', gap: '8px' }}>
                      <InputGroup
                        id="card-texture"
                        label={t.labels.texture || "Texture"}
                        value={cardData.texture || 'none'}
                        onChange={(v) => updateCardData('texture', v)}
                        options={textureOptions}
                      />
                      {cardData.texture && cardData.texture !== 'none' && (
                        <InputGroup
                          id="texture-color"
                          label="Color"
                          type="color"
                          value={cardData.textureColor || '#000000'}
                          onChange={(v) => updateCardData('textureColor', v)}
                        />
                      )}
                    </div>
                    <div style={{ marginBottom: '12px' }}>
                      <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.backgroundStyle || "Background Style"}</label>
                      <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                        <button
                          className={`mode-toggle-btn ${cardData.colorMode === 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('colorMode', 'solid')}
                        >
                          {t.labels.solid || "Solid"}
                        </button>
                        <button
                          className={`mode-toggle-btn ${cardData.colorMode !== 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('colorMode', 'gradient')}
                        >
                          {t.labels.gradient || "Gradient"}
                        </button>
                      </div>
                      <div style={{ display: 'grid', gridTemplateColumns: cardData.colorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px', minHeight: '74px' }}>
                        <InputGroup
                          id="primary-color"
                          label={cardData.colorMode === 'solid' ? t.labels.backgroundColor : (t.labels.primaryColor || "Primary Color")}
                          type="color"
                          value={cardData.primaryColor}
                          onChange={(v) => updateCardData('primaryColor', v)}
                        />
                        {cardData.colorMode !== 'solid' && (
                          <InputGroup
                            id="secondary-color"
                            label={t.labels.secondaryColor || "Secondary Color"}
                            type="color"
                            value={cardData.secondaryColor}
                            onChange={(v) => updateCardData('secondaryColor', v)}
                          />
                        )}
                      </div>
                    </div>

                    <div style={{ marginBottom: '12px', borderTop: '1px solid rgba(255,255,255,0.1)', paddingTop: '12px' }}>
                      <label style={{ display: 'block', color: '#a0a0c0', fontSize: '11px', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '4px', fontWeight: '600' }}>{t.labels.cardInner || "Card Inner Background"}</label>
                      <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                        <button
                          className={`mode-toggle-btn ${cardData.cardInnerColorMode === 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('cardInnerColorMode', 'solid')}
                        >
                          {t.labels.solid || "Solid"}
                        </button>
                        <button
                          className={`mode-toggle-btn ${cardData.cardInnerColorMode !== 'solid' ? 'active' : ''}`}
                          onClick={() => updateCardData('cardInnerColorMode', 'gradient')}
                        >
                          {t.labels.gradient || "Gradient"}
                        </button>
                      </div>
                      <div style={{ display: 'grid', gridTemplateColumns: cardData.cardInnerColorMode === 'solid' ? '1fr' : '1fr 1fr', gap: '8px' }}>
                        <InputGroup
                          id="inner-primary-color"
                          label={cardData.cardInnerColorMode === 'solid' ? (t.labels.backgroundColor || "Background") : (t.labels.primaryColor || "Primary")}
                          type="color"
                          value={cardData.cardInnerBackground || '#ffffff'}
                          onChange={(v) => updateCardData('cardInnerBackground', v)}
                        />
                        {cardData.cardInnerColorMode !== 'solid' && (
                          <InputGroup
                            id="inner-secondary-color"
                            label={t.labels.secondaryColor || "Secondary"}
                            type="color"
                            value={cardData.cardInnerSecondaryBackground || '#f5f5fa'}
                            onChange={(v) => updateCardData('cardInnerSecondaryBackground', v)}
                          />
                        )}
                      </div>
                    </div>
                    <InputGroup
                      id="card-border-color"
                      label={t.labels.borderColor}
                      type="color"
                      value={cardData.borderColor || '#ffd700'}
                      onChange={(v) => updateCardData('borderColor', v)}
                    />
                  </CollapsibleSection>

                  {/* Text Style Section */}
                  <CollapsibleSection
                    title={t.sections.textStyle || "Text Style"}
                    icon="ğŸ“"
                    isOpen={openSection === 'textStyle'}
                    onToggle={() => setOpenSection(openSection === 'textStyle' ? null : 'textStyle')}
                  >
                    <div style={{ marginBottom: '20px' }}>
                      <InputGroup
                        id="card-font"
                        label={t.labels.font}
                        value={cardData.font}
                        onChange={(v) => updateCardData('font', v)}
                        options={fontOptions}
                      />
                    </div>

                    <div>
                      <TextSettingsGroup label={t.labels.name} colorKey="nameColor" sizeKey="nameSize" weightKey="nameWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.hp} colorKey="hpColor" sizeKey="hpSize" weightKey="hpWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.element + " / " + t.labels.stage} colorKey="typeColor" sizeKey="stageSize" weightKey="stageWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.abilityName || "Ability Name"} colorKey="moveNameColor" sizeKey="moveNameSize" weightKey="moveNameWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.abilityDesc || "Abilities Description"} colorKey="moveDescColor" sizeKey="moveDescSize" weightKey="moveDescWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.description} colorKey="descColor" sizeKey="descSize" weightKey="descWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.stats || "Stats"} colorKey="statsColor" sizeKey="statsSize" weightKey="statsWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                      <TextSettingsGroup label={t.labels.author} colorKey="authorColor" sizeKey="authorSize" weightKey="authorWeight" cardData={cardData} updateCardData={updateCardData} t={t} />
                    </div>
                  </CollapsibleSection>

                  {/* Ability Style Section */}
                  <CollapsibleSection
                    title={t.sections.abilityStyle || "Ability Style"}
                    icon="ğŸ¨"
                    isOpen={openSection === 'abilityStyle'}
                    onToggle={() => setOpenSection(openSection === 'abilityStyle' ? null : 'abilityStyle')}
                  >
                    {attacks.map((attack, idx) => (
                      <AttackStyleEditor
                        key={attack.id}
                        index={idx}
                        attack={attack}
                        typeIcon={typeIcon}
                        onUpdate={updateAttack}
                        t={t}
                      />
                    ))}
                  </CollapsibleSection>

                  {/* Display Options - Moved from visual tab */}
                  <CollapsibleSection
                    title={t.display.title}
                    icon="ğŸ‘ï¸"
                    isOpen={openSection === 'appearance'}
                    onToggle={() => setOpenSection(openSection === 'appearance' ? null : 'appearance')}
                  >
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                      <Checkbox
                        id="show-hp"
                        label={t.checkboxes.showHP}
                        checked={cardData.showHP}
                        onChange={(v) => updateCardData('showHP', v)}
                      />
                      <Checkbox
                        id="show-weak-res"
                        label={t.checkboxes.showWeakRes}
                        checked={cardData.showWeakRes}
                        onChange={(v) => updateCardData('showWeakRes', v)}
                      />
                      <Checkbox
                        id="show-retreat"
                        label={t.checkboxes.showRetreat}
                        checked={cardData.showRetreat}
                        onChange={(v) => updateCardData('showRetreat', v)}
                      />
                      <Checkbox
                        id="show-desc"
                        label={t.checkboxes.showDescription}
                        checked={cardData.showDescription}
                        onChange={(v) => updateCardData('showDescription', v)}
                      />

                    </div>
                  </CollapsibleSection>

                </>
              )}
            </div>

            {showResetConfirm && (
              <div className="modal-overlay" onClick={() => setShowResetConfirm(false)} style={{ zIndex: 11000 }}>
                <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '400px' }}>
                  <div className="modal-header">
                    <h3 style={{ color: '#f44336' }}>âš ï¸ {t.sections?.reset || 'Reset'}</h3>
                  </div>
                  <div className="modal-body">
                    <p>{t.prompts.resetConfirm}</p>
                  </div>
                  <div className="modal-footer">
                    <button className="secondary-button" onClick={() => setShowResetConfirm(false)}>
                      {t.common.cancel}
                    </button>
                    <button
                      className="primary-button"
                      style={{ background: '#f44336' }}
                      onClick={() => {
                        setCardData(getInitialCardData(t));
                        setAttacks(getInitialAttacks(t));
                        setImage(null);
                        setImageSettings(INITIAL_IMAGE_SETTINGS);
                        setShowResetConfirm(false);
                      }}
                    >
                      {t.buttons.resetCard}
                    </button>
                  </div>
                </div>
              </div>
            )}

            <SaveModal
              isOpen={isSaveModalOpen}
              onClose={() => setIsSaveModalOpen(false)}
              onSave={handleSaveCard}
              defaultName={cardData.name}
              t={t}
            />
            <LoadModal
              isOpen={isLoadModalOpen}
              onClose={() => setIsLoadModalOpen(false)}
              onLoad={handleLoadCard}
              onDelete={handleDeleteCard}
              onDeleteAll={handleDeleteAllCards}
              cards={savedCards}
              t={t}
            />
            <ConfirmModal
              isOpen={confirmState.isOpen}
              onClose={() => setConfirmState(prev => ({ ...prev, isOpen: false }))}
              onConfirm={confirmState.onConfirm}
              title={confirmState.title}
              message={confirmState.message}
              t={t}
            />

          </div></div></div>)
    }
    function CardCreator() {
      const [lang, setLang] = useState('en');
      const t = TRANSLATIONS[lang];
      const [isGifSupported, setIsGifSupported] = useState(true);

      useEffect(() => {
        // Detect if getDisplayMedia is supported (Mobile usually doesn't support it)
        const supported = !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia);
        setIsGifSupported(supported);
      }, []);

      return (
        <LanguageContext.Provider value={{ lang, setLang, t, isGifSupported }}>
          <NotificationProvider>
            <CardCreatorContent />
          </NotificationProvider>
        </LanguageContext.Provider>
      )
    }
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CardCreator />);


  </script>
</body>

</html>
