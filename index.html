<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Creator - Create Custom Collectible Cards</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽ´</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Nunito:wght@400;600;700;800&family=Oswald:wght@400;500;600&family=Playfair+Display:wght@400;600&family=Poppins:wght@400;500;600&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Nunito', sans-serif; background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%); min-height: 100vh; }
    #root { min-height: 100vh; }
    .loading { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; color: white; font-size: 24px; gap: 20px; }
    .loading-spinner { width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top-color: #ffd700; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="root"><div class="loading"><div class="loading-spinner"></div><div>ðŸŽ´ Loading Card Creator...</div></div></div>
  <script type="text/babel" >
const { useState, useRef, useMemo, useCallback, useEffect, createContext, useContext } = React;

// ============================================
// SYSTÃˆME DE TRADUCTION
// ============================================
const LANGUAGES = {
  en: { name: 'English', flag: 'ðŸ‡¬ðŸ‡§' },
  fr: { name: 'FranÃ§ais', flag: 'ðŸ‡«ðŸ‡·' },
  es: { name: 'EspaÃ±ol', flag: 'ðŸ‡ªðŸ‡¸' },
  de: { name: 'Deutsch', flag: 'ðŸ‡©ðŸ‡ª' },
  ru: { name: 'Ð ÑƒÑÑÐºÐ¸Ð¹', flag: 'ðŸ‡·ðŸ‡º' },
  ja: { name: 'æ—¥æœ¬èªž', flag: 'ðŸ‡¯ðŸ‡µ' },
  zh: { name: 'ä¸­æ–‡', flag: 'ðŸ‡¨ðŸ‡³' },
};

const TRANSLATIONS = {
  en: {
    // App
    appTitle: 'Card Creator',
    appSubtitle: 'Create your own personalized collectible cards',
    hoverHint: 'âœ¨ Hover over the card to intensify the effect âœ¨',
    
    // Elements
    elements: {
      Fire: 'Fire',
      Water: 'Water',
      Nature: 'Nature',
      Electric: 'Electric',
      Mystic: 'Mystic',
      Fighting: 'Fighting',
      Shadow: 'Shadow',
      Metal: 'Metal',
      Light: 'Light',
      Dragon: 'Dragon',
      Ice: 'Ice',
      Neutral: 'Neutral',
    },
    
    // Effects
    effects: {
      none: { name: 'None', description: 'No effect' },
      holographic: { name: 'Holographic', description: 'Classic rainbow effect' },
      rainbow: { name: 'Rainbow', description: 'Animated multicolor gradient' },
      gold: { name: 'Gold', description: 'Luxurious golden reflections' },
      silver: { name: 'Silver', description: 'Metallic silver reflections' },
      prismatic: { name: 'Prismatic', description: 'Refracting crystal effect' },
      neon: { name: 'Neon', description: 'Vibrant neon glow' },
      galaxy: { name: 'Galaxy', description: 'Starry cosmic effect' },
      fire: { name: 'Flames', description: 'Animated flame effect' },
      ice: { name: 'Frost', description: 'Sparkling ice effect' },
    },
    
    // Stages
    stages: ['Base', 'Stage 1', 'Stage 2', 'Special', 'Legendary', 'Mythic', 'Ultra'],
    
    // Rarities
    rarities: {
      common: 'Common',
      uncommon: 'Uncommon',
      rare: 'Rare',
      epic: 'Epic',
      legendary: 'Legendary',
      mythic: 'Mythic',
    },
    
    // Sections
    sections: {
      image: 'Image',
      basicInfo: 'Basic Information',
      rarityEffects: 'Rarity & Effects',
      abilities: 'Abilities',
      stats: 'Statistics',
      appearance: 'Appearance',
    },
    
    // Labels
    labels: {
      name: 'Name',
      hp: 'Hit Points',
      element: 'Element',
      stage: 'Stage',
      description: 'Description',
      author: 'Author',
      rarity: 'Rarity',
      effect: 'Effect',
      weakness: 'Weakness',
      resistance: 'Resistance',
      retreatCost: 'Retreat Cost',
      abilityName: 'Ability Name',
      damage: 'Damage',
      energyCost: 'Energy Cost',
      abilityDesc: 'Description',
      borderColor: 'Border Color',
      backgroundColor: 'Background Color',
      textColor: 'Text Color',
      font: 'Font',
      zoom: 'Zoom',
    },
    
    // Buttons
    buttons: {
      addAbility: '+ Add Ability',
      remove: 'Remove',
      change: 'Change',
      recenter: 'Recenter',
      download: 'Download',
      autoRotate: '3D Preview',
    },
    
    // Checkboxes
    checkboxes: {
      showHP: 'Show hit points',
      showWeakRes: 'Show weakness/resistance',
      showRetreat: 'Show retreat cost',
      showDescription: 'Show description',
      showTexture: 'Show texture pattern',
      showParticles: 'Show particles',
    },
    
    // Image Editor
    imageEditor: {
      dropHint: 'Drag & drop an image here',
      orClick: 'or click to select',
      formats: 'PNG, JPG, GIF, WEBP (max 15MB)',
      loading: 'Loading...',
      unsupportedFormat: 'Unsupported format. Use PNG, JPG, GIF or WEBP.',
      fileTooLarge: 'File too large. Maximum 15MB.',
    },
    
    // Download
    download: {
      title: 'ðŸ“¥ Download',
      pngTitle: 'Transparent PNG image',
      jpgTitle: 'JPG image with background',
      gifTitle: 'Animated GIF (3 seconds)',
      htmlTitle: 'Interactive HTML file',
      capturing: 'â³ Capturing...',
    },
    
    // Card
    card: {
      hp: 'HP',
      weakness: 'Weakness',
      resistance: 'Resistance',
      cost: 'Cost',
      illus: 'Illus.',
    },
    
    // Defaults
    defaults: {
      newAbility: 'New Ability',
    },
    
    // Display options
    display: {
      title: 'Display Options',
    },
  },
  
  fr: {
    // App
    appTitle: 'Card Creator',
    appSubtitle: 'CrÃ©ez vos propres cartes Ã  collectionner personnalisÃ©es',
    hoverHint: 'âœ¨ Survolez la carte pour intensifier l\'effet âœ¨',
    
    // Elements
    elements: {
      Fire: 'Feu',
      Water: 'Eau',
      Nature: 'Nature',
      Electric: 'Ã‰lectrique',
      Mystic: 'Mystique',
      Fighting: 'Combat',
      Shadow: 'Ombre',
      Metal: 'MÃ©tal',
      Light: 'LumiÃ¨re',
      Dragon: 'Dragon',
      Ice: 'Glace',
      Neutral: 'Neutre',
    },
    
    // Effects
    effects: {
      none: { name: 'Aucun', description: 'Pas d\'effet' },
      holographic: { name: 'Holographique', description: 'Effet arc-en-ciel classique' },
      rainbow: { name: 'Arc-en-ciel', description: 'DÃ©gradÃ© multicolore animÃ©' },
      gold: { name: 'DorÃ©', description: 'Reflets dorÃ©s luxueux' },
      silver: { name: 'ArgentÃ©', description: 'Reflets argentÃ©s mÃ©talliques' },
      prismatic: { name: 'Prismatique', description: 'Effet cristal rÃ©fractant' },
      neon: { name: 'NÃ©on', description: 'Lueur nÃ©on vibrante' },
      galaxy: { name: 'Galaxie', description: 'Effet cosmique Ã©toilÃ©' },
      fire: { name: 'Flammes', description: 'Effet de flammes animÃ©es' },
      ice: { name: 'GivrÃ©', description: 'Effet de glace scintillante' },
    },
    
    // Stages
    stages: ['Base', 'Ã‰volution 1', 'Ã‰volution 2', 'SpÃ©cial', 'LÃ©gendaire', 'Mythique', 'Ultra'],
    
    // Rarities
    rarities: {
      common: 'Commune',
      uncommon: 'Peu commune',
      rare: 'Rare',
      epic: 'Ã‰pique',
      legendary: 'LÃ©gendaire',
      mythic: 'Mythique',
    },
    
    // Sections
    sections: {
      image: 'Image',
      basicInfo: 'Informations de base',
      rarityEffects: 'RaretÃ© & Effets',
      abilities: 'CapacitÃ©s',
      stats: 'Statistiques',
      appearance: 'Apparence',
    },
    
    // Labels
    labels: {
      name: 'Nom',
      hp: 'Points de vie',
      element: 'Ã‰lÃ©ment',
      stage: 'Stade',
      description: 'Description',
      author: 'Auteur',
      rarity: 'RaretÃ©',
      effect: 'Effet',
      weakness: 'Faiblesse',
      resistance: 'RÃ©sistance',
      retreatCost: 'CoÃ»t de retraite',
      abilityName: 'Nom de la capacitÃ©',
      damage: 'DÃ©gÃ¢ts',
      energyCost: 'CoÃ»t en Ã©nergie',
      abilityDesc: 'Description',
      borderColor: 'Couleur de bordure',
      backgroundColor: 'Couleur de fond',
      textColor: 'Couleur du texte',
      font: 'Police',
      zoom: 'Zoom',
    },
    
    // Buttons
    buttons: {
      addAbility: '+ Ajouter une capacitÃ©',
      remove: 'Supprimer',
      change: 'Changer',
      recenter: 'Recentrer',
      download: 'TÃ©lÃ©charger',
      autoRotate: 'AperÃ§u 3D',
    },
    
    // Checkboxes
    checkboxes: {
      showHP: 'Afficher les points de vie',
      showWeakRes: 'Afficher faiblesse/rÃ©sistance',
      showRetreat: 'Afficher le coÃ»t de retraite',
      showDescription: 'Afficher la description',
      showTexture: 'Afficher le motif',
      showParticles: 'Afficher les particules',
    },
    
    // Image Editor
    imageEditor: {
      dropHint: 'Glissez-dÃ©posez une image ici',
      orClick: 'ou cliquez pour sÃ©lectionner',
      formats: 'PNG, JPG, GIF, WEBP (max 15Mo)',
      loading: 'Chargement...',
      unsupportedFormat: 'Format non supportÃ©. Utilisez PNG, JPG, GIF ou WEBP.',
      fileTooLarge: 'Fichier trop volumineux. Maximum 15Mo.',
    },
    
    // Download
    download: {
      title: 'ðŸ“¥ TÃ©lÃ©charger',
      pngTitle: 'Image PNG transparente',
      jpgTitle: 'Image JPG avec fond',
      gifTitle: 'GIF animÃ© (3 secondes)',
      htmlTitle: 'Fichier HTML interactif',
      capturing: 'â³ Capture...',
    },
    
    // Card
    card: {
      hp: 'PV',
      weakness: 'Faiblesse',
      resistance: 'RÃ©sistance',
      cost: 'CoÃ»t',
      illus: 'Illus.',
    },
    
    // Defaults
    defaults: {
      newAbility: 'Nouvelle CapacitÃ©',
    },
    
    // Display options
    display: {
      title: 'Options d\'affichage',
    },
  },
  
  es: {
    // App
    appTitle: 'Card Creator',
    appSubtitle: 'Crea tus propias cartas coleccionables personalizadas',
    hoverHint: 'âœ¨ Pasa el cursor sobre la carta para intensificar el efecto âœ¨',
    
    // Elements
    elements: {
      Fire: 'Fuego',
      Water: 'Agua',
      Nature: 'Naturaleza',
      Electric: 'ElÃ©ctrico',
      Mystic: 'MÃ­stico',
      Fighting: 'Lucha',
      Shadow: 'Sombra',
      Metal: 'Metal',
      Light: 'Luz',
      Dragon: 'DragÃ³n',
      Ice: 'Hielo',
      Neutral: 'Neutral',
    },
    
    // Effects
    effects: {
      none: { name: 'Ninguno', description: 'Sin efecto' },
      holographic: { name: 'HologrÃ¡fico', description: 'Efecto arcoÃ­ris clÃ¡sico' },
      rainbow: { name: 'ArcoÃ­ris', description: 'Degradado multicolor animado' },
      gold: { name: 'Dorado', description: 'Reflejos dorados lujosos' },
      silver: { name: 'Plateado', description: 'Reflejos metÃ¡licos plateados' },
      prismatic: { name: 'PrismÃ¡tico', description: 'Efecto cristal refractante' },
      neon: { name: 'NeÃ³n', description: 'Brillo neÃ³n vibrante' },
      galaxy: { name: 'Galaxia', description: 'Efecto cÃ³smico estrellado' },
      fire: { name: 'Llamas', description: 'Efecto de llamas animadas' },
      ice: { name: 'Escarcha', description: 'Efecto de hielo brillante' },
    },
    
    // Stages
    stages: ['Base', 'Fase 1', 'Fase 2', 'Especial', 'Legendario', 'MÃ­tico', 'Ultra'],
    
    // Rarities
    rarities: {
      common: 'ComÃºn',
      uncommon: 'Poco comÃºn',
      rare: 'Rara',
      epic: 'Ã‰pica',
      legendary: 'Legendaria',
      mythic: 'MÃ­tica',
    },
    
    // Sections
    sections: {
      image: 'Imagen',
      basicInfo: 'InformaciÃ³n bÃ¡sica',
      rarityEffects: 'Rareza y Efectos',
      abilities: 'Habilidades',
      stats: 'EstadÃ­sticas',
      appearance: 'Apariencia',
    },
    
    // Labels
    labels: {
      name: 'Nombre',
      hp: 'Puntos de vida',
      element: 'Elemento',
      stage: 'Fase',
      description: 'DescripciÃ³n',
      author: 'Autor',
      rarity: 'Rareza',
      effect: 'Efecto',
      weakness: 'Debilidad',
      resistance: 'Resistencia',
      retreatCost: 'Coste de retirada',
      abilityName: 'Nombre de habilidad',
      damage: 'DaÃ±o',
      energyCost: 'Coste de energÃ­a',
      abilityDesc: 'DescripciÃ³n',
      borderColor: 'Color del borde',
      backgroundColor: 'Color de fondo',
      textColor: 'Color del texto',
      font: 'Fuente',
      zoom: 'Zoom',
    },
    
    // Buttons
    buttons: {
      addAbility: '+ AÃ±adir habilidad',
      remove: 'Eliminar',
      change: 'Cambiar',
      recenter: 'Recentrar',
      download: 'Descargar',
      autoRotate: 'Vista previa 3D',
    },
    
    // Checkboxes
    checkboxes: {
      showHP: 'Mostrar puntos de vida',
      showWeakRes: 'Mostrar debilidad/resistencia',
      showRetreat: 'Mostrar coste de retirada',
      showDescription: 'Mostrar descripciÃ³n',
      showTexture: 'Mostrar patrÃ³n',
      showParticles: 'Mostrar partÃ­culas',
    },
    
    // Image Editor
    imageEditor: {
      dropHint: 'Arrastra y suelta una imagen aquÃ­',
      orClick: 'o haz clic para seleccionar',
      formats: 'PNG, JPG, GIF, WEBP (mÃ¡x 15MB)',
      loading: 'Cargando...',
      unsupportedFormat: 'Formato no soportado. Use PNG, JPG, GIF o WEBP.',
      fileTooLarge: 'Archivo demasiado grande. MÃ¡ximo 15MB.',
    },
    
    // Download
    download: {
      title: 'ðŸ“¥ Descargar',
      pngTitle: 'Imagen PNG transparente',
      jpgTitle: 'Imagen JPG con fondo',
      gifTitle: 'GIF animado (3 segundos)',
      htmlTitle: 'Archivo HTML interactivo',
      capturing: 'â³ Capturando...',
    },
    
    // Card
    card: {
      hp: 'PS',
      weakness: 'Debilidad',
      resistance: 'Resistencia',
      cost: 'Coste',
      illus: 'Illus.',
    },
    
    // Defaults
    defaults: {
      newAbility: 'Nueva Habilidad',
    },
    
    // Display options
    display: {
      title: 'Opciones de visualizaciÃ³n',
    },
  },
  
  de: {
    // App
    appTitle: 'Card Creator',
    appSubtitle: 'Erstellen Sie Ihre eigenen personalisierten Sammelkarten',
    hoverHint: 'âœ¨ Fahren Sie mit der Maus Ã¼ber die Karte, um den Effekt zu verstÃ¤rken âœ¨',
    
    // Elements
    elements: {
      Fire: 'Feuer',
      Water: 'Wasser',
      Nature: 'Natur',
      Electric: 'Elektro',
      Mystic: 'Mystik',
      Fighting: 'Kampf',
      Shadow: 'Schatten',
      Metal: 'Metall',
      Light: 'Licht',
      Dragon: 'Drache',
      Ice: 'Eis',
      Neutral: 'Neutral',
    },
    
    // Effects
    effects: {
      none: { name: 'Keiner', description: 'Kein Effekt' },
      holographic: { name: 'Holografisch', description: 'Klassischer Regenbogeneffekt' },
      rainbow: { name: 'Regenbogen', description: 'Animierter mehrfarbiger Verlauf' },
      gold: { name: 'Gold', description: 'LuxuriÃ¶se goldene Reflexionen' },
      silver: { name: 'Silber', description: 'Metallische Silberreflexionen' },
      prismatic: { name: 'Prismatisch', description: 'Brechender Kristalleffekt' },
      neon: { name: 'Neon', description: 'Lebhaftes Neonleuchten' },
      galaxy: { name: 'Galaxie', description: 'Sternenkosmischer Effekt' },
      fire: { name: 'Flammen', description: 'Animierter Flammeneffekt' },
      ice: { name: 'Frost', description: 'Funkelnder Eiseffekt' },
    },
    
    // Stages
    stages: ['Basis', 'Phase 1', 'Phase 2', 'Spezial', 'LegendÃ¤r', 'Mythisch', 'Ultra'],
    
    // Rarities
    rarities: {
      common: 'GewÃ¶hnlich',
      uncommon: 'UngewÃ¶hnlich',
      rare: 'Selten',
      epic: 'Episch',
      legendary: 'LegendÃ¤r',
      mythic: 'Mythisch',
    },
    
    // Sections
    sections: {
      image: 'Bild',
      basicInfo: 'Grundinformationen',
      rarityEffects: 'Seltenheit & Effekte',
      abilities: 'FÃ¤higkeiten',
      stats: 'Statistiken',
      appearance: 'Aussehen',
    },
    
    // Labels
    labels: {
      name: 'Name',
      hp: 'Lebenspunkte',
      element: 'Element',
      stage: 'Phase',
      description: 'Beschreibung',
      author: 'Autor',
      rarity: 'Seltenheit',
      effect: 'Effekt',
      weakness: 'SchwÃ¤che',
      resistance: 'Resistenz',
      retreatCost: 'RÃ¼ckzugskosten',
      abilityName: 'FÃ¤higkeitsname',
      damage: 'Schaden',
      energyCost: 'Energiekosten',
      abilityDesc: 'Beschreibung',
      borderColor: 'Rahmenfarbe',
      backgroundColor: 'Hintergrundfarbe',
      textColor: 'Textfarbe',
      font: 'Schriftart',
      zoom: 'Zoom',
    },
    
    // Buttons
    buttons: {
      addAbility: '+ FÃ¤higkeit hinzufÃ¼gen',
      remove: 'Entfernen',
      change: 'Ã„ndern',
      recenter: 'Zentrieren',
      download: 'Herunterladen',
      autoRotate: '3D-Vorschau',
    },
    
    // Checkboxes
    checkboxes: {
      showHP: 'Lebenspunkte anzeigen',
      showWeakRes: 'SchwÃ¤che/Resistenz anzeigen',
      showRetreat: 'RÃ¼ckzugskosten anzeigen',
      showDescription: 'Beschreibung anzeigen',
      showTexture: 'Muster anzeigen',
      showParticles: 'Partikel anzeigen',
    },
    
    // Image Editor
    imageEditor: {
      dropHint: 'Bild hier ablegen',
      orClick: 'oder klicken zum AuswÃ¤hlen',
      formats: 'PNG, JPG, GIF, WEBP (max 15MB)',
      loading: 'Laden...',
      unsupportedFormat: 'Nicht unterstÃ¼tztes Format. Verwenden Sie PNG, JPG, GIF oder WEBP.',
      fileTooLarge: 'Datei zu groÃŸ. Maximal 15MB.',
    },
    
    // Download
    download: {
      title: 'ðŸ“¥ Herunterladen',
      pngTitle: 'Transparentes PNG-Bild',
      jpgTitle: 'JPG-Bild mit Hintergrund',
      gifTitle: 'Animiertes GIF (3 Sekunden)',
      htmlTitle: 'Interaktive HTML-Datei',
      capturing: 'â³ Aufnahme...',
    },
    
    // Card
    card: {
      hp: 'KP',
      weakness: 'SchwÃ¤che',
      resistance: 'Resistenz',
      cost: 'Kosten',
      illus: 'Illus.',
    },
    
    // Defaults
    defaults: {
      newAbility: 'Neue FÃ¤higkeit',
    },
    
    // Display options
    display: {
      title: 'Anzeigeoptionen',
    },
  },
  
  ru: {
    // App
    appTitle: 'Card Creator',
    appSubtitle: 'Ð¡Ð¾Ð·Ð´Ð°Ð²Ð°Ð¹Ñ‚Ðµ ÑÐ²Ð¾Ð¸ ÑÐ¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ðµ ÐºÐ¾Ð»Ð»ÐµÐºÑ†Ð¸Ð¾Ð½Ð½Ñ‹Ðµ ÐºÐ°Ñ€Ñ‚Ñ‹',
    hoverHint: 'âœ¨ ÐÐ°Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ñƒ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÑÐ¸Ð»Ð¸Ñ‚ÑŒ ÑÑ„Ñ„ÐµÐºÑ‚ âœ¨',
    
    // Elements
    elements: {
      Fire: 'ÐžÐ³Ð¾Ð½ÑŒ',
      Water: 'Ð’Ð¾Ð´Ð°',
      Nature: 'ÐŸÑ€Ð¸Ñ€Ð¾Ð´Ð°',
      Electric: 'Ð­Ð»ÐµÐºÑ‚Ñ€Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾',
      Mystic: 'ÐœÐ¸ÑÑ‚Ð¸ÐºÐ°',
      Fighting: 'Ð‘Ð¾ÐµÐ²Ð¾Ð¹',
      Shadow: 'Ð¢ÐµÐ½ÑŒ',
      Metal: 'ÐœÐµÑ‚Ð°Ð»Ð»',
      Light: 'Ð¡Ð²ÐµÑ‚',
      Dragon: 'Ð”Ñ€Ð°ÐºÐ¾Ð½',
      Ice: 'Ð›Ñ‘Ð´',
      Neutral: 'ÐÐµÐ¹Ñ‚Ñ€Ð°Ð»ÑŒÐ½Ñ‹Ð¹',
    },
    
    // Effects
    effects: {
      none: { name: 'ÐÐµÑ‚', description: 'Ð‘ÐµÐ· ÑÑ„Ñ„ÐµÐºÑ‚Ð°' },
      holographic: { name: 'Ð“Ð¾Ð»Ð¾Ð³Ñ€Ð°Ñ„Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹', description: 'ÐšÐ»Ð°ÑÑÐ¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ñ€Ð°Ð´ÑƒÐ¶Ð½Ñ‹Ð¹ ÑÑ„Ñ„ÐµÐºÑ‚' },
      rainbow: { name: 'Ð Ð°Ð´ÑƒÐ³Ð°', description: 'ÐÐ½Ð¸Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð¼Ð½Ð¾Ð³Ð¾Ñ†Ð²ÐµÑ‚Ð½Ñ‹Ð¹ Ð³Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚' },
      gold: { name: 'Ð—Ð¾Ð»Ð¾Ñ‚Ð¾', description: 'Ð Ð¾ÑÐºÐ¾ÑˆÐ½Ñ‹Ðµ Ð·Ð¾Ð»Ð¾Ñ‚Ñ‹Ðµ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ' },
      silver: { name: 'Ð¡ÐµÑ€ÐµÐ±Ñ€Ð¾', description: 'ÐœÐµÑ‚Ð°Ð»Ð»Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ ÑÐµÑ€ÐµÐ±Ñ€ÑÐ½Ñ‹Ðµ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ' },
      prismatic: { name: 'ÐŸÑ€Ð¸Ð·Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹', description: 'Ð­Ñ„Ñ„ÐµÐºÑ‚ Ð¿Ñ€ÐµÐ»Ð¾Ð¼Ð»ÑÑŽÑ‰ÐµÐ³Ð¾ ÐºÑ€Ð¸ÑÑ‚Ð°Ð»Ð»Ð°' },
      neon: { name: 'ÐÐµÐ¾Ð½', description: 'Ð¯Ñ€ÐºÐ¾Ðµ Ð½ÐµÐ¾Ð½Ð¾Ð²Ð¾Ðµ ÑÐ²ÐµÑ‡ÐµÐ½Ð¸Ðµ' },
      galaxy: { name: 'Ð“Ð°Ð»Ð°ÐºÑ‚Ð¸ÐºÐ°', description: 'Ð—Ð²Ñ‘Ð·Ð´Ð½Ñ‹Ð¹ ÐºÐ¾ÑÐ¼Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ ÑÑ„Ñ„ÐµÐºÑ‚' },
      fire: { name: 'ÐŸÐ»Ð°Ð¼Ñ', description: 'ÐÐ½Ð¸Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ ÑÑ„Ñ„ÐµÐºÑ‚ Ð¾Ð³Ð½Ñ' },
      ice: { name: 'Ð›Ñ‘Ð´', description: 'Ð¡Ð²ÐµÑ€ÐºÐ°ÑŽÑ‰Ð¸Ð¹ Ð»ÐµÐ´ÑÐ½Ð¾Ð¹ ÑÑ„Ñ„ÐµÐºÑ‚' },
    },
    
    // Stages
    stages: ['Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ð¹', 'Ð¡Ñ‚Ð°Ð´Ð¸Ñ 1', 'Ð¡Ñ‚Ð°Ð´Ð¸Ñ 2', 'ÐžÑÐ¾Ð±Ñ‹Ð¹', 'Ð›ÐµÐ³ÐµÐ½Ð´Ð°Ñ€Ð½Ñ‹Ð¹', 'ÐœÐ¸Ñ„Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹', 'Ð£Ð»ÑŒÑ‚Ñ€Ð°'],
    
    // Rarities
    rarities: {
      common: 'ÐžÐ±Ñ‹Ñ‡Ð½Ð°Ñ',
      uncommon: 'ÐÐµÐ¾Ð±Ñ‹Ñ‡Ð½Ð°Ñ',
      rare: 'Ð ÐµÐ´ÐºÐ°Ñ',
      epic: 'Ð­Ð¿Ð¸Ñ‡ÐµÑÐºÐ°Ñ',
      legendary: 'Ð›ÐµÐ³ÐµÐ½Ð´Ð°Ñ€Ð½Ð°Ñ',
      mythic: 'ÐœÐ¸Ñ„Ð¸Ñ‡ÐµÑÐºÐ°Ñ',
    },
    
    // Sections
    sections: {
      image: 'Ð˜Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ',
      basicInfo: 'ÐžÑÐ½Ð¾Ð²Ð½Ð°Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ',
      rarityEffects: 'Ð ÐµÐ´ÐºÐ¾ÑÑ‚ÑŒ Ð¸ Ð­Ñ„Ñ„ÐµÐºÑ‚Ñ‹',
      abilities: 'Ð¡Ð¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸',
      stats: 'Ð¥Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸',
      appearance: 'Ð’Ð½ÐµÑˆÐ½Ð¸Ð¹ Ð²Ð¸Ð´',
    },
    
    // Labels
    labels: {
      name: 'Ð˜Ð¼Ñ',
      hp: 'ÐžÑ‡ÐºÐ¸ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÑ',
      element: 'Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚',
      stage: 'Ð¡Ñ‚Ð°Ð´Ð¸Ñ',
      description: 'ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ',
      author: 'ÐÐ²Ñ‚Ð¾Ñ€',
      rarity: 'Ð ÐµÐ´ÐºÐ¾ÑÑ‚ÑŒ',
      effect: 'Ð­Ñ„Ñ„ÐµÐºÑ‚',
      weakness: 'Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚ÑŒ',
      resistance: 'Ð¡Ð¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ðµ',
      retreatCost: 'Ð¡Ñ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ÑÑ‚ÑƒÐ¿Ð»ÐµÐ½Ð¸Ñ',
      abilityName: 'ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚Ð¸',
      damage: 'Ð£Ñ€Ð¾Ð½',
      energyCost: 'Ð¡Ñ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ ÑÐ½ÐµÑ€Ð³Ð¸Ð¸',
      abilityDesc: 'ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ',
      borderColor: 'Ð¦Ð²ÐµÑ‚ Ñ€Ð°Ð¼ÐºÐ¸',
      backgroundColor: 'Ð¦Ð²ÐµÑ‚ Ñ„Ð¾Ð½Ð°',
      textColor: 'Ð¦Ð²ÐµÑ‚ Ñ‚ÐµÐºÑÑ‚Ð°',
      font: 'Ð¨Ñ€Ð¸Ñ„Ñ‚',
      zoom: 'ÐœÐ°ÑÑˆÑ‚Ð°Ð±',
    },
    
    // Buttons
    buttons: {
      addAbility: '+ Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ',
      remove: 'Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ',
      change: 'Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ',
      recenter: 'Ð¦ÐµÐ½Ñ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ',
      download: 'Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ',
      autoRotate: '3D Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€',
    },
    
    // Checkboxes
    checkboxes: {
      showHP: 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¾Ñ‡ÐºÐ¸ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÑ',
      showWeakRes: 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÐ»Ð°Ð±Ð¾ÑÑ‚ÑŒ/ÑÐ¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ðµ',
      showRetreat: 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ÑÑ‚ÑƒÐ¿Ð»ÐµÐ½Ð¸Ñ',
      showDescription: 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ',
      showTexture: 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ñ‚ÐµÐºÑÑ‚ÑƒÑ€Ñƒ',
      showParticles: 'ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ñ‡Ð°ÑÑ‚Ð¸Ñ†Ñ‹',
    },
    
    // Image Editor
    imageEditor: {
      dropHint: 'ÐŸÐµÑ€ÐµÑ‚Ð°Ñ‰Ð¸Ñ‚Ðµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑÑŽÐ´Ð°',
      orClick: 'Ð¸Ð»Ð¸ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð´Ð»Ñ Ð²Ñ‹Ð±Ð¾Ñ€Ð°',
      formats: 'PNG, JPG, GIF, WEBP (Ð¼Ð°ÐºÑ 15ÐœÐ‘)',
      loading: 'Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ°...',
      unsupportedFormat: 'ÐÐµÐ¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ PNG, JPG, GIF Ð¸Ð»Ð¸ WEBP.',
      fileTooLarge: 'Ð¤Ð°Ð¹Ð» ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹. ÐœÐ°ÐºÑÐ¸Ð¼ÑƒÐ¼ 15ÐœÐ‘.',
    },
    
    // Download
    download: {
      title: 'ðŸ“¥ Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ',
      pngTitle: 'ÐŸÑ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ð¾Ðµ PNG Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ',
      jpgTitle: 'JPG Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ñ Ñ„Ð¾Ð½Ð¾Ð¼',
      gifTitle: 'ÐÐ½Ð¸Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ GIF (3 ÑÐµÐºÑƒÐ½Ð´Ñ‹)',
      htmlTitle: 'Ð˜Ð½Ñ‚ÐµÑ€Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¹ HTML Ñ„Ð°Ð¹Ð»',
      capturing: 'â³ Ð—Ð°Ñ…Ð²Ð°Ñ‚...',
    },
    
    // Card
    card: {
      hp: 'ÐžÐ—',
      weakness: 'Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚ÑŒ',
      resistance: 'Ð¡Ð¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ðµ',
      cost: 'Ð¡Ñ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ',
      illus: 'Ð¥ÑƒÐ´.',
    },
    
    // Defaults
    defaults: {
      newAbility: 'ÐÐ¾Ð²Ð°Ñ ÑÐ¿Ð¾ÑÐ¾Ð±Ð½Ð¾ÑÑ‚ÑŒ',
    },
    
    // Display options
    display: {
      title: 'ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ',
    },
  },
  
  ja: {
    // App
    appTitle: 'Card Creator',
    appSubtitle: 'ã‚ªãƒªã‚¸ãƒŠãƒ«ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã‚ˆã†',
    hoverHint: 'âœ¨ ã‚«ãƒ¼ãƒ‰ã«ãƒžã‚¦ã‚¹ã‚’ä¹—ã›ã‚‹ã¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒå¼·ããªã‚Šã¾ã™ âœ¨',
    
    // Elements
    elements: {
      Fire: 'ç‚Ž',
      Water: 'æ°´',
      Nature: 'è‡ªç„¶',
      Electric: 'é›»æ°—',
      Mystic: 'ç¥žç§˜',
      Fighting: 'æ ¼é—˜',
      Shadow: 'é—‡',
      Metal: 'é‹¼',
      Light: 'å…‰',
      Dragon: 'ãƒ‰ãƒ©ã‚´ãƒ³',
      Ice: 'æ°·',
      Neutral: 'ç„¡',
    },
    
    // Effects
    effects: {
      none: { name: 'ãªã—', description: 'ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã—' },
      holographic: { name: 'ãƒ›ãƒ­ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯', description: 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯ãªè™¹è‰²ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' },
      rainbow: { name: 'ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼', description: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ãƒ©ãƒ¼ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³' },
      gold: { name: 'ã‚´ãƒ¼ãƒ«ãƒ‰', description: 'è±ªè¯ãªé‡‘è‰²ã®åå°„' },
      silver: { name: 'ã‚·ãƒ«ãƒãƒ¼', description: 'ãƒ¡ã‚¿ãƒªãƒƒã‚¯ãªéŠ€è‰²ã®åå°„' },
      prismatic: { name: 'ãƒ—ãƒªã‚ºãƒžãƒ†ã‚£ãƒƒã‚¯', description: 'å±ˆæŠ˜ã™ã‚‹ã‚¯ãƒªã‚¹ã‚¿ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' },
      neon: { name: 'ãƒã‚ªãƒ³', description: 'é®®ã‚„ã‹ãªãƒã‚ªãƒ³ã®è¼ã' },
      galaxy: { name: 'ã‚®ãƒ£ãƒ©ã‚¯ã‚·ãƒ¼', description: 'æ˜Ÿç©ºã®å®‡å®™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' },
      fire: { name: 'ãƒ•ãƒ¬ã‚¤ãƒ ', description: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç‚Žã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' },
      ice: { name: 'ãƒ•ãƒ­ã‚¹ãƒˆ', description: 'ãã‚‰ã‚ãæ°·ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ' },
    },
    
    // Stages
    stages: ['ãƒ™ãƒ¼ã‚·ãƒƒã‚¯', 'ã‚¹ãƒ†ãƒ¼ã‚¸1', 'ã‚¹ãƒ†ãƒ¼ã‚¸2', 'ã‚¹ãƒšã‚·ãƒ£ãƒ«', 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼', 'ãƒŸã‚·ãƒƒã‚¯', 'ã‚¦ãƒ«ãƒˆãƒ©'],
    
    // Rarities
    rarities: {
      common: 'ã‚³ãƒ¢ãƒ³',
      uncommon: 'ã‚¢ãƒ³ã‚³ãƒ¢ãƒ³',
      rare: 'ãƒ¬ã‚¢',
      epic: 'ã‚¨ãƒ”ãƒƒã‚¯',
      legendary: 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼',
      mythic: 'ãƒŸã‚·ãƒƒã‚¯',
    },
    
    // Sections
    sections: {
      image: 'ç”»åƒ',
      basicInfo: 'åŸºæœ¬æƒ…å ±',
      rarityEffects: 'ãƒ¬ã‚¢ãƒªãƒ†ã‚£ï¼†ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ',
      abilities: 'æŠ€',
      stats: 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹',
      appearance: 'å¤–è¦³',
    },
    
    // Labels
    labels: {
      name: 'åå‰',
      hp: 'HP',
      element: 'ã‚¿ã‚¤ãƒ—',
      stage: 'ã‚¹ãƒ†ãƒ¼ã‚¸',
      description: 'èª¬æ˜Ž',
      author: 'ä½œè€…',
      rarity: 'ãƒ¬ã‚¢ãƒªãƒ†ã‚£',
      effect: 'ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ',
      weakness: 'å¼±ç‚¹',
      resistance: 'æŠµæŠ—åŠ›',
      retreatCost: 'ã«ã’ã‚‹ã‚³ã‚¹ãƒˆ',
      abilityName: 'æŠ€å',
      damage: 'ãƒ€ãƒ¡ãƒ¼ã‚¸',
      energyCost: 'ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚³ã‚¹ãƒˆ',
      abilityDesc: 'èª¬æ˜Ž',
      borderColor: 'æž ã®è‰²',
      backgroundColor: 'èƒŒæ™¯è‰²',
      textColor: 'æ–‡å­—è‰²',
      font: 'ãƒ•ã‚©ãƒ³ãƒˆ',
      zoom: 'ã‚ºãƒ¼ãƒ ',
    },
    
    // Buttons
    buttons: {
      addAbility: '+ æŠ€ã‚’è¿½åŠ ',
      remove: 'å‰Šé™¤',
      change: 'å¤‰æ›´',
      recenter: 'ä¸­å¤®ã«æˆ»ã™',
      download: 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰',
      autoRotate: '3Dãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼',
    },
    
    // Checkboxes
    checkboxes: {
      showHP: 'HPã‚’è¡¨ç¤º',
      showWeakRes: 'å¼±ç‚¹/æŠµæŠ—åŠ›ã‚’è¡¨ç¤º',
      showRetreat: 'ã«ã’ã‚‹ã‚³ã‚¹ãƒˆã‚’è¡¨ç¤º',
      showDescription: 'èª¬æ˜Žã‚’è¡¨ç¤º',
      showTexture: 'ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¡¨ç¤º',
      showParticles: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¡¨ç¤º',
    },
    
    // Image Editor
    imageEditor: {
      dropHint: 'ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ­ãƒƒãƒ—',
      orClick: 'ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠž',
      formats: 'PNG, JPG, GIF, WEBP (æœ€å¤§15MB)',
      loading: 'èª­ã¿è¾¼ã¿ä¸­...',
      unsupportedFormat: 'ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å½¢å¼ã§ã™ã€‚PNGã€JPGã€GIFã€WEBPã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚',
      fileTooLarge: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤§ãã™ãŽã¾ã™ã€‚æœ€å¤§15MBã§ã™ã€‚',
    },
    
    // Download
    download: {
      title: 'ðŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰',
      pngTitle: 'é€éŽPNGç”»åƒ',
      jpgTitle: 'èƒŒæ™¯ä»˜ãJPGç”»åƒ',
      gifTitle: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³GIFï¼ˆ3ç§’ï¼‰',
      htmlTitle: 'ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–HTMLãƒ•ã‚¡ã‚¤ãƒ«',
      capturing: 'â³ ã‚­ãƒ£ãƒ—ãƒãƒ£ä¸­...',
    },
    
    // Card
    card: {
      hp: 'HP',
      weakness: 'å¼±ç‚¹',
      resistance: 'æŠµæŠ—åŠ›',
      cost: 'ã‚³ã‚¹ãƒˆ',
      illus: 'ã‚¤ãƒ©ã‚¹ãƒˆ',
    },
    
    // Defaults
    defaults: {
      newAbility: 'æ–°ã—ã„æŠ€',
    },
    
    // Display options
    display: {
      title: 'è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³',
    },
  },
  
  zh: {
    // App
    appTitle: 'Card Creator',
    appSubtitle: 'åˆ›å»ºæ‚¨è‡ªå·±çš„ä¸ªæ€§åŒ–æ”¶è—å¡',
    hoverHint: 'âœ¨ å°†é¼ æ ‡æ‚¬åœåœ¨å¡ç‰‡ä¸Šä»¥å¢žå¼ºæ•ˆæžœ âœ¨',
    
    // Elements
    elements: {
      Fire: 'ç«',
      Water: 'æ°´',
      Nature: 'è‡ªç„¶',
      Electric: 'ç”µ',
      Mystic: 'ç¥žç§˜',
      Fighting: 'æ ¼æ–—',
      Shadow: 'æš—',
      Metal: 'é’¢',
      Light: 'å…‰',
      Dragon: 'é¾™',
      Ice: 'å†°',
      Neutral: 'æ— ',
    },
    
    // Effects
    effects: {
      none: { name: 'æ— ', description: 'æ— æ•ˆæžœ' },
      holographic: { name: 'å…¨æ¯', description: 'ç»å…¸å½©è™¹æ•ˆæžœ' },
      rainbow: { name: 'å½©è™¹', description: 'åŠ¨ç”»å¤šè‰²æ¸å˜' },
      gold: { name: 'é‡‘è‰²', description: 'å¥¢åŽé‡‘è‰²åå°„' },
      silver: { name: 'é“¶è‰²', description: 'é‡‘å±žé“¶è‰²åå°„' },
      prismatic: { name: 'æ£±é•œ', description: 'æŠ˜å°„æ°´æ™¶æ•ˆæžœ' },
      neon: { name: 'éœ“è™¹', description: 'é²œè‰³éœ“è™¹å…‰èŠ’' },
      galaxy: { name: 'æ˜Ÿç³»', description: 'æ˜Ÿç©ºå®‡å®™æ•ˆæžœ' },
      fire: { name: 'ç«ç„°', description: 'åŠ¨ç”»ç«ç„°æ•ˆæžœ' },
      ice: { name: 'å†°éœœ', description: 'é—ªçƒå†°æ™¶æ•ˆæžœ' },
    },
    
    // Stages
    stages: ['åŸºç¡€', 'é˜¶æ®µ1', 'é˜¶æ®µ2', 'ç‰¹æ®Š', 'ä¼ è¯´', 'ç¥žè¯', 'ç©¶æž'],
    
    // Rarities
    rarities: {
      common: 'æ™®é€š',
      uncommon: 'ç¨€æœ‰',
      rare: 'çè´µ',
      epic: 'å²è¯—',
      legendary: 'ä¼ è¯´',
      mythic: 'ç¥žè¯',
    },
    
    // Sections
    sections: {
      image: 'å›¾ç‰‡',
      basicInfo: 'åŸºæœ¬ä¿¡æ¯',
      rarityEffects: 'ç¨€æœ‰åº¦å’Œæ•ˆæžœ',
      abilities: 'æŠ€èƒ½',
      stats: 'å±žæ€§',
      appearance: 'å¤–è§‚',
    },
    
    // Labels
    labels: {
      name: 'åç§°',
      hp: 'ç”Ÿå‘½å€¼',
      element: 'å±žæ€§',
      stage: 'é˜¶æ®µ',
      description: 'æè¿°',
      author: 'ä½œè€…',
      rarity: 'ç¨€æœ‰åº¦',
      effect: 'æ•ˆæžœ',
      weakness: 'å¼±ç‚¹',
      resistance: 'æŠ—æ€§',
      retreatCost: 'æ’¤é€€æ¶ˆè€—',
      abilityName: 'æŠ€èƒ½åç§°',
      damage: 'ä¼¤å®³',
      energyCost: 'èƒ½é‡æ¶ˆè€—',
      abilityDesc: 'æè¿°',
      borderColor: 'è¾¹æ¡†é¢œè‰²',
      backgroundColor: 'èƒŒæ™¯é¢œè‰²',
      textColor: 'æ–‡å­—é¢œè‰²',
      font: 'å­—ä½“',
      zoom: 'ç¼©æ”¾',
    },
    
    // Buttons
    buttons: {
      addAbility: '+ æ·»åŠ æŠ€èƒ½',
      remove: 'åˆ é™¤',
      change: 'æ›´æ”¹',
      recenter: 'å±…ä¸­',
      download: 'ä¸‹è½½',
      autoRotate: '3Dé¢„è§ˆ',
    },
    
    // Checkboxes
    checkboxes: {
      showHP: 'æ˜¾ç¤ºç”Ÿå‘½å€¼',
      showWeakRes: 'æ˜¾ç¤ºå¼±ç‚¹/æŠ—æ€§',
      showRetreat: 'æ˜¾ç¤ºæ’¤é€€æ¶ˆè€—',
      showDescription: 'æ˜¾ç¤ºæè¿°',
      showTexture: 'æ˜¾ç¤ºçº¹ç†',
      showParticles: 'æ˜¾ç¤ºç²’å­',
    },
    
    // Image Editor
    imageEditor: {
      dropHint: 'å°†å›¾ç‰‡æ‹–æ”¾åˆ°è¿™é‡Œ',
      orClick: 'æˆ–ç‚¹å‡»é€‰æ‹©',
      formats: 'PNG, JPG, GIF, WEBP (æœ€å¤§15MB)',
      loading: 'åŠ è½½ä¸­...',
      unsupportedFormat: 'ä¸æ”¯æŒçš„æ ¼å¼ã€‚è¯·ä½¿ç”¨PNGã€JPGã€GIFæˆ–WEBPã€‚',
      fileTooLarge: 'æ–‡ä»¶å¤ªå¤§ã€‚æœ€å¤§15MBã€‚',
    },
    
    // Download
    download: {
      title: 'ðŸ“¥ ä¸‹è½½',
      pngTitle: 'é€æ˜ŽPNGå›¾ç‰‡',
      jpgTitle: 'å¸¦èƒŒæ™¯çš„JPGå›¾ç‰‡',
      gifTitle: 'åŠ¨ç”»GIFï¼ˆ3ç§’ï¼‰',
      htmlTitle: 'äº¤äº’å¼HTMLæ–‡ä»¶',
      capturing: 'â³ æ•èŽ·ä¸­...',
    },
    
    // Card
    card: {
      hp: 'HP',
      weakness: 'å¼±ç‚¹',
      resistance: 'æŠ—æ€§',
      cost: 'æ¶ˆè€—',
      illus: 'ç”»å¸ˆ',
    },
    
    // Defaults
    defaults: {
      newAbility: 'æ–°æŠ€èƒ½',
    },
    
    // Display options
    display: {
      title: 'æ˜¾ç¤ºé€‰é¡¹',
    },
  },
};

// Context pour la langue
const LanguageContext = createContext();

const useLanguage = () => {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
};

// ============================================
// CONSTANTES
// ============================================
const CARD_LIMITS = {
  HP_MIN: 0,
  HP_MAX: 999,
  DAMAGE_MIN: 0,
  DAMAGE_MAX: 9999,
  COST_MIN: 0,
  COST_MAX: 6,
  RETREAT_MIN: 0,
  RETREAT_MAX: 5,
  NAME_MAX_LENGTH: 25,
  DESC_MAX_LENGTH: 150,
  ATTACK_DESC_MAX_LENGTH: 80,
  AUTHOR_MAX_LENGTH: 30,
  MAX_FILE_SIZE: 15 * 1024 * 1024, // 15MB
  ZOOM_MIN: 1,
  ZOOM_MAX: 3,
};

const ELEMENT_TYPES = {
  Fire: { icon: 'ðŸ”¥', primary: '#FF6B35', secondary: '#FFE066' },
  Water: { icon: 'ðŸ’§', primary: '#4FC3F7', secondary: '#E1F5FE' },
  Nature: { icon: 'ðŸŒ¿', primary: '#66BB6A', secondary: '#C8E6C9' },
  Electric: { icon: 'âš¡', primary: '#FFEE58', secondary: '#FFF9C4' },
  Mystic: { icon: 'ðŸ”®', primary: '#BA68C8', secondary: '#F3E5F5' },
  Fighting: { icon: 'ðŸ‘Š', primary: '#D84315', secondary: '#FFAB91' },
  Shadow: { icon: 'ðŸŒ‘', primary: '#5D4037', secondary: '#A1887F' },
  Metal: { icon: 'âš™ï¸', primary: '#90A4AE', secondary: '#ECEFF1' },
  Light: { icon: 'âœ¨', primary: '#FFD54F', secondary: '#FFF8E1' },
  Dragon: { icon: 'ðŸ‰', primary: '#7E57C2', secondary: '#D1C4E9' },
  Ice: { icon: 'â„ï¸', primary: '#4DD0E1', secondary: '#E0F7FA' },
  Neutral: { icon: 'â­', primary: '#BDBDBD', secondary: '#F5F5F5' },
};

const ELEMENT_KEYS = Object.keys(ELEMENT_TYPES);

const CARD_EFFECTS = ['none', 'holographic', 'rainbow', 'gold', 'silver', 'prismatic', 'neon', 'galaxy', 'fire', 'ice'];

const STAGES = ['Base', 'Stage1', 'Stage2', 'Special', 'Legendary', 'Mythic', 'Ultra'];

const RARITIES = [
  { key: 'common', icon: 'âšª', color: '#8b7355', border: '#8b7355', label: 'Common' },
  { key: 'uncommon', icon: 'ðŸŸ¢', color: '#4CAF50', border: '#4CAF50', label: 'Uncommon' },
  { key: 'rare', icon: 'ðŸ’Ž', color: '#2196F3', border: '#2196F3', label: 'Rare' },
  { key: 'epic', icon: 'ðŸ’œ', color: '#9C27B0', border: '#9C27B0', label: 'Epic' },
  { key: 'legendary', icon: 'â­', color: '#ffd700', border: '#ffd700', label: 'Legendary' },
  { key: 'mythic', icon: 'ðŸŒŸ', color: '#ff4081', border: '#ff4081', label: 'Mythic' },
];

// Textures de fond par Ã©lÃ©ment (patterns SVG)
const ELEMENT_TEXTURES = {
  Fire: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5c-5 10-15 15-15 25 0 8 7 15 15 15s15-7 15-15c0-10-10-15-15-25z' fill='%23ff6b3520' /%3E%3Cpath d='M30 15c-3 6-9 9-9 15 0 5 4 9 9 9s9-4 9-9c0-6-6-9-9-15z' fill='%23ff450015' /%3E%3C/svg%3E")`,
  Water: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='15' cy='15' r='8' fill='%2300bcd420' /%3E%3Ccircle cx='45' cy='35' r='6' fill='%232196f315' /%3E%3Ccircle cx='25' cy='45' r='10' fill='%2303a9f418' /%3E%3Cpath d='M5 30 Q15 25 25 30 T45 30 T60 30' stroke='%2300bcd415' fill='none' stroke-width='2'/%3E%3C/svg%3E")`,
  Nature: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5 Q35 15 30 25 Q25 15 30 5z' fill='%234caf5020' /%3E%3Cpath d='M15 30 Q25 35 20 45 Q15 35 15 30z' fill='%238bc34a18' /%3E%3Cpath d='M45 25 Q50 35 45 45 Q40 35 45 25z' fill='%234caf5015' /%3E%3Ccircle cx='10' cy='50' r='3' fill='%234caf5012' /%3E%3C/svg%3E")`,
  Electric: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 0 L25 25 L35 20 L20 60 L25 30 L15 35 Z' fill='%23ffeb3b15' /%3E%3Cpath d='M50 10 L48 20 L52 18 L45 35' stroke='%23ffc10710' fill='none' stroke-width='2'/%3E%3Ccircle cx='10' cy='45' r='2' fill='%23ffeb3b20' /%3E%3C/svg%3E")`,
  Mystic: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='30,5 32,15 40,10 35,18 45,20 35,22 40,30 32,25 30,35 28,25 20,30 25,22 15,20 25,18 20,10 28,15' fill='%239c27b015' /%3E%3Ccircle cx='10' cy='50' r='4' fill='%23e91e6310' /%3E%3Ccircle cx='50' cy='45' r='3' fill='%239c27b012' /%3E%3C/svg%3E")`,
  Fighting: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 10 L50 50' stroke='%23f4433615' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M50 10 L10 50' stroke='%23ff572215' stroke-width='4' stroke-linecap='round'/%3E%3Cpath d='M30 5 L30 55' stroke='%23f4433610' stroke-width='3'/%3E%3Cpath d='M5 30 L55 30' stroke='%23f4433610' stroke-width='3'/%3E%3C/svg%3E")`,
  Shadow: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cellipse cx='30' cy='50' rx='20' ry='8' fill='%2300000015' /%3E%3Cellipse cx='15' cy='30' rx='10' ry='5' fill='%2300000010' /%3E%3Cellipse cx='45' cy='20' rx='12' ry='6' fill='%2300000012' /%3E%3Cpath d='M20 10 Q30 20 25 35 Q35 25 40 40' stroke='%2300000008' fill='none' stroke-width='3'/%3E%3C/svg%3E")`,
  Metal: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='5' y='5' width='20' height='20' rx='2' fill='none' stroke='%2360606015' stroke-width='2'/%3E%3Crect x='35' y='35' width='20' height='20' rx='2' fill='none' stroke='%2360606015' stroke-width='2'/%3E%3Ccircle cx='15' cy='15' r='3' fill='%2390909020' /%3E%3Ccircle cx='45' cy='45' r='3' fill='%2390909020' /%3E%3Ccircle cx='45' cy='15' r='2' fill='%2360606015' /%3E%3Ccircle cx='15' cy='45' r='2' fill='%2360606015' /%3E%3C/svg%3E")`,
  Light: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='30' cy='30' r='15' fill='%23fff59d10' /%3E%3Cpath d='M30 5 L30 15 M30 45 L30 55 M5 30 L15 30 M45 30 L55 30 M12 12 L19 19 M41 41 L48 48 M12 48 L19 41 M41 19 L48 12' stroke='%23ffeb3b15' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E")`,
  Dragon: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 20 Q20 15 30 20 Q40 15 50 20 L50 35 Q40 40 30 35 Q20 40 10 35 Z' fill='%23673ab720' /%3E%3Cpath d='M10 35 Q20 30 30 35 Q40 30 50 35 L50 50 Q40 55 30 50 Q20 55 10 50 Z' fill='%23673ab715' /%3E%3Cpath d='M10 5 Q20 0 30 5 Q40 0 50 5 L50 20 Q40 25 30 20 Q20 25 10 20 Z' fill='%23673ab712' /%3E%3C/svg%3E")`,
  Ice: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 5 L30 55 M15 15 L45 45 M45 15 L15 45' stroke='%2381d4fa20' stroke-width='2'/%3E%3Cpath d='M30 20 L25 15 M30 20 L35 15 M30 40 L25 45 M30 40 L35 45' stroke='%2329b6f618' stroke-width='2'/%3E%3Cpolygon points='30,25 33,30 30,35 27,30' fill='%2381d4fa15' /%3E%3C/svg%3E")`,
  Neutral: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='30' cy='30' r='20' fill='none' stroke='%2390909010' stroke-width='1'/%3E%3Ccircle cx='30' cy='30' r='10' fill='none' stroke='%2390909008' stroke-width='1'/%3E%3C/svg%3E")`,
};

// Configuration des particules par Ã©lÃ©ment
const ELEMENT_PARTICLES = {
  Fire: { emoji: 'ðŸ”¥', alt: ['âœ¨', 'ðŸ’«'], count: 8, speed: 'fast', direction: 'up' },
  Water: { emoji: 'ðŸ’§', alt: ['ðŸ«§', 'â—‹'], count: 10, speed: 'slow', direction: 'up' },
  Nature: { emoji: 'ðŸƒ', alt: ['ðŸŒ¿', 'âœ¿'], count: 6, speed: 'medium', direction: 'float' },
  Electric: { emoji: 'âš¡', alt: ['âœ¦', 'âš¡'], count: 5, speed: 'fast', direction: 'random' },
  Mystic: { emoji: 'âœ¨', alt: ['â­', 'ðŸ’œ'], count: 8, speed: 'slow', direction: 'float' },
  Fighting: { emoji: 'ðŸ’¥', alt: ['âœŠ', 'ðŸ’¢'], count: 4, speed: 'fast', direction: 'random' },
  Shadow: { emoji: 'ðŸŒ‘', alt: ['ðŸ‘', 'ðŸ’€'], count: 5, speed: 'slow', direction: 'down' },
  Metal: { emoji: 'âš™ï¸', alt: ['ðŸ”©', 'âœ¦'], count: 4, speed: 'slow', direction: 'float' },
  Light: { emoji: 'âœ¨', alt: ['â­', 'ðŸ’›'], count: 10, speed: 'medium', direction: 'radial' },
  Dragon: { emoji: 'ðŸ‰', alt: ['ðŸ’Ž', 'ðŸ”®'], count: 4, speed: 'medium', direction: 'float' },
  Ice: { emoji: 'â„ï¸', alt: ['â…', 'â†'], count: 12, speed: 'slow', direction: 'down' },
  Neutral: { emoji: 'âœ¦', alt: ['â—‹', 'â€¢'], count: 3, speed: 'slow', direction: 'float' },
};

const FONTS = [
  { id: 'nunito', name: 'Nunito', family: "'Nunito', sans-serif" },
  { id: 'roboto', name: 'Roboto', family: "'Roboto', sans-serif" },
  { id: 'poppins', name: 'Poppins', family: "'Poppins', sans-serif" },
  { id: 'oswald', name: 'Oswald', family: "'Oswald', sans-serif" },
  { id: 'playfair', name: 'Playfair', family: "'Playfair Display', serif" },
  { id: 'bangers', name: 'Bangers', family: "'Bangers', cursive" },
];

const INITIAL_CARD_DATA = {
  name: 'My Creature',
  hp: 120,
  type: 'Fire',
  stage: 'Base',
  weakness: 'Water',
  resistance: 'Nature',
  retreatCost: 2,
  rarity: 'rare',
  description: 'A mysterious creature with incredible powers.',
  author: 'Creator',
  effect: 'holographic',
  font: 'nunito',
  // Custom colors
  borderColor: '',
  backgroundColor: '',
  textColor: '',
  // Display options
  showHP: true,
  showWeakRes: true,
  showRetreat: true,
  showDescription: true,
  showTexture: false,
  showParticles: true,
};

const INITIAL_ATTACKS = [
  { id: 'attack-1', name: 'Quick Attack', damage: 30, cost: 1, desc: 'Deals basic damage.' },
  { id: 'attack-2', name: 'Special Attack', damage: 80, cost: 3, desc: 'A devastating attack!' },
];

const INITIAL_IMAGE_SETTINGS = {
  zoom: 1,
  offsetX: 0,
  offsetY: 0,
};

// ============================================
// UTILITAIRES
// ============================================
const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

const parseIntSafe = (value, fallback = 0) => {
  const parsed = parseInt(value, 10);
  return isNaN(parsed) ? fallback : parsed;
};

const parseFloatSafe = (value, fallback = 0) => {
  const parsed = parseFloat(value);
  return isNaN(parsed) ? fallback : parsed;
};

const generateId = () => `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

// Hook throttle pour limiter les appels de fonction
const useThrottle = (callback, delay) => {
  const lastCall = useRef(0);
  const callbackRef = useRef(callback);
  callbackRef.current = callback;
  
  return useCallback((...args) => {
    const now = Date.now();
    if (now - lastCall.current >= delay) {
      lastCall.current = now;
      callbackRef.current(...args);
    }
  }, [delay]);
};

// ============================================
// FONCTIONS DE TÃ‰LÃ‰CHARGEMENT
// ============================================

// Capturer le canvas de la carte (version propre sans effets problÃ©matiques)
const captureCard = async (cardElement, options = {}) => {
  if (!cardElement) throw new Error('Element non trouvÃ©');
  
  // Charger html2canvas dynamiquement
  if (!window.html2canvas) {
    await new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  
  // Trouver le conteneur parent pour rÃ©initialiser la transformation 3D
  const container = cardElement.closest('.card-3d-container') || cardElement.parentElement;
  const originalContainerTransform = container ? container.style.transform : '';
  
  // RÃ©initialiser la transformation 3D du conteneur
  if (container) {
    container.style.transform = 'perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)';
  }
  
  // Masquer TOUS les Ã©lÃ©ments qui causent des problÃ¨mes avec html2canvas
  const problematicElements = cardElement.querySelectorAll('.effect-layer, .particles-layer, .texture-layer');
  const originalStyles = [];
  
  problematicElements.forEach((el, i) => {
    originalStyles[i] = {
      display: el.style.display,
      visibility: el.style.visibility,
      opacity: el.style.opacity
    };
    el.style.display = 'none';
    el.style.visibility = 'hidden';
    el.style.opacity = '0';
  });
  
  // RÃ©initialiser les transformations de la carte elle-mÃªme
  const originalCardTransform = cardElement.style.transform;
  cardElement.style.transform = 'none';
  
  // Attendre un tick pour que les styles soient appliquÃ©s
  await new Promise(r => setTimeout(r, 50));
  
  const canvas = await window.html2canvas(cardElement, {
    backgroundColor: options.backgroundColor || null,
    scale: options.scale || 2,
    useCORS: true,
    allowTaint: true,
    logging: false,
    removeContainer: true,
  });
  
  // Restaurer tous les styles
  problematicElements.forEach((el, i) => {
    el.style.display = originalStyles[i].display;
    el.style.visibility = originalStyles[i].visibility;
    el.style.opacity = originalStyles[i].opacity;
  });
  
  cardElement.style.transform = originalCardTransform;
  
  if (container) {
    container.style.transform = originalContainerTransform;
  }
  
  return canvas;
};

// TÃ©lÃ©charger en PNG (carte propre sans effets animÃ©s)
const downloadAsPNG = async (cardElement, filename = 'card') => {
  try {
    const canvas = await captureCard(cardElement);
    const link = document.createElement('a');
    link.download = `${filename}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
    return true;
  } catch (error) {
    console.error('Erreur PNG:', error);
    return false;
  }
};

// TÃ©lÃ©charger en JPG (carte propre sans effets animÃ©s)
const downloadAsJPG = async (cardElement, filename = 'card') => {
  try {
    const canvas = await captureCard(cardElement, { backgroundColor: '#1a1a2e' });
    const link = document.createElement('a');
    link.download = `${filename}.jpg`;
    link.href = canvas.toDataURL('image/jpeg', 0.95);
    link.click();
    return true;
  } catch (error) {
    console.error('Erreur JPG:', error);
    return false;
  }
};

// CSS des effets pour export HTML
const getEffectCSS = () => `
  .effect-holographic .layer-1 {
    background: linear-gradient(125deg, rgba(255,0,0,0.08) 0%, rgba(255,154,0,0.08) 10%, rgba(208,222,33,0.08) 20%, rgba(79,220,74,0.08) 30%, rgba(63,218,216,0.08) 40%, rgba(47,201,226,0.08) 50%, rgba(28,127,238,0.08) 60%, rgba(95,21,242,0.08) 70%, rgba(186,12,248,0.08) 80%, rgba(251,7,217,0.08) 90%, rgba(255,0,0,0.08) 100%);
    background-size: 400% 400%; animation: holoGradient 8s ease infinite; mix-blend-mode: color;
  }
  .effect-holographic:hover .layer-1 {
    background: linear-gradient(125deg, rgba(255,0,0,0.2) 0%, rgba(255,154,0,0.2) 10%, rgba(208,222,33,0.2) 20%, rgba(79,220,74,0.2) 30%, rgba(63,218,216,0.2) 40%, rgba(47,201,226,0.2) 50%, rgba(28,127,238,0.2) 60%, rgba(95,21,242,0.2) 70%, rgba(186,12,248,0.2) 80%, rgba(251,7,217,0.2) 90%, rgba(255,0,0,0.2) 100%);
    animation: holoGradient 3s ease infinite;
  }
  @keyframes holoGradient { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } }
  
  .effect-rainbow .layer-1 {
    background: linear-gradient(90deg, rgba(255,0,0,0.12) 0%, rgba(255,127,0,0.12) 14%, rgba(255,255,0,0.12) 28%, rgba(0,255,0,0.12) 42%, rgba(0,0,255,0.12) 57%, rgba(75,0,130,0.12) 71%, rgba(148,0,211,0.12) 85%, rgba(255,0,0,0.12) 100%);
    background-size: 300% 100%; animation: rainbowSlide 6s linear infinite; mix-blend-mode: color;
  }
  .effect-rainbow:hover .layer-1 {
    background: linear-gradient(90deg, rgba(255,0,0,0.28) 0%, rgba(255,127,0,0.28) 14%, rgba(255,255,0,0.28) 28%, rgba(0,255,0,0.28) 42%, rgba(0,0,255,0.28) 57%, rgba(75,0,130,0.28) 71%, rgba(148,0,211,0.28) 85%, rgba(255,0,0,0.28) 100%);
    animation: rainbowSlide 3s linear infinite;
  }
  @keyframes rainbowSlide { 0% { background-position: 0% 50%; } 100% { background-position: 300% 50%; } }
  
  .effect-gold .layer-1 {
    background: linear-gradient(-45deg, transparent 35%, rgba(255,200,50,0.15) 47%, rgba(255,240,150,0.3) 50%, rgba(255,200,50,0.15) 53%, transparent 65%);
    background-size: 300% 300%; animation: goldShine 4s ease-in-out infinite; mix-blend-mode: soft-light;
  }
  .effect-gold:hover .layer-1 {
    background: linear-gradient(-45deg, transparent 30%, rgba(255,200,50,0.25) 45%, rgba(255,240,150,0.45) 50%, rgba(255,200,50,0.25) 55%, transparent 70%);
    animation: goldShine 2s ease-in-out infinite;
  }
  @keyframes goldShine { 0%, 100% { background-position: 100% 100%; } 50% { background-position: 0% 0%; } }
  
  .effect-silver .layer-1 {
    background: linear-gradient(-45deg, transparent 35%, rgba(180,180,200,0.18) 47%, rgba(255,255,255,0.35) 50%, rgba(180,180,200,0.18) 53%, transparent 65%);
    background-size: 300% 300%; animation: goldShine 4s ease-in-out infinite; mix-blend-mode: soft-light;
  }
  .effect-silver:hover .layer-1 {
    background: linear-gradient(-45deg, transparent 30%, rgba(180,180,200,0.28) 45%, rgba(255,255,255,0.5) 50%, rgba(180,180,200,0.28) 55%, transparent 70%);
    animation: goldShine 2s ease-in-out infinite;
  }
  
  .effect-prismatic .layer-1 {
    background: conic-gradient(from 0deg at 50% 50%, rgba(255,0,0,0.15), rgba(255,127,0,0.15), rgba(255,255,0,0.15), rgba(0,255,0,0.15), rgba(0,255,255,0.15), rgba(0,0,255,0.15), rgba(255,0,255,0.15), rgba(255,0,0,0.15));
    animation: prismaticRotate 8s linear infinite; mix-blend-mode: color;
  }
  .effect-prismatic:hover .layer-1 {
    background: conic-gradient(from 0deg at 50% 50%, rgba(255,0,0,0.3), rgba(255,127,0,0.3), rgba(255,255,0,0.3), rgba(0,255,0,0.3), rgba(0,255,255,0.3), rgba(0,0,255,0.3), rgba(255,0,255,0.3), rgba(255,0,0,0.3));
    animation: prismaticRotate 3s linear infinite;
  }
  @keyframes prismaticRotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  
  .effect-neon .layer-1 {
    background: linear-gradient(45deg, transparent 40%, rgba(0,255,255,0.15) 50%, transparent 60%), linear-gradient(-45deg, transparent 40%, rgba(255,0,255,0.15) 50%, transparent 60%);
    animation: neonPulse 2s ease-in-out infinite; mix-blend-mode: hard-light;
  }
  .effect-neon:hover .layer-1 {
    background: linear-gradient(45deg, transparent 35%, rgba(0,255,255,0.3) 50%, transparent 65%), linear-gradient(-45deg, transparent 35%, rgba(255,0,255,0.3) 50%, transparent 65%);
    animation: neonPulse 1s ease-in-out infinite;
  }
  @keyframes neonPulse { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }
  
  .effect-galaxy .layer-1 {
    background: radial-gradient(ellipse at 30% 20%, rgba(80,40,140,0.2) 0%, transparent 40%), radial-gradient(ellipse at 70% 80%, rgba(50,30,120,0.18) 0%, transparent 35%), radial-gradient(circle at 20% 70%, rgba(255,255,255,0.9) 0%, transparent 1.5%), radial-gradient(circle at 80% 30%, rgba(255,255,255,0.85) 0%, transparent 1.2%), radial-gradient(circle at 60% 60%, rgba(255,220,255,0.8) 0%, transparent 1.5%);
    animation: galaxyRotate 20s linear infinite; mix-blend-mode: screen;
  }
  .effect-galaxy:hover .layer-1 { animation: galaxyRotate 10s linear infinite; }
  @keyframes galaxyRotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  
  .effect-fire .layer-1 {
    background: linear-gradient(0deg, rgba(255,100,0,0.2) 0%, transparent 40%), radial-gradient(ellipse at 50% 90%, rgba(255,200,50,0.25) 0%, transparent 30%), radial-gradient(circle at 40% 75%, rgba(255,255,100,0.5) 0%, transparent 8%);
    animation: fireFlicker 0.4s ease-in-out infinite alternate; mix-blend-mode: hard-light;
  }
  .effect-fire:hover .layer-1 {
    background: linear-gradient(0deg, rgba(255,100,0,0.35) 0%, transparent 50%), radial-gradient(ellipse at 50% 90%, rgba(255,200,50,0.4) 0%, transparent 35%), radial-gradient(circle at 40% 75%, rgba(255,255,100,0.7) 0%, transparent 10%);
    animation: fireFlicker 0.25s ease-in-out infinite alternate;
  }
  @keyframes fireFlicker { 0% { transform: translateY(0); opacity: 0.9; } 100% { transform: translateY(-2px); opacity: 1; } }
  
  .effect-ice .layer-1 {
    background: linear-gradient(135deg, rgba(200,240,255,0.12) 0%, transparent 50%, rgba(200,240,255,0.12) 100%), radial-gradient(circle at 20% 20%, rgba(255,255,255,0.85) 0%, transparent 3%), radial-gradient(circle at 80% 25%, rgba(200,240,255,0.75) 0%, transparent 2.5%);
    animation: iceSparkle 3s ease-in-out infinite; mix-blend-mode: soft-light;
  }
  .effect-ice:hover .layer-1 {
    background: linear-gradient(135deg, rgba(200,240,255,0.25) 0%, transparent 50%, rgba(200,240,255,0.25) 100%), radial-gradient(circle at 20% 20%, rgba(255,255,255,1) 0%, transparent 4%), radial-gradient(circle at 80% 25%, rgba(200,240,255,0.9) 0%, transparent 3%);
    animation: iceSparkle 1.5s ease-in-out infinite;
  }
  @keyframes iceSparkle { 0%, 100% { opacity: 0.85; } 50% { opacity: 1; } }
`;

// GÃ©nÃ©rer HTML interactif avec animation automatique
const generateInteractiveHTML = (cardData, attacks, image, imageSettings) => {
  const typeData = ELEMENT_TYPES[cardData.type] || ELEMENT_TYPES.Neutral;
  const weaknessData = ELEMENT_TYPES[cardData.weakness] || ELEMENT_TYPES.Water;
  const resistanceData = ELEMENT_TYPES[cardData.resistance] || ELEMENT_TYPES.Fighting;
  const rarityData = RARITIES.find(r => r.key === cardData.rarity) || RARITIES[0];
  const fontData = FONTS.find(f => f.id === cardData.font) || FONTS[0];
  
  const borderColor = cardData.borderColor || rarityData.color;
  const textColor = cardData.textColor || '#1a1a2e';
  const cardGradient = cardData.backgroundColor || `linear-gradient(135deg, ${typeData.primary}dd 0%, ${typeData.secondary}dd 100%)`;
  
  const imageStyle = image ? `background-image: url('${image}'); background-size: ${imageSettings.zoom * 100}%; background-position: calc(50% + ${imageSettings.offsetX}px) calc(50% + ${imageSettings.offsetY}px); background-repeat: no-repeat;` : '';

  // GÃ©nÃ©rer le CSS des effets selon le type d'effet choisi
  const getEffectSpecificCSS = () => {
    const effect = cardData.effect;
    if (effect === 'none') return '';
    
    const effects = {
      holographic: `
        .game-card .layer-1 {
          background: linear-gradient(125deg, 
            hsla(0, 70%, 60%, 0.3), hsla(60, 70%, 60%, 0.3), hsla(120, 70%, 60%, 0.3),
            hsla(180, 70%, 60%, 0.3), hsla(240, 70%, 60%, 0.3), hsla(300, 70%, 60%, 0.3));
          background-size: 400% 400%;
          animation: holoMove 6s ease infinite;
          mix-blend-mode: color;
        }
        @keyframes holoMove {
          0%, 100% { background-position: 0% 50%; }
          50% { background-position: 100% 50%; }
        }
      `,
      rainbow: `
        .game-card .layer-1 {
          background: repeating-linear-gradient(90deg,
            rgba(255,0,0,0.35) 0%, rgba(255,127,0,0.35) 14%, rgba(255,255,0,0.35) 28%,
            rgba(0,255,0,0.35) 42%, rgba(0,127,255,0.35) 56%, rgba(127,0,255,0.35) 70%,
            rgba(255,0,127,0.35) 84%, rgba(255,0,0,0.35) 100%);
          background-size: 200% 100%;
          animation: rainbowSlide 4s linear infinite;
          mix-blend-mode: color;
        }
        @keyframes rainbowSlide {
          0% { background-position: 0% 0%; }
          100% { background-position: 200% 0%; }
        }
      `,
      gold: `
        .game-card .layer-1 {
          background: radial-gradient(ellipse 120% 80% at 50% 50%, 
            rgba(255,215,0,0.5) 0%, rgba(255,180,0,0.3) 40%, transparent 70%);
          animation: goldShine 3s ease-in-out infinite;
          mix-blend-mode: hard-light;
        }
        .game-card .layer-3 {
          background: radial-gradient(circle at 30% 30%, rgba(255,255,200,0.8) 0%, transparent 10%),
                      radial-gradient(circle at 70% 60%, rgba(255,250,180,0.7) 0%, transparent 8%);
          mix-blend-mode: overlay;
        }
        @keyframes goldShine {
          0%, 100% { opacity: 0.8; transform: translateX(-10%) translateY(-10%); }
          50% { opacity: 1; transform: translateX(10%) translateY(10%); }
        }
      `,
      silver: `
        .game-card .layer-1 {
          background: radial-gradient(ellipse 120% 80% at 50% 50%, 
            rgba(220,230,255,0.6) 0%, rgba(180,190,210,0.4) 40%, transparent 70%);
          animation: silverShine 3s ease-in-out infinite;
          mix-blend-mode: hard-light;
        }
        .game-card .layer-3 {
          background: radial-gradient(circle at 25% 25%, rgba(255,255,255,0.9) 0%, transparent 8%),
                      radial-gradient(circle at 75% 70%, rgba(230,235,255,0.8) 0%, transparent 6%);
          mix-blend-mode: overlay;
        }
        @keyframes silverShine {
          0%, 100% { opacity: 0.85; transform: translateX(-10%) translateY(-10%); }
          50% { opacity: 1; transform: translateX(10%) translateY(10%); }
        }
      `,
      prismatic: `
        .game-card .layer-1 {
          background: linear-gradient(45deg, transparent 20%, rgba(255,0,100,0.3) 40%, 
            rgba(255,200,0,0.35) 50%, rgba(0,255,100,0.3) 60%, transparent 80%),
            linear-gradient(-45deg, transparent 25%, rgba(0,200,255,0.25) 45%, 
            rgba(100,0,255,0.3) 55%, transparent 75%);
          animation: prismaticBeam 5s ease-in-out infinite;
          mix-blend-mode: screen;
        }
        @keyframes prismaticBeam {
          0%, 100% { background-position: -50% -50%; }
          50% { background-position: 150% 150%; }
        }
      `,
      neon: `
        .game-card .layer-1 {
          background: radial-gradient(ellipse 100% 60% at 30% 30%, rgba(0,255,255,0.5) 0%, transparent 50%),
                      radial-gradient(ellipse 80% 50% at 70% 70%, rgba(255,0,255,0.45) 0%, transparent 45%);
          animation: neonPulse 2s ease-in-out infinite;
          mix-blend-mode: screen;
        }
        @keyframes neonPulse {
          0%, 100% { opacity: 0.7; filter: brightness(1); }
          50% { opacity: 1; filter: brightness(1.3); }
        }
      `,
      galaxy: `
        .game-card .layer-1 {
          background: radial-gradient(ellipse 70% 50% at 30% 30%, rgba(120,40,200,0.6) 0%, transparent 50%),
                      radial-gradient(ellipse 60% 45% at 70% 70%, rgba(60,30,180,0.5) 0%, transparent 45%);
          animation: galaxyRotate 20s linear infinite;
          mix-blend-mode: screen;
        }
        .game-card .layer-3 {
          background: radial-gradient(circle at 20% 30%, rgba(255,255,255,0.9) 0%, transparent 3%),
                      radial-gradient(circle at 80% 20%, rgba(255,255,255,0.85) 0%, transparent 2.5%),
                      radial-gradient(circle at 50% 60%, rgba(255,220,255,0.8) 0%, transparent 3%),
                      radial-gradient(circle at 30% 80%, rgba(200,200,255,0.75) 0%, transparent 2%);
          mix-blend-mode: screen;
        }
        @keyframes galaxyRotate {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `,
      fire: `
        .game-card .layer-1 {
          background: linear-gradient(0deg, rgba(255,100,0,0.5) 0%, rgba(255,50,0,0.3) 30%, transparent 60%),
                      radial-gradient(ellipse 80% 55% at 50% 85%, rgba(255,180,50,0.6) 0%, transparent 50%);
          animation: fireFlicker 0.15s ease-in-out infinite alternate, fireRise 1s ease-in-out infinite;
          mix-blend-mode: screen;
        }
        .game-card .layer-3 {
          background: radial-gradient(circle at 35% 70%, rgba(255,255,100,0.9) 0%, transparent 10%),
                      radial-gradient(circle at 65% 75%, rgba(255,200,50,0.8) 0%, transparent 8%);
          mix-blend-mode: screen;
        }
        @keyframes fireFlicker { 0% { opacity: 0.85; } 100% { opacity: 1; } }
        @keyframes fireRise { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-4px); } }
      `,
      ice: `
        .game-card .layer-1 {
          background: linear-gradient(135deg, rgba(180,230,255,0.4) 0%, transparent 35%, 
            rgba(200,240,255,0.35) 65%, transparent 100%),
            linear-gradient(45deg, transparent 40%, rgba(220,250,255,0.3) 50%, transparent 60%);
          animation: iceSparkle 2s ease-in-out infinite;
          mix-blend-mode: hard-light;
        }
        .game-card .layer-3 {
          background: radial-gradient(circle at 15% 20%, rgba(255,255,255,0.95) 0%, transparent 5%),
                      radial-gradient(circle at 85% 25%, rgba(230,250,255,0.9) 0%, transparent 4%),
                      radial-gradient(circle at 20% 75%, rgba(255,255,255,0.85) 0%, transparent 5%);
          mix-blend-mode: overlay;
        }
        @keyframes iceSparkle { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }
      `
    };
    return effects[effect] || '';
  };

  return `<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${cardData.name} - Carte Interactive</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&family=Bangers&family=Roboto:wght@400;500;700&family=Poppins:wght@400;500;600;700&family=Oswald:wght@400;500;600&family=Playfair+Display:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f1a 100%);
      font-family: '${fontData.family}', sans-serif; padding: 20px;
    }
    .card-container {
      position: relative; cursor: pointer; transform-style: preserve-3d;
    }
    .game-card {
      width: 320px; height: 448px; border-radius: 16px; position: relative; overflow: hidden;
      border: 5px solid ${borderColor}; background: ${cardGradient}; font-family: '${fontData.family}', sans-serif;
      box-shadow: 0 0 20px rgba(0,0,0,0.5), 0 10px 40px rgba(0,0,0,0.4), inset 0 0 60px rgba(255,255,255,0.05);
      transition: box-shadow 0.3s ease;
    }
    .game-card:hover { box-shadow: 0 0 30px rgba(0,0,0,0.4), 0 15px 50px rgba(0,0,0,0.35), inset 0 0 80px rgba(255,255,255,0.08); }
    .card-inner {
      position: absolute; inset: 8px; background: rgba(255,255,255,0.95); border-radius: 10px;
      padding: 10px; display: flex; flex-direction: column; color: ${textColor}; overflow: hidden;
    }
    .effect-layer { position: absolute; inset: 0; pointer-events: none; border-radius: 12px; transition: all 0.15s ease-out; }
    .effect-layer.layer-1 { z-index: 10; }
    .effect-layer.layer-2 { z-index: 11; }
    .effect-layer.layer-3 { z-index: 12; }
    .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; min-height: 28px; }
    .card-header-left { display: flex; align-items: center; gap: 6px; flex: 1; min-width: 0; }
    .card-header-right { display: flex; align-items: center; gap: 4px; flex-shrink: 0; }
    .stage-badge { font-size: 9px; padding: 2px 6px; border-radius: 4px; color: white; font-weight: 700; background: ${typeData.primary}; }
    .creature-name { font-weight: 900; font-size: 16px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .hp-value { font-size: 18px; font-weight: 900; color: #e53935; }
    .type-icon { font-size: 18px; }
    .card-image { flex: 0 0 150px; border-radius: 8px; border: 3px solid ${typeData.primary}; display: flex; align-items: center; justify-content: center; margin-bottom: 6px; background-color: #f5f5f5; ${imageStyle} }
    .placeholder-icon { font-size: 50px; opacity: 0.4; }
    .card-description { font-size: 8px; color: #555; text-align: center; padding: 3px 8px; background: rgba(0,0,0,0.04); border-radius: 4px; margin-bottom: 6px; font-style: italic; }
    .attacks-container { flex: 1; display: flex; flex-direction: column; gap: 5px; overflow: hidden; }
    .attack-card { background: rgba(255,255,255,0.7); border-radius: 6px; padding: 6px 8px; border: 1px solid rgba(0,0,0,0.08); }
    .attack-header { display: flex; align-items: center; gap: 4px; }
    .attack-cost { display: flex; gap: 1px; flex-shrink: 0; }
    .energy-icon { font-size: 11px; }
    .attack-name { font-weight: 700; font-size: 12px; flex: 1; margin-left: 4px; }
    .attack-damage { font-weight: 900; font-size: 14px; flex-shrink: 0; }
    .attack-desc { font-size: 8px; color: #666; margin-top: 2px; }
    .card-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 6px; padding-top: 5px; border-top: 1px solid rgba(0,0,0,0.08); font-size: 8px; }
    .footer-stats { display: flex; gap: 10px; }
    .stat { display: flex; align-items: center; }
    .stat-label { color: #888; }
    .stat-icon { font-size: 12px; }
    .stat-value.weakness { color: #e53935; font-weight: 700; }
    .stat-value.resistance { color: #43a047; font-weight: 700; }
    .retreat-icon { font-size: 9px; }
    .card-author { text-align: center; font-size: 6px; color: #999; margin-top: 3px; }
    .rarity-indicator { position: absolute; bottom: 12px; right: 12px; font-size: 14px; z-index: 5; }
    .rarity-indicator.legendary { filter: drop-shadow(0 0 4px gold); }
    .rarity-indicator.mythic { filter: drop-shadow(0 0 6px #ff4081); animation: pulse 1.5s ease-in-out infinite; }
    .rarity-indicator.epic { filter: drop-shadow(0 0 4px #9C27B0); }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
    .controls { margin-top: 20px; display: flex; gap: 10px; }
    .btn { padding: 10px 20px; border: 2px solid rgba(255,255,255,0.3); border-radius: 20px; background: rgba(255,255,255,0.1); color: #fff; cursor: pointer; font-size: 14px; transition: all 0.2s; }
    .btn:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.5); }
    .btn.active { background: rgba(100,255,150,0.2); border-color: rgba(100,255,150,0.6); color: #7fffaa; }
    .hint { margin-top: 15px; color: rgba(255,255,255,0.5); font-size: 12px; }
    ${getEffectSpecificCSS()}
  </style>
</head>
<body>
  <div class="card-container" id="cardContainer">
    <div class="game-card" id="gameCard">
      <div class="effect-layer layer-1" id="layer1"></div>
      <div class="effect-layer layer-2" id="layer2"></div>
      <div class="effect-layer layer-3" id="layer3"></div>
      <div class="card-inner">
        <div class="card-header">
          <div class="card-header-left">
            <span class="stage-badge">${cardData.stage}</span>
            <span class="creature-name">${cardData.name}</span>
          </div>
          ${cardData.showHP ? `<div class="card-header-right"><span class="hp-value">HP ${cardData.hp}</span><span class="type-icon">${typeData.icon}</span></div>` : ''}
        </div>
        <div class="card-image">${!image ? `<span class="placeholder-icon">${typeData.icon}</span>` : ''}</div>
        ${cardData.showDescription && cardData.description ? `<div class="card-description">${cardData.description}</div>` : ''}
        <div class="attacks-container">
          ${attacks.map(attack => `<div class="attack-card"><div class="attack-header"><div class="attack-cost">${[...Array(Math.min(10, attack.cost))].map(() => `<span class="energy-icon">${typeData.icon}</span>`).join('')}</div><span class="attack-name">${attack.name}</span><span class="attack-damage">${attack.damage}</span></div>${attack.desc ? `<div class="attack-desc">${attack.desc}</div>` : ''}</div>`).join('')}
        </div>
        <div class="card-footer">
          ${cardData.showWeakRes ? `<div class="footer-stats"><div class="stat"><span class="stat-label">Weakness </span><span class="stat-icon">${weaknessData.icon}</span><span class="stat-value weakness"> Ã—2</span></div><div class="stat"><span class="stat-label">Resistance </span><span class="stat-icon">${resistanceData.icon}</span><span class="stat-value resistance"> -30</span></div></div>` : '<div></div>'}
          ${cardData.showRetreat ? `<div class="retreat-cost"><span class="stat-label">Cost </span>${[...Array(cardData.retreatCost)].map(() => `<span class="retreat-icon">âšª</span>`).join('')}</div>` : ''}
        </div>
        ${cardData.author ? `<div class="card-author">Illus. ${cardData.author} â€¢ Card Creator</div>` : ''}
      </div>
      <div class="rarity-indicator ${cardData.rarity}">${rarityData.icon}</div>
    </div>
  </div>
  <div class="controls">
    <button class="btn active" id="autoBtn" onclick="toggleAuto()">â¸ï¸ Auto 3D</button>
  </div>
  <p class="hint">âœ¨ Move your mouse over the card or use Auto 3D âœ¨</p>
  <script>
    const container = document.getElementById('cardContainer');
    const card = document.getElementById('gameCard');
    const layer2 = document.getElementById('layer2');
    const autoBtn = document.getElementById('autoBtn');
    let autoRotate = true;
    let angle = 0;
    let animationId = null;
    
    function updateCard(x, y) {
      const rotateY = (x - 0.5) * 15;
      const rotateX = (0.5 - y) * 15;
      container.style.transform = 'perspective(1000px) rotateY(' + rotateY + 'deg) rotateX(' + rotateX + 'deg) scale(1.02)';
      const lightAngle = Math.atan2(y - 0.5, x - 0.5) * (180 / Math.PI) + 180;
      layer2.style.background = 'linear-gradient(' + lightAngle + 'deg, transparent 42%, rgba(255,255,255,0.5) 49%, rgba(255,255,255,0.7) 50%, rgba(255,255,255,0.5) 51%, transparent 58%)';
      layer2.style.mixBlendMode = 'soft-light';
    }
    
    function animate() {
      if (!autoRotate) return;
      angle += 0.02;
      const x = 0.5 + Math.sin(angle) * 0.35;
      const y = 0.5 + Math.sin(angle * 2) * 0.25;
      updateCard(x, y);
      animationId = requestAnimationFrame(animate);
    }
    
    function toggleAuto() {
      autoRotate = !autoRotate;
      autoBtn.textContent = autoRotate ? 'â¸ï¸ Auto 3D' : 'â–¶ï¸ Auto 3D';
      autoBtn.classList.toggle('active', autoRotate);
      if (autoRotate) {
        animate();
      } else {
        if (animationId) cancelAnimationFrame(animationId);
        container.style.transform = 'perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)';
        layer2.style.background = '';
      }
    }
    
    container.addEventListener('mouseenter', () => {
      if (autoRotate && animationId) {
        cancelAnimationFrame(animationId);
      }
    });
    
    container.addEventListener('mouseleave', () => {
      if (autoRotate) {
        animate();
      } else {
        container.style.transform = 'perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)';
        layer2.style.background = '';
      }
    });
    
    container.addEventListener('mousemove', (e) => {
      const rect = card.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      updateCard(x, y);
    });
    
    // Start auto animation
    animate();
  <` + `/script>
</body>
</html>`;
};

// TÃ©lÃ©charger HTML interactif
const downloadAsHTML = (cardData, attacks, image, imageSettings) => {
  const html = generateInteractiveHTML(cardData, attacks, image, imageSettings);
  const blob = new Blob([html], { type: 'text/html' });
  const link = document.createElement('a');
  link.download = `${cardData.name || 'card'}-interactive.html`;
  link.href = URL.createObjectURL(blob);
  link.click();
  URL.revokeObjectURL(link.href);
};

// Capturer une vidÃ©o de l'animation 3D (utilise l'enregistrement d'Ã©cran)
const downloadAsVideo = async (cardElement, filename = 'card', duration = 4000) => {
  if (!cardElement) return false;
  
  try {
    // Demander la permission de capturer l'Ã©cran
    const stream = await navigator.mediaDevices.getDisplayMedia({
      video: {
        mediaSource: 'screen',
        cursor: 'never'
      },
      audio: false
    });
    
    // Configurer le recorder
    const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') 
      ? 'video/webm;codecs=vp9' 
      : MediaRecorder.isTypeSupported('video/webm') 
        ? 'video/webm' 
        : 'video/mp4';
    
    const recorder = new MediaRecorder(stream, { 
      mimeType,
      videoBitsPerSecond: 5000000 // 5 Mbps pour une bonne qualitÃ©
    });
    
    const chunks = [];
    
    recorder.ondataavailable = (e) => {
      if (e.data.size > 0) chunks.push(e.data);
    };
    
    recorder.onstop = () => {
      // ArrÃªter toutes les pistes du stream
      stream.getTracks().forEach(track => track.stop());
      
      const blob = new Blob(chunks, { type: mimeType });
      const link = document.createElement('a');
      const ext = mimeType.includes('webm') ? 'webm' : 'mp4';
      link.download = `${filename}-3d-animation.${ext}`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    };
    
    // DÃ©marrer l'enregistrement
    recorder.start();
    
    // Afficher un message pour informer l'utilisateur
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.9);color:#fff;padding:15px 25px;border-radius:10px;z-index:99999;font-family:sans-serif;text-align:center;';
    overlay.innerHTML = `<div style="font-size:18px;margin-bottom:5px;">ðŸ”´ Recording...</div><div style="font-size:14px;opacity:0.8;">${Math.ceil(duration/1000)} seconds remaining</div>`;
    document.body.appendChild(overlay);
    
    // Compte Ã  rebours
    let remaining = duration;
    const countdown = setInterval(() => {
      remaining -= 1000;
      if (remaining > 0) {
        overlay.innerHTML = `<div style="font-size:18px;margin-bottom:5px;">ðŸ”´ Recording...</div><div style="font-size:14px;opacity:0.8;">${Math.ceil(remaining/1000)} seconds remaining</div>`;
      }
    }, 1000);
    
    // ArrÃªter aprÃ¨s la durÃ©e spÃ©cifiÃ©e
    await new Promise(r => setTimeout(r, duration));
    
    clearInterval(countdown);
    document.body.removeChild(overlay);
    recorder.stop();
    
    return true;
    
  } catch (error) {
    console.error('Erreur capture vidÃ©o:', error);
    
    // Si l'utilisateur refuse ou erreur, proposer alternative
    if (error.name === 'NotAllowedError') {
      alert('Pour capturer la vidÃ©o, sÃ©lectionnez l\'onglet ou la fenÃªtre contenant la carte, puis attendez la fin de l\'enregistrement.');
    }
    return false;
  }
};
const InputGroup = React.memo(({ 
  id, 
  label, 
  type = 'text', 
  value, 
  onChange, 
  min, 
  max, 
  step,
  maxLength,
  rows,
  options,
  style,
  className = '',
  disabled = false,
}) => {
  const inputId = `input-${id}`;
  
  const handleChange = useCallback((e) => {
    onChange(e.target.value);
  }, [onChange]);
  
  const renderInput = () => {
    const commonProps = {
      id: inputId,
      value,
      onChange: handleChange,
      disabled,
    };

    if (options) {
      return (
        <select {...commonProps}>
          {options.map(opt => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>
      );
    }

    if (rows) {
      return (
        <textarea 
          {...commonProps}
          rows={rows}
          maxLength={maxLength}
          style={{ resize: 'none' }}
        />
      );
    }

    if (type === 'color') {
      return (
        <div className="color-input-wrapper">
          <input 
            {...commonProps}
            type="color"
            className="color-input"
          />
          <input 
            type="text"
            value={value}
            onChange={handleChange}
            placeholder="#RRGGBB"
            className="color-text-input"
            maxLength={7}
          />
        </div>
      );
    }

    return (
      <input 
        {...commonProps}
        type={type}
        min={min}
        max={max}
        step={step}
        maxLength={maxLength}
      />
    );
  };

  return (
    <div className={`input-group ${className}`} style={style}>
      <label htmlFor={inputId}>{label}</label>
      {renderInput()}
    </div>
  );
});

InputGroup.displayName = 'InputGroup';

const Checkbox = React.memo(({ id, label, checked, onChange }) => {
  const inputId = `checkbox-${id}`;
  
  return (
    <div className="checkbox-group">
      <input 
        type="checkbox"
        id={inputId}
        checked={checked}
        onChange={(e) => onChange(e.target.checked)}
      />
      <label htmlFor={inputId}>{label}</label>
    </div>
  );
});

Checkbox.displayName = 'Checkbox';

const AttackEditor = React.memo(({ 
  index, 
  attack, 
  typeIcon,
  onUpdate,
  onRemove,
  canRemove,
  t,
}) => {
  const attackRef = useRef(attack);
  attackRef.current = attack;

  const handleChange = useCallback((field, value) => {
    onUpdate(index, { ...attackRef.current, [field]: value });
  }, [index, onUpdate]);

  const handleNumericChange = useCallback((field, value, min, max) => {
    const parsed = parseIntSafe(value, min);
    handleChange(field, clamp(parsed, min, max));
  }, [handleChange]);

  return (
    <div className="attack-editor">
      <div className="attack-header-edit">
        <h3 className="attack-title">
          {typeIcon} {t.sections.abilities} {index + 1}
        </h3>
        {canRemove && (
          <button 
            type="button" 
            className="remove-attack-btn"
            onClick={() => onRemove(index)}
            aria-label={t.buttons.remove}
          >
            âœ•
          </button>
        )}
      </div>
      <div className="attack-grid">
        <InputGroup
          id={`attack-${attack.id}-name`}
          label={t.labels.abilityName}
          value={attack.name}
          onChange={(v) => handleChange('name', v)}
          maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
        />
        <InputGroup
          id={`attack-${attack.id}-damage`}
          label={t.labels.damage}
          type="number"
          value={attack.damage}
          onChange={(v) => handleNumericChange('damage', v, CARD_LIMITS.DAMAGE_MIN, CARD_LIMITS.DAMAGE_MAX)}
        />
        <InputGroup
          id={`attack-${attack.id}-cost`}
          label={t.labels.energyCost}
          type="number"
          value={attack.cost}
          onChange={(v) => handleNumericChange('cost', v, CARD_LIMITS.COST_MIN, CARD_LIMITS.COST_MAX)}
          min={CARD_LIMITS.COST_MIN}
          max={CARD_LIMITS.COST_MAX}
        />
      </div>
      <InputGroup
        id={`attack-${attack.id}-desc`}
        label={t.labels.abilityDesc}
        value={attack.desc}
        onChange={(v) => handleChange('desc', v)}
        maxLength={CARD_LIMITS.ATTACK_DESC_MAX_LENGTH}
      />
    </div>
  );
});

AttackEditor.displayName = 'AttackEditor';

const RaritySelector = React.memo(({ value, onChange, t }) => (
  <fieldset className="input-group rarity-fieldset">
    <legend className="field-legend">{t.labels.rarity}</legend>
    <div className="rarity-selector" role="radiogroup" aria-label={t.labels.rarity}>
      {RARITIES.map(r => (
        <button 
          key={r.key}
          type="button"
          className={`rarity-btn ${value === r.key ? 'active' : ''}`}
          onClick={() => onChange(r.key)}
          role="radio"
          aria-checked={value === r.key}
          style={{ '--rarity-color': r.border }}
        >
          {t.rarities[r.key]}
        </button>
      ))}
    </div>
  </fieldset>
));

RaritySelector.displayName = 'RaritySelector';

const EffectSelector = React.memo(({ value, onChange, t }) => (
  <fieldset className="input-group effect-fieldset">
    <legend className="field-legend">{t.labels.effect}</legend>
    <div className="effect-selector">
      {CARD_EFFECTS.map(effect => (
        <button 
          key={effect}
          type="button"
          className={`effect-btn ${value === effect ? 'active' : ''}`}
          onClick={() => onChange(effect)}
          title={t.effects[effect]?.description || effect}
        >
          {effect === 'none' ? 'âŒ' : effect === 'holographic' ? 'ðŸŒˆ' : effect === 'rainbow' ? 'ðŸŽ¨' : effect === 'gold' ? 'ðŸ¥‡' : effect === 'silver' ? 'ðŸ¥ˆ' : effect === 'prismatic' ? 'ðŸ’Ž' : effect === 'neon' ? 'ðŸ’¡' : effect === 'galaxy' ? 'ðŸŒŒ' : effect === 'fire' ? 'ðŸ”¥' : effect === 'ice' ? 'â„ï¸' : 'âœ¨'} {t.effects[effect]?.name || effect}
        </button>
      ))}
    </div>
  </fieldset>
));

EffectSelector.displayName = 'EffectSelector';

// ============================================
// Ã‰DITEUR D'IMAGE
// ============================================
const ImageEditor = React.memo(({ 
  image, 
  settings, 
  onSettingsChange,
  isLoading, 
  error, 
  onUpload,
  onClear,
  t,
}) => {
  const fileInputRef = useRef(null);
  const containerRef = useRef(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isPanning, setIsPanning] = useState(false);
  const panStart = useRef({ x: 0, y: 0 });
  const offsetStart = useRef({ x: 0, y: 0 });

  const handleDragOver = useCallback((e) => {
    e.preventDefault();
    if (!isPanning) setIsDragging(true);
  }, [isPanning]);

  const handleDragLeave = useCallback((e) => {
    e.preventDefault();
    setIsDragging(false);
  }, []);

  const handleDrop = useCallback((e) => {
    e.preventDefault();
    setIsDragging(false);
    const file = e.dataTransfer.files[0];
    if (file) onUpload(file);
  }, [onUpload]);

  const handleClick = useCallback(() => {
    if (!image) fileInputRef.current?.click();
  }, [image]);

  const handleFileChange = useCallback((e) => {
    const file = e.target.files?.[0];
    if (file) onUpload(file);
    // Reset input pour permettre de re-sÃ©lectionner le mÃªme fichier
    e.target.value = '';
  }, [onUpload]);

  const handleZoomChange = useCallback((value) => {
    const zoom = parseFloatSafe(value, 1);
    const clampedZoom = clamp(zoom, CARD_LIMITS.ZOOM_MIN, CARD_LIMITS.ZOOM_MAX);
    onSettingsChange({ 
      ...settings, 
      zoom: clampedZoom,
      // RÃ©ajuster les offsets si le zoom diminue
      offsetX: clamp(settings.offsetX, -(clampedZoom - 1) * 50 - 30, (clampedZoom - 1) * 50 + 30),
      offsetY: clamp(settings.offsetY, -(clampedZoom - 1) * 50 - 30, (clampedZoom - 1) * 50 + 30),
    });
  }, [settings, onSettingsChange]);

  // Pan handlers
  const handlePanStart = useCallback((e) => {
    if (!image) return;
    e.preventDefault();
    setIsPanning(true);
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    panStart.current = { x: clientX, y: clientY };
    offsetStart.current = { x: settings.offsetX, y: settings.offsetY };
  }, [image, settings.offsetX, settings.offsetY]);

  const handlePanMove = useCallback((e) => {
    if (!isPanning) return;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const deltaX = clientX - panStart.current.x;
    const deltaY = clientY - panStart.current.y;
    
    // Limiter le dÃ©placement basÃ© sur le zoom
    const maxOffset = (settings.zoom - 1) * 50 + 30;
    const newOffsetX = clamp(offsetStart.current.x + deltaX, -maxOffset, maxOffset);
    const newOffsetY = clamp(offsetStart.current.y + deltaY, -maxOffset, maxOffset);
    
    onSettingsChange({ 
      zoom: settings.zoom,
      offsetX: newOffsetX, 
      offsetY: newOffsetY 
    });
  }, [isPanning, settings.zoom, onSettingsChange]);

  const handlePanEnd = useCallback(() => {
    setIsPanning(false);
  }, []);

  const handleReset = useCallback(() => {
    onSettingsChange(INITIAL_IMAGE_SETTINGS);
  }, [onSettingsChange]);

  return (
    <div className="image-editor">
      <div className="image-editor-header">
        <span className="section-title">ðŸ“· Image</span>
        {image && (
          <div className="image-actions">
            <button type="button" onClick={() => fileInputRef.current?.click()} className="small-btn">
              {t.buttons.change}
            </button>
            <button type="button" onClick={handleReset} className="small-btn">
              {t.buttons.recenter}
            </button>
            <button type="button" onClick={onClear} className="small-btn danger">
              {t.buttons.remove}
            </button>
          </div>
        )}
      </div>

      <div 
        ref={containerRef}
        className={`image-preview-container ${isDragging ? 'dragging' : ''} ${error ? 'error' : ''} ${image ? 'has-image' : ''}`}
        onClick={handleClick}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onMouseDown={image ? handlePanStart : undefined}
        onMouseMove={image ? handlePanMove : undefined}
        onMouseUp={handlePanEnd}
        onMouseLeave={handlePanEnd}
        onTouchStart={image ? handlePanStart : undefined}
        onTouchMove={image ? handlePanMove : undefined}
        onTouchEnd={handlePanEnd}
        role={image ? "application" : "button"}
        tabIndex={0}
        aria-label={t.imageEditor.dropHint}
      >
        <input 
          type="file" 
          ref={fileInputRef}
          onChange={handleFileChange}
          accept="image/png,image/jpeg,image/gif,image/webp"
          style={{ display: 'none' }}
          aria-hidden="true"
        />
        
        {image ? (
          <div 
            className="image-preview"
            style={{
              backgroundImage: `url(${image})`,
              backgroundSize: `${settings.zoom * 100}%`,
              backgroundPosition: `calc(50% + ${settings.offsetX}px) calc(50% + ${settings.offsetY}px)`,
            }}
          >
            {isPanning && <div className="pan-overlay">â†”</div>}
          </div>
        ) : (
          <div className="upload-placeholder">
            <div className="upload-icon">{isLoading ? 'â³' : 'ðŸ“·'}</div>
            <div className="upload-text">
              {isLoading ? t.imageEditor.loading : error ? error : t.imageEditor.dropHint}
            </div>
            <div className="upload-hint">{t.imageEditor.formats}</div>
          </div>
        )}
      </div>

      {image && (
        <div className="image-controls">
          <div className="zoom-control">
            <label htmlFor="zoom-slider">{t.labels.zoom}: {(settings.zoom * 100).toFixed(0)}%</label>
            <input 
              id="zoom-slider"
              type="range"
              min={CARD_LIMITS.ZOOM_MIN}
              max={CARD_LIMITS.ZOOM_MAX}
              step={0.05}
              value={settings.zoom}
              onChange={(e) => handleZoomChange(e.target.value)}
            />
          </div>
        </div>
      )}
    </div>
  );
});

ImageEditor.displayName = 'ImageEditor';

// ============================================
// EFFETS DE CARTE (animations + rÃ©activitÃ© souris)
// ============================================
const getEffectStyles = (effect, mousePos, isHovering) => {
  const x = mousePos.x * 100;
  const y = mousePos.y * 100;
  const angle = Math.atan2(mousePos.y - 0.5, mousePos.x - 0.5) * (180 / Math.PI) + 180;
  
  if (effect === 'none') {
    return { layer1: {}, layer2: {}, layer3: {}, glow: {}, cardClass: '' };
  }

  // IntensitÃ© augmentÃ©e
  const i = isHovering ? 1 : 0.5;

  switch (effect) {
    // HOLOGRAPHIQUE : Effet irisÃ© qui suit la souris - couleurs pastel arc-en-ciel douces
    case 'holographic':
      return {
        cardClass: 'effect-holographic',
        layer1: {},
        layer2: {
          background: `
            radial-gradient(ellipse 80% 80% at ${x}% ${y}%, 
              hsla(${angle}, 70%, 70%, ${0.5 * i}) 0%, 
              hsla(${angle + 60}, 70%, 65%, ${0.4 * i}) 25%,
              hsla(${angle + 120}, 70%, 65%, ${0.35 * i}) 50%,
              transparent 75%)
          `,
          mixBlendMode: 'color',
        },
        layer3: {
          background: `
            radial-gradient(circle at ${x}% ${y}%, rgba(255,255,255,${0.25 * i}) 0%, transparent 30%),
            radial-gradient(circle at ${100-x}% ${100-y}%, hsla(${angle + 180}, 60%, 75%, ${0.3 * i}) 0%, transparent 40%)
          `,
          mixBlendMode: 'overlay',
        },
        glow: { 
          boxShadow: `0 0 ${20 * i}px hsla(${angle}, 80%, 70%, ${0.4 * i}), 0 0 ${40 * i}px hsla(${angle + 120}, 80%, 70%, ${0.3 * i})` 
        },
      };

    // RAINBOW : Bandes arc-en-ciel horizontales qui dÃ©filent
    case 'rainbow':
      const rainbowOffset = mousePos.x * 100;
      return {
        cardClass: 'effect-rainbow',
        layer1: {},
        layer2: {
          background: `
            repeating-linear-gradient(
              ${90 + (mousePos.y - 0.5) * 30}deg,
              rgba(255,0,0,${0.4 * i}) 0%,
              rgba(255,127,0,${0.4 * i}) 8%,
              rgba(255,255,0,${0.4 * i}) 16%,
              rgba(0,255,0,${0.4 * i}) 24%,
              rgba(0,127,255,${0.4 * i}) 32%,
              rgba(127,0,255,${0.4 * i}) 40%,
              rgba(255,0,127,${0.4 * i}) 48%,
              rgba(255,0,0,${0.4 * i}) 56%
            )
          `,
          backgroundSize: '200% 200%',
          backgroundPosition: `${rainbowOffset}% 0%`,
          mixBlendMode: 'color',
        },
        layer3: {},
        glow: { 
          boxShadow: `0 0 ${25 * i}px rgba(255,0,0,${0.3 * i}), 0 0 ${40 * i}px rgba(0,255,0,${0.25 * i}), 0 0 ${55 * i}px rgba(0,0,255,${0.2 * i})` 
        },
      };

    // PRISMATIC : Faisceaux de lumiÃ¨re qui se croisent comme un prisme
    case 'prismatic': {
      const beam1 = angle;
      const beam2 = angle + 60;
      const beam3 = angle + 120;
      return {
        cardClass: 'effect-prismatic',
        layer1: {},
        layer2: {
          background: `
            linear-gradient(${beam1}deg, transparent 20%, rgba(255,0,0,${0.35 * i}) 35%, rgba(255,255,0,${0.4 * i}) 50%, rgba(0,255,0,${0.35 * i}) 65%, transparent 80%),
            linear-gradient(${beam2}deg, transparent 25%, rgba(0,255,255,${0.3 * i}) 40%, rgba(0,100,255,${0.35 * i}) 50%, rgba(100,0,255,${0.3 * i}) 60%, transparent 75%),
            linear-gradient(${beam3}deg, transparent 30%, rgba(255,0,255,${0.25 * i}) 45%, rgba(255,100,100,${0.3 * i}) 55%, transparent 70%)
          `,
          mixBlendMode: 'screen',
        },
        layer3: {
          background: `radial-gradient(circle at ${x}% ${y}%, rgba(255,255,255,${0.3 * i}) 0%, transparent 25%)`,
          mixBlendMode: 'overlay',
        },
        glow: { 
          boxShadow: `0 0 ${30 * i}px rgba(255,0,255,${0.4 * i}), 0 0 ${50 * i}px rgba(0,255,255,${0.35 * i}), 0 0 ${70 * i}px rgba(255,255,0,${0.3 * i})` 
        },
      };
    }

    // GOLD : Effet dorÃ© mÃ©tallique intense
    case 'gold':
      return {
        cardClass: 'effect-gold',
        layer1: {},
        layer2: {
          background: `
            radial-gradient(ellipse 120% 80% at ${x}% ${y}%, rgba(255,215,0,${0.6 * i}) 0%, rgba(255,180,0,${0.4 * i}) 30%, transparent 60%),
            linear-gradient(${angle}deg, transparent 30%, rgba(255,240,150,${0.5 * i}) 50%, transparent 70%),
            radial-gradient(ellipse at 50% 100%, rgba(180,130,0,${0.4 * i}) 0%, transparent 50%)
          `,
          mixBlendMode: 'hard-light',
        },
        layer3: {
          background: `
            radial-gradient(circle at ${15 + mousePos.x * 25}% ${10 + mousePos.y * 15}%, rgba(255,255,200,${0.9 * i}) 0%, transparent 8%),
            radial-gradient(circle at ${75 - mousePos.x * 20}% ${55 + mousePos.y * 20}%, rgba(255,250,180,${0.8 * i}) 0%, transparent 6%),
            radial-gradient(circle at ${45 + mousePos.x * 30}% ${85 - mousePos.y * 25}%, rgba(255,255,220,${0.85 * i}) 0%, transparent 7%),
            radial-gradient(circle at ${85 - mousePos.x * 15}% ${25 + mousePos.y * 10}%, rgba(255,240,150,${0.75 * i}) 0%, transparent 5%)
          `,
          mixBlendMode: 'overlay',
        },
        glow: { 
          boxShadow: `0 0 ${30 * i}px rgba(255,200,0,${0.6 * i}), 0 0 ${60 * i}px rgba(255,150,0,${0.4 * i}), inset 0 0 ${30 * i}px rgba(255,200,50,${0.15 * i})` 
        },
      };

    // SILVER : Effet argentÃ©/chrome mÃ©tallique
    case 'silver':
      return {
        cardClass: 'effect-silver',
        layer1: {},
        layer2: {
          background: `
            radial-gradient(ellipse 120% 80% at ${x}% ${y}%, rgba(220,230,255,${0.7 * i}) 0%, rgba(180,190,210,${0.5 * i}) 30%, transparent 60%),
            linear-gradient(${angle}deg, transparent 30%, rgba(255,255,255,${0.6 * i}) 50%, transparent 70%),
            radial-gradient(ellipse at 50% 100%, rgba(140,150,170,${0.45 * i}) 0%, transparent 50%)
          `,
          mixBlendMode: 'hard-light',
        },
        layer3: {
          background: `
            radial-gradient(circle at ${10 + mousePos.x * 30}% ${15 + mousePos.y * 15}%, rgba(255,255,255,${0.95 * i}) 0%, transparent 7%),
            radial-gradient(circle at ${80 - mousePos.x * 25}% ${50 + mousePos.y * 25}%, rgba(230,235,255,${0.85 * i}) 0%, transparent 5%),
            radial-gradient(circle at ${40 + mousePos.x * 20}% ${80 - mousePos.y * 20}%, rgba(255,255,255,${0.9 * i}) 0%, transparent 6%),
            radial-gradient(circle at ${70 - mousePos.x * 15}% ${20 + mousePos.y * 10}%, rgba(220,230,250,${0.8 * i}) 0%, transparent 4%)
          `,
          mixBlendMode: 'overlay',
        },
        glow: { 
          boxShadow: `0 0 ${25 * i}px rgba(200,210,255,${0.5 * i}), 0 0 ${50 * i}px rgba(180,190,230,${0.35 * i}), inset 0 0 ${25 * i}px rgba(220,230,255,${0.12 * i})` 
        },
      };

    // NEON : Lueurs vibrantes qui pulsent
    case 'neon': {
      const hue = (mousePos.x * 360 + mousePos.y * 60) % 360;
      const hue2 = (hue + 120) % 360;
      const hue3 = (hue + 240) % 360;
      return {
        cardClass: 'effect-neon',
        layer1: {},
        layer2: {
          background: `
            radial-gradient(ellipse 100% 60% at ${x}% ${y}%, hsla(${hue}, 100%, 55%, ${0.7 * i}) 0%, hsla(${hue}, 100%, 50%, ${0.3 * i}) 40%, transparent 70%),
            radial-gradient(ellipse 80% 50% at ${100-x}% ${100-y}%, hsla(${hue2}, 100%, 55%, ${0.5 * i}) 0%, transparent 50%)
          `,
          mixBlendMode: 'screen',
        },
        layer3: {
          background: `
            radial-gradient(circle at ${20 + mousePos.x * 25}% ${20 + mousePos.y * 25}%, hsla(${hue}, 100%, 70%, ${0.8 * i}) 0%, transparent 20%),
            radial-gradient(circle at ${80 - mousePos.x * 25}% ${80 - mousePos.y * 25}%, hsla(${hue2}, 100%, 70%, ${0.7 * i}) 0%, transparent 18%),
            radial-gradient(circle at ${50}% ${50}%, hsla(${hue3}, 100%, 65%, ${0.4 * i}) 0%, transparent 30%)
          `,
          mixBlendMode: 'screen',
        },
        glow: { 
          boxShadow: `0 0 ${35 * i}px hsla(${hue}, 100%, 50%, ${0.7 * i}), 0 0 ${70 * i}px hsla(${hue2}, 100%, 50%, ${0.5 * i}), 0 0 ${100 * i}px hsla(${hue3}, 100%, 50%, ${0.3 * i}), inset 0 0 ${40 * i}px hsla(${hue}, 100%, 60%, ${0.15 * i})` 
        },
      };
    }

    // GALAXY : NÃ©buleuses profondes avec Ã©toiles scintillantes
    case 'galaxy': {
      const starX = (n) => (17 * n + mousePos.x * 35) % 100;
      const starY = (n) => (23 * n + mousePos.y * 30) % 100;
      return {
        cardClass: 'effect-galaxy',
        layer1: {},
        layer2: {
          background: `
            radial-gradient(ellipse 70% 50% at ${25 + mousePos.x * 50}% ${15 + mousePos.y * 35}%, rgba(120,40,200,${0.7 * i}) 0%, rgba(80,20,160,${0.4 * i}) 40%, transparent 70%),
            radial-gradient(ellipse 60% 45% at ${75 - mousePos.x * 40}% ${85 - mousePos.y * 35}%, rgba(60,30,180,${0.6 * i}) 0%, rgba(40,15,120,${0.35 * i}) 45%, transparent 70%),
            radial-gradient(ellipse 50% 40% at ${x}% ${y}%, rgba(180,80,255,${0.5 * i}) 0%, transparent 50%),
            linear-gradient(180deg, rgba(20,10,60,${0.3 * i}) 0%, transparent 30%, transparent 70%, rgba(30,15,80,${0.25 * i}) 100%)
          `,
          mixBlendMode: 'screen',
        },
        layer3: {
          background: `
            radial-gradient(circle at ${starX(1)}% ${starY(1)}%, rgba(255,255,255,${1 * i}) 0%, rgba(200,180,255,${0.5 * i}) 2%, transparent 4%),
            radial-gradient(circle at ${starX(2)}% ${starY(2)}%, rgba(255,220,255,${0.95 * i}) 0%, transparent 3%),
            radial-gradient(circle at ${starX(3)}% ${starY(3)}%, rgba(200,200,255,${0.9 * i}) 0%, transparent 3.5%),
            radial-gradient(circle at ${starX(4)}% ${starY(4)}%, rgba(255,255,200,${0.85 * i}) 0%, transparent 2.5%),
            radial-gradient(circle at ${starX(5)}% ${starY(5)}%, rgba(255,180,255,${0.9 * i}) 0%, transparent 3%),
            radial-gradient(circle at ${starX(6)}% ${starY(6)}%, rgba(180,180,255,${0.85 * i}) 0%, transparent 2%),
            radial-gradient(circle at ${starX(7)}% ${starY(7)}%, rgba(255,255,255,${0.95 * i}) 0%, transparent 4%),
            radial-gradient(circle at ${starX(8)}% ${starY(8)}%, rgba(255,200,200,${0.8 * i}) 0%, transparent 2.5%),
            radial-gradient(circle at ${starX(9)}% ${starY(9)}%, rgba(200,255,255,${0.85 * i}) 0%, transparent 2%),
            radial-gradient(circle at ${starX(10)}% ${starY(10)}%, rgba(255,255,180,${0.9 * i}) 0%, transparent 3%)
          `,
          mixBlendMode: 'screen',
        },
        glow: { 
          boxShadow: `0 0 ${40 * i}px rgba(140,60,255,${0.5 * i}), 0 0 ${80 * i}px rgba(100,30,200,${0.4 * i}), 0 0 ${120 * i}px rgba(60,20,150,${0.3 * i})` 
        },
      };
    }

    // FIRE : Flammes ardentes dynamiques
    case 'fire': {
      const flameY = 100 - (mousePos.y * 25);
      const flicker = Math.sin(Date.now() / 100) * 5;
      return {
        cardClass: 'effect-fire',
        layer1: {},
        layer2: {
          background: `
            radial-gradient(ellipse 90% 60% at ${x}% ${flameY}%, rgba(255,255,100,${0.8 * i}) 0%, rgba(255,200,0,${0.6 * i}) 20%, rgba(255,100,0,${0.5 * i}) 40%, rgba(255,50,0,${0.3 * i}) 60%, transparent 80%),
            radial-gradient(ellipse 70% 50% at ${50 + (mousePos.x - 0.5) * 25}% 90%, rgba(255,150,0,${0.7 * i}) 0%, rgba(255,80,0,${0.5 * i}) 40%, transparent 70%),
            linear-gradient(0deg, rgba(255,100,0,${0.5 * i}) 0%, rgba(255,50,0,${0.3 * i}) 20%, transparent 50%)
          `,
          mixBlendMode: 'screen',
        },
        layer3: {
          background: `
            radial-gradient(circle at ${30 + mousePos.x * 20}% ${65 - mousePos.y * 15}%, rgba(255,255,150,${1 * i}) 0%, rgba(255,200,50,${0.5 * i}) 5%, transparent 10%),
            radial-gradient(circle at ${70 - mousePos.x * 15}% ${60 + mousePos.y * 10}%, rgba(255,220,80,${0.9 * i}) 0%, transparent 8%),
            radial-gradient(circle at ${50 + mousePos.x * 25}% ${70 - mousePos.y * 20}%, rgba(255,180,0,${0.85 * i}) 0%, transparent 9%),
            radial-gradient(circle at ${40 - mousePos.x * 20}% ${75 + mousePos.y * 10}%, rgba(255,150,50,${0.8 * i}) 0%, transparent 7%),
            radial-gradient(circle at ${60 + mousePos.x * 15}% ${55 - mousePos.y * 15}%, rgba(255,200,100,${0.85 * i}) 0%, transparent 8%)
          `,
          mixBlendMode: 'screen',
        },
        glow: { 
          boxShadow: `0 0 ${40 * i}px rgba(255,150,0,${0.7 * i}), 0 0 ${80 * i}px rgba(255,100,0,${0.5 * i}), 0 0 ${120 * i}px rgba(255,50,0,${0.35 * i}), 0 ${20 * i}px ${50 * i}px rgba(255,100,0,${0.4 * i})` 
        },
      };
    }

    // ICE : Cristaux de glace et givre
    case 'ice': {
      const crystalX = (n) => (19 * n + mousePos.x * 30) % 100;
      const crystalY = (n) => (29 * n + mousePos.y * 25) % 100;
      return {
        cardClass: 'effect-ice',
        layer1: {},
        layer2: {
          background: `
            radial-gradient(ellipse 100% 70% at ${x}% ${y}%, rgba(180,230,255,${0.5 * i}) 0%, rgba(140,200,255,${0.35 * i}) 30%, transparent 60%),
            linear-gradient(${angle}deg, transparent 20%, rgba(200,240,255,${0.4 * i}) 45%, rgba(230,250,255,${0.5 * i}) 50%, rgba(200,240,255,${0.4 * i}) 55%, transparent 80%),
            linear-gradient(${angle + 60}deg, transparent 30%, rgba(180,230,255,${0.3 * i}) 50%, transparent 70%),
            linear-gradient(${angle + 120}deg, transparent 35%, rgba(160,220,255,${0.25 * i}) 50%, transparent 65%)
          `,
          mixBlendMode: 'hard-light',
        },
        layer3: {
          background: `
            radial-gradient(circle at ${crystalX(1)}% ${crystalY(1)}%, rgba(255,255,255,${1 * i}) 0%, rgba(200,240,255,${0.6 * i}) 3%, transparent 6%),
            radial-gradient(circle at ${crystalX(2)}% ${crystalY(2)}%, rgba(230,250,255,${0.95 * i}) 0%, transparent 5%),
            radial-gradient(circle at ${crystalX(3)}% ${crystalY(3)}%, rgba(255,255,255,${0.9 * i}) 0%, transparent 4%),
            radial-gradient(circle at ${crystalX(4)}% ${crystalY(4)}%, rgba(200,240,255,${0.85 * i}) 0%, transparent 5.5%),
            radial-gradient(circle at ${crystalX(5)}% ${crystalY(5)}%, rgba(255,255,255,${0.95 * i}) 0%, transparent 3.5%),
            radial-gradient(circle at ${crystalX(6)}% ${crystalY(6)}%, rgba(220,250,255,${0.9 * i}) 0%, transparent 4.5%),
            radial-gradient(circle at ${crystalX(7)}% ${crystalY(7)}%, rgba(255,255,255,${0.85 * i}) 0%, transparent 3%),
            radial-gradient(circle at ${crystalX(8)}% ${crystalY(8)}%, rgba(180,230,255,${0.8 * i}) 0%, transparent 5%)
          `,
          mixBlendMode: 'overlay',
        },
        glow: { 
          boxShadow: `0 0 ${35 * i}px rgba(150,220,255,${0.55 * i}), 0 0 ${70 * i}px rgba(100,200,255,${0.4 * i}), 0 0 ${100 * i}px rgba(180,240,255,${0.3 * i}), inset 0 0 ${30 * i}px rgba(200,240,255,${0.1 * i})` 
        },
      };
    }

    default:
      return { layer1: {}, layer2: {}, layer3: {}, glow: {}, cardClass: '' };
  }
};

// ============================================
// COMPOSANT CARTE
// ============================================
const Card = React.memo(({ 
  cardData, 
  attacks, 
  image,
  imageSettings,
  mousePos, 
  isHovering, 
  cardRef,
  onMouseMove,
  onMouseEnter,
  onMouseLeave,
  autoRotate,
  t
}) => {
  const typeData = ELEMENT_TYPES[cardData.type] || ELEMENT_TYPES.Neutral;
  const weaknessData = ELEMENT_TYPES[cardData.weakness] || ELEMENT_TYPES.Neutral;
  const resistanceData = ELEMENT_TYPES[cardData.resistance] || ELEMENT_TYPES.Neutral;
  const rarityData = RARITIES.find(r => r.key === cardData.rarity) || RARITIES[0];
  const fontData = FONTS.find(f => f.id === cardData.font) || FONTS[0];

  // Couleurs (personnalisÃ©es ou par dÃ©faut)
  const borderColor = cardData.borderColor || rarityData.border;
  const backgroundColor = cardData.backgroundColor || '';
  const textColor = cardData.textColor || '#1a1a2e';

  const cardStyle = useMemo(() => ({
    transform: isHovering 
      ? `perspective(1000px) rotateY(${(mousePos.x - 0.5) * 15}deg) rotateX(${(0.5 - mousePos.y) * 15}deg) scale(1.02)`
      : 'perspective(1000px) rotateY(0deg) rotateX(0deg) scale(1)',
    transition: autoRotate ? 'none' : 'transform 0.12s ease-out',
  }), [isHovering, mousePos.x, mousePos.y, autoRotate]);

  const effectStyles = useMemo(() => 
    getEffectStyles(cardData.effect, mousePos, isHovering),
    [cardData.effect, mousePos, isHovering]
  );

  const imageStyle = useMemo(() => {
    const baseStyle = {
      borderColor: typeData.primary,
    };
    
    if (image) {
      return {
        ...baseStyle,
        backgroundImage: `url(${image})`,
        backgroundSize: `${imageSettings.zoom * 100}%`,
        backgroundPosition: `calc(50% + ${imageSettings.offsetX}px) calc(50% + ${imageSettings.offsetY}px)`,
        backgroundRepeat: 'no-repeat',
      };
    }
    
    return {
      ...baseStyle,
      background: `linear-gradient(135deg, ${typeData.primary}40, ${typeData.secondary}40)`,
    };
  }, [image, imageSettings, typeData.primary, typeData.secondary]);

  const cardGradient = useMemo(() => {
    if (backgroundColor) {
      return backgroundColor;
    }
    return `linear-gradient(135deg, ${typeData.primary} 0%, ${typeData.secondary} 50%, ${typeData.primary} 100%)`;
  }, [backgroundColor, typeData.primary, typeData.secondary]);

  return (
    <div 
      ref={cardRef}
      className="card-container"
      style={cardStyle}
      onMouseMove={onMouseMove}
      onMouseEnter={onMouseEnter}
      onMouseLeave={onMouseLeave}
    >
      <div 
        className={`game-card ${effectStyles.cardClass || ''}`}
        style={{
          background: cardGradient,
          borderColor: borderColor,
          fontFamily: fontData.family,
          ...effectStyles.glow,
        }}
      >
        {/* Inner card frame */}
        <div className="card-inner" style={{ color: textColor }}>
          {/* Header */}
          <div className="card-header">
            <div className="card-header-left">
              <span className="stage-badge" style={{ background: typeData.primary }}>
                {t.stages[STAGES.indexOf(cardData.stage)] || cardData.stage}
              </span>
              <span className="creature-name">{cardData.name}</span>
            </div>
            {cardData.showHP && (
              <div className="card-header-right">
                <span className="hp-value">{t.card.hp} {cardData.hp}</span>
                <span className="type-icon">{typeData.icon}</span>
              </div>
            )}
          </div>

          {/* Image */}
          <div className="card-image" style={imageStyle}>
            {!image && (
              <span className="placeholder-icon">{typeData.icon}</span>
            )}
          </div>

          {/* Description bar */}
          {cardData.showDescription && cardData.description && (
            <div className="card-description">{cardData.description}</div>
          )}

          {/* Attacks */}
          <div className="attacks-container">
            {attacks.map((attack) => (
              <div key={attack.id} className="attack-card">
                <div className="attack-header">
                  <div className="attack-cost">
                    {[...Array(Math.max(0, Math.min(10, attack.cost)))].map((_, i) => (
                      <span key={i} className="energy-icon">{typeData.icon}</span>
                    ))}
                  </div>
                  <span className="attack-name">{attack.name}</span>
                  <span className="attack-damage">{attack.damage}</span>
                </div>
                {attack.desc && <div className="attack-desc">{attack.desc}</div>}
              </div>
            ))}
          </div>

          {/* Footer */}
          <div className="card-footer">
            {cardData.showWeakRes && (
              <div className="footer-stats">
                <div className="stat">
                  <span className="stat-label">{t.card.weakness} </span>
                  <span className="stat-icon">{weaknessData.icon}</span>
                  <span className="stat-value weakness"> Ã—2</span>
                </div>
                <div className="stat">
                  <span className="stat-label">{t.card.resistance} </span>
                  <span className="stat-icon">{resistanceData.icon}</span>
                  <span className="stat-value resistance"> -30</span>
                </div>
              </div>
            )}
            {cardData.showRetreat && (
              <div className="retreat-cost">
                <span className="stat-label">{t.card.cost} </span>
                {[...Array(Math.max(0, cardData.retreatCost))].map((_, i) => (
                  <span key={i} className="retreat-icon">âšª</span>
                ))}
              </div>
            )}
          </div>

          {/* Author */}
          <div className="card-author">
            {t.card.illus} {cardData.author} â€¢ Card Creator
          </div>
        </div>

        {/* Element texture layer */}
        {cardData.showTexture && (
          <div 
            className="texture-layer" 
            style={{ 
              backgroundImage: ELEMENT_TEXTURES[cardData.type],
              backgroundSize: '60px 60px',
            }} 
          />
        )}

        {/* Effect layers */}
        <div className="effect-layer layer-1" style={effectStyles.layer1} />
        <div className="effect-layer layer-2" style={effectStyles.layer2} />
        <div className="effect-layer layer-3" style={effectStyles.layer3} />
        
        {/* Particles layer */}
        {cardData.showParticles && (
          <div className={`particles-layer particles-${cardData.type.toLowerCase()}`}>
            {[...Array(ELEMENT_PARTICLES[cardData.type]?.count || 5)].map((_, i) => (
              <span 
                key={i} 
                className={`particle particle-${i % 3}`}
                style={{
                  left: `${10 + (i * 13) % 80}%`,
                  animationDelay: `${i * 0.4}s`,
                  animationDuration: `${2 + (i % 3)}s`,
                }}
              >
                {i % 2 === 0 
                  ? ELEMENT_PARTICLES[cardData.type]?.emoji 
                  : ELEMENT_PARTICLES[cardData.type]?.alt[i % 2]}
              </span>
            ))}
          </div>
        )}
        
        {/* Rarity indicator */}
        {(cardData.rarity === 'legendary' || cardData.rarity === 'mythic') && (
          <div className={`rarity-indicator ${cardData.rarity}`}>
            {cardData.rarity === 'mythic' ? 'ðŸŒŸ' : 'â­'}
          </div>
        )}
        {cardData.rarity === 'epic' && (
          <div className="rarity-indicator epic">ðŸ’œ</div>
        )}
      </div>
    </div>
  );
});

Card.displayName = 'Card';

// ============================================
// SECTION PLIABLE
// ============================================
const CollapsibleSection = React.memo(({ title, icon, children, defaultOpen = true }) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className={`collapsible-section ${isOpen ? 'open' : ''}`}>
      <button 
        type="button"
        className="collapsible-header"
        onClick={() => setIsOpen(!isOpen)}
        aria-expanded={isOpen}
      >
        <span>{icon} {title}</span>
        <span className="collapse-icon">{isOpen ? 'â–¼' : 'â–¶'}</span>
      </button>
      {isOpen && <div className="collapsible-content">{children}</div>}
    </div>
  );
});

CollapsibleSection.displayName = 'CollapsibleSection';

// ============================================
// STYLES CSS
// ============================================
const STYLES = `
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&family=Bangers&family=Roboto:wght@400;500;700&family=Poppins:wght@400;500;600;700&family=Oswald:wght@400;500;600;700&family=Playfair+Display:wght@400;500;600;700&display=swap');
  
  * { box-sizing: border-box; }
  
  /* Language Dropdown */
  .language-dropdown {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 1000;
  }
  
  .lang-select {
    background: linear-gradient(135deg, #2a2a4a 0%, #1a1a2e 100%);
    color: #fff;
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 8px;
    padding: 10px 35px 10px 15px;
    font-size: 15px;
    font-family: 'Nunito', sans-serif;
    font-weight: 600;
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23ffd700' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 12px center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    transition: all 0.2s ease;
    min-width: 160px;
  }
  
  .lang-select:hover {
    border-color: rgba(255, 215, 0, 0.6);
    box-shadow: 0 4px 20px rgba(255, 215, 0, 0.2);
  }
  
  .lang-select:focus {
    outline: none;
    border-color: #ffd700;
    box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
  }
  
  .lang-select option {
    background: #1a1a2e;
    color: #fff;
    padding: 10px;
  }

  .app-container {
    min-height: 100vh;
    background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #0f0f1a 100%);
    font-family: 'Nunito', 'Segoe UI', sans-serif;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  .title {
    font-family: 'Bangers', cursive;
    font-size: 48px;
    background: linear-gradient(90deg, #ffd700, #fff, #ffd700, #ff6b6b, #ffd700);
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: shimmer 3s linear infinite;
    letter-spacing: 3px;
    margin-bottom: 10px;
    text-align: center;
  }
  
  .subtitle {
    color: #666;
    font-size: 14px;
    margin-bottom: 30px;
    text-align: center;
  }
  
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }
  
  .main-layout {
    display: flex;
    gap: 40px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: flex-start;
    max-width: 1400px;
    width: 100%;
  }
  
  /* Card Styles */
  .card-preview {
    position: sticky;
    top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  .card-container {
    position: relative;
    cursor: pointer;
    transform-style: preserve-3d;
  }
  
  .card-container:hover {
    z-index: 10;
  }
  
  .game-card {
    width: 320px;
    height: 448px;
    border-radius: 16px;
    position: relative;
    overflow: hidden;
    border: 5px solid;
    box-shadow: 
      0 0 20px rgba(0,0,0,0.5),
      0 10px 40px rgba(0,0,0,0.4),
      inset 0 0 60px rgba(255,255,255,0.05);
    transition: box-shadow 0.3s ease, transform 0.1s ease;
  }
  
  .game-card:hover {
    box-shadow: 
      0 0 30px rgba(0,0,0,0.4),
      0 15px 50px rgba(0,0,0,0.35),
      inset 0 0 80px rgba(255,255,255,0.08);
  }
  
  .card-inner {
    position: absolute;
    inset: 8px;
    background: linear-gradient(180deg, rgba(255,255,255,0.95) 0%, rgba(245,245,250,0.95) 100%);
    border-radius: 10px;
    padding: 10px;
    display: flex;
    flex-direction: column;
  }
  
  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    min-height: 28px;
  }
  
  .card-header-left {
    display: flex;
    align-items: center;
    gap: 6px;
    flex: 1;
    min-width: 0;
  }
  
  .card-header-right {
    display: flex;
    align-items: center;
    gap: 4px;
    flex-shrink: 0;
  }
  
  .stage-badge {
    font-size: 9px;
    color: #fff;
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: 700;
    flex-shrink: 0;
  }
  
  .creature-name {
    font-size: 16px;
    font-weight: 900;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  .hp-value {
    font-size: 18px;
    font-weight: 900;
    color: #e53935;
  }
  
  .type-icon {
    font-size: 18px;
  }
  
  .card-image {
    flex: 0 0 150px;
    border-radius: 8px;
    border: 3px solid;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 6px;
    position: relative;
    overflow: hidden;
    background-color: #f5f5f5;
  }
  
  .placeholder-icon {
    font-size: 50px;
    opacity: 0.4;
  }
  
  .card-description {
    font-size: 8px;
    color: #555;
    text-align: center;
    padding: 3px 8px;
    background: rgba(0,0,0,0.04);
    border-radius: 4px;
    margin-bottom: 6px;
    font-style: italic;
    line-height: 1.3;
  }
  
  .attacks-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 5px;
    overflow: hidden;
  }
  
  .attack-card {
    background: rgba(255,255,255,0.7);
    border-radius: 6px;
    padding: 6px 8px;
    border: 1px solid rgba(0,0,0,0.08);
  }
  
  .attack-header {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  
  .attack-cost {
    display: flex;
    gap: 1px;
    flex-shrink: 0;
  }
  
  .energy-icon {
    font-size: 11px;
  }
  
  .attack-name {
    font-weight: 700;
    font-size: 12px;
    flex: 1;
    margin-left: 4px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  .attack-damage {
    font-weight: 900;
    font-size: 14px;
    flex-shrink: 0;
  }
  
  .attack-desc {
    font-size: 8px;
    color: #666;
    margin-top: 2px;
    line-height: 1.2;
  }
  
  .card-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 6px;
    padding-top: 5px;
    border-top: 1px solid rgba(0,0,0,0.08);
    font-size: 8px;
    min-height: 20px;
  }
  
  .footer-stats {
    display: flex;
    gap: 10px;
  }
  
  .stat {
    display: flex;
    align-items: center;
  }
  
  .stat-label {
    color: #888;
  }
  
  .stat-icon {
    font-size: 12px;
  }
  
  .stat-value.weakness {
    color: #e53935;
    font-weight: 700;
  }
  
  .stat-value.resistance {
    color: #43a047;
    font-weight: 700;
  }
  
  .retreat-icon {
    font-size: 9px;
  }
  
  .card-author {
    text-align: center;
    font-size: 6px;
    color: #999;
    margin-top: 3px;
  }
  
  .effect-layer {
    position: absolute;
    inset: 0;
    pointer-events: none;
    border-radius: 12px;
    transition: all 0.15s ease-out, opacity 0.2s ease;
  }
  
  .effect-layer.layer-1 {
    z-index: 10;
    transition: all 0.2s ease-out;
  }
  
  .effect-layer.layer-2 {
    z-index: 11;
    transition: all 0.08s ease-out;
  }
  
  .effect-layer.layer-3 {
    z-index: 12;
    transition: all 0.08s ease-out;
  }
  
  /* ========== TEXTURE LAYER ========== */
  .texture-layer {
    position: absolute;
    inset: 0;
    pointer-events: none;
    border-radius: 12px;
    opacity: 0.5;
    z-index: 8;
    mix-blend-mode: soft-light;
  }
  
  .game-card:hover .texture-layer {
    opacity: 0.7;
  }
  
  /* ========== PARTICLES LAYER ========== */
  .particles-layer {
    position: absolute;
    inset: 0;
    pointer-events: none;
    border-radius: 12px;
    overflow: hidden;
    z-index: 15;
  }
  
  .particle {
    position: absolute;
    font-size: 12px;
    opacity: 0;
    animation: particleFloat 3s ease-in-out infinite;
    filter: drop-shadow(0 0 3px currentColor);
  }
  
  .particle-0 { font-size: 10px; }
  .particle-1 { font-size: 14px; }
  .particle-2 { font-size: 8px; }
  
  /* Fire particles - rise up */
  .particles-fire .particle {
    bottom: -20px;
    animation-name: particleRise;
    color: #ff6b35;
    filter: drop-shadow(0 0 4px #ff4500);
  }
  
  @keyframes particleRise {
    0% { transform: translateY(0) scale(1); opacity: 0; }
    10% { opacity: 0.9; }
    90% { opacity: 0.7; }
    100% { transform: translateY(-400px) scale(0.5); opacity: 0; }
  }
  
  /* Water particles - bubbles */
  .particles-water .particle {
    bottom: -20px;
    animation-name: particleBubble;
    color: #00bcd4;
    filter: drop-shadow(0 0 3px #2196f3);
  }
  
  @keyframes particleBubble {
    0% { transform: translateY(0) translateX(0) scale(0.5); opacity: 0; }
    10% { opacity: 0.8; }
    50% { transform: translateY(-200px) translateX(15px) scale(1); }
    100% { transform: translateY(-400px) translateX(-10px) scale(0.8); opacity: 0; }
  }
  
  /* Ice particles - snowfall */
  .particles-ice .particle {
    top: -20px;
    animation-name: particleSnow;
    color: #81d4fa;
    filter: drop-shadow(0 0 3px #e3f2fd);
  }
  
  @keyframes particleSnow {
    0% { transform: translateY(0) translateX(0) rotate(0deg); opacity: 0; }
    10% { opacity: 0.9; }
    100% { transform: translateY(450px) translateX(30px) rotate(360deg); opacity: 0; }
  }
  
  /* Nature particles - floating leaves */
  .particles-nature .particle {
    top: 50%;
    animation-name: particleLeaf;
    color: #4caf50;
    filter: drop-shadow(0 0 2px #8bc34a);
  }
  
  @keyframes particleLeaf {
    0% { transform: translateY(0) translateX(-50px) rotate(0deg); opacity: 0; }
    20% { opacity: 0.8; }
    80% { opacity: 0.6; }
    100% { transform: translateY(100px) translateX(50px) rotate(180deg); opacity: 0; }
  }
  
  /* Electric particles - sparks */
  .particles-electric .particle {
    top: 50%;
    animation-name: particleSpark;
    color: #ffeb3b;
    filter: drop-shadow(0 0 5px #ffc107);
  }
  
  @keyframes particleSpark {
    0%, 100% { transform: scale(0); opacity: 0; }
    5% { transform: scale(1.5); opacity: 1; }
    10% { transform: scale(0.8); opacity: 0.8; }
    15% { transform: scale(1.2); opacity: 0; }
  }
  
  /* Mystic particles - magical float */
  .particles-mystic .particle {
    top: 50%;
    animation-name: particleMagic;
    color: #9c27b0;
    filter: drop-shadow(0 0 4px #e91e63);
  }
  
  @keyframes particleMagic {
    0% { transform: translateY(0) scale(0); opacity: 0; }
    20% { transform: translateY(-20px) scale(1); opacity: 0.9; }
    80% { transform: translateY(-60px) scale(0.8); opacity: 0.7; }
    100% { transform: translateY(-100px) scale(0); opacity: 0; }
  }
  
  /* Shadow particles - fade */
  .particles-shadow .particle {
    top: 20%;
    animation-name: particleShadow;
    color: #424242;
    filter: drop-shadow(0 0 3px #000);
  }
  
  @keyframes particleShadow {
    0% { transform: scale(1) translateY(0); opacity: 0; }
    30% { opacity: 0.6; }
    100% { transform: scale(2) translateY(50px); opacity: 0; }
  }
  
  /* Fighting particles - impact */
  .particles-fighting .particle {
    top: 50%;
    animation-name: particleImpact;
    color: #f44336;
    filter: drop-shadow(0 0 3px #ff5722);
  }
  
  @keyframes particleImpact {
    0%, 100% { transform: scale(0) rotate(0deg); opacity: 0; }
    10% { transform: scale(1.5) rotate(15deg); opacity: 1; }
    30% { transform: scale(1) rotate(-10deg); opacity: 0.8; }
    50% { opacity: 0; }
  }
  
  /* Metal particles - gear rotation */
  .particles-metal .particle {
    top: 50%;
    animation-name: particleGear;
    color: #9e9e9e;
    filter: drop-shadow(0 0 2px #616161);
  }
  
  @keyframes particleGear {
    0% { transform: rotate(0deg) scale(0.8); opacity: 0.3; }
    50% { transform: rotate(180deg) scale(1); opacity: 0.7; }
    100% { transform: rotate(360deg) scale(0.8); opacity: 0.3; }
  }
  
  /* Light particles - radiate */
  .particles-light .particle {
    top: 50%;
    left: 50%;
    animation-name: particleRadiate;
    color: #fff59d;
    filter: drop-shadow(0 0 5px #ffeb3b);
  }
  
  @keyframes particleRadiate {
    0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
    20% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    100% { transform: translate(calc(-50% + var(--dx, 0px)), calc(-50% + var(--dy, 0px))) scale(0.5); opacity: 0; }
  }
  
  .particles-light .particle:nth-child(1) { --dx: 80px; --dy: 0; }
  .particles-light .particle:nth-child(2) { --dx: -80px; --dy: 0; }
  .particles-light .particle:nth-child(3) { --dx: 0; --dy: 80px; }
  .particles-light .particle:nth-child(4) { --dx: 0; --dy: -80px; }
  .particles-light .particle:nth-child(5) { --dx: 56px; --dy: 56px; }
  .particles-light .particle:nth-child(6) { --dx: -56px; --dy: 56px; }
  .particles-light .particle:nth-child(7) { --dx: 56px; --dy: -56px; }
  .particles-light .particle:nth-child(8) { --dx: -56px; --dy: -56px; }
  
  /* Dragon particles - majestic float */
  .particles-dragon .particle {
    top: 30%;
    animation-name: particleDragon;
    color: #673ab7;
    filter: drop-shadow(0 0 4px #9c27b0);
  }
  
  @keyframes particleDragon {
    0% { transform: translateY(0) scale(0.5); opacity: 0; }
    30% { opacity: 0.8; transform: translateY(-30px) scale(1); }
    70% { opacity: 0.6; transform: translateY(-60px) scale(0.9); }
    100% { transform: translateY(-100px) scale(0.3); opacity: 0; }
  }
  
  /* Neutral particles - subtle */
  .particles-neutral .particle {
    top: 50%;
    animation-name: particleNeutral;
    color: #9e9e9e;
    filter: drop-shadow(0 0 2px #bdbdbd);
  }
  
  @keyframes particleNeutral {
    0%, 100% { transform: translateY(0) scale(0.8); opacity: 0.2; }
    50% { transform: translateY(-20px) scale(1); opacity: 0.5; }
  }
  
  /* ========== ANIMATIONS HOLOGRAPHIQUE - IrisÃ© pastel ========== */
  .effect-holographic .layer-1 {
    background: radial-gradient(
      ellipse 100% 100% at 50% 50%,
      hsla(300, 70%, 70%, 0.2) 0%,
      hsla(180, 70%, 65%, 0.15) 35%,
      hsla(60, 70%, 65%, 0.1) 70%,
      transparent 100%
    );
    animation: holoShift 4s ease-in-out infinite;
    mix-blend-mode: color;
  }
  
  .effect-holographic:hover .layer-1 {
    background: radial-gradient(
      ellipse 100% 100% at 50% 50%,
      hsla(300, 70%, 70%, 0.4) 0%,
      hsla(180, 70%, 65%, 0.3) 35%,
      hsla(60, 70%, 65%, 0.2) 70%,
      transparent 100%
    );
    animation: holoShift 2s ease-in-out infinite;
  }
  
  @keyframes holoShift {
    0%, 100% { transform: translateX(-10%) translateY(-10%); filter: hue-rotate(0deg); }
    50% { transform: translateX(10%) translateY(10%); filter: hue-rotate(30deg); }
  }
  
  /* ========== ANIMATIONS ARC-EN-CIEL - Bandes dÃ©filantes ========== */
  .effect-rainbow .layer-1 {
    background: repeating-linear-gradient(
      90deg,
      rgba(255,0,0,0.25) 0%,
      rgba(255,127,0,0.25) 10%,
      rgba(255,255,0,0.25) 20%,
      rgba(0,255,0,0.25) 30%,
      rgba(0,127,255,0.25) 40%,
      rgba(127,0,255,0.25) 50%,
      rgba(255,0,127,0.25) 60%,
      rgba(255,0,0,0.25) 70%
    );
    background-size: 200% 100%;
    animation: rainbowSlide 3s linear infinite;
    mix-blend-mode: color;
  }
  
  .effect-rainbow:hover .layer-1 {
    background: repeating-linear-gradient(
      90deg,
      rgba(255,0,0,0.45) 0%,
      rgba(255,127,0,0.45) 10%,
      rgba(255,255,0,0.45) 20%,
      rgba(0,255,0,0.45) 30%,
      rgba(0,127,255,0.45) 40%,
      rgba(127,0,255,0.45) 50%,
      rgba(255,0,127,0.45) 60%,
      rgba(255,0,0,0.45) 70%
    );
    background-size: 200% 100%;
    animation: rainbowSlide 1.5s linear infinite;
  }
  
  @keyframes rainbowSlide {
    0% { background-position: 0% 0%; }
    100% { background-position: 200% 0%; }
  }
  
  /* ========== ANIMATIONS PRISMATIQUE - Faisceaux croisÃ©s ========== */
  .effect-prismatic .layer-1 {
    background: 
      linear-gradient(45deg, transparent 20%, rgba(255,0,100,0.2) 40%, rgba(255,200,0,0.25) 50%, rgba(0,255,100,0.2) 60%, transparent 80%),
      linear-gradient(-45deg, transparent 25%, rgba(0,200,255,0.18) 45%, rgba(100,0,255,0.2) 55%, transparent 75%);
    animation: prismaticBeam 5s ease-in-out infinite;
    mix-blend-mode: screen;
  }
  
  .effect-prismatic:hover .layer-1 {
    background: 
      linear-gradient(45deg, transparent 15%, rgba(255,0,100,0.4) 35%, rgba(255,200,0,0.45) 50%, rgba(0,255,100,0.4) 65%, transparent 85%),
      linear-gradient(-45deg, transparent 20%, rgba(0,200,255,0.35) 40%, rgba(100,0,255,0.4) 60%, transparent 80%);
    animation: prismaticBeam 2s ease-in-out infinite;
  }
  
  @keyframes prismaticBeam {
    0%, 100% { background-position: -50% -50%; }
    50% { background-position: 150% 150%; }
  }
  
  /* ========== ANIMATIONS DORÃ‰ - Brillance mÃ©tallique ========== */
  .effect-gold .layer-1 {
    background: 
      radial-gradient(ellipse 80% 60% at 30% 30%, rgba(255,215,0,0.35) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 100%, rgba(180,130,0,0.25) 0%, transparent 40%);
    animation: goldGleam 3s ease-in-out infinite;
    mix-blend-mode: hard-light;
  }
  
  .effect-gold:hover .layer-1 {
    background: 
      radial-gradient(ellipse 90% 70% at 30% 30%, rgba(255,215,0,0.55) 0%, transparent 55%),
      radial-gradient(ellipse at 50% 100%, rgba(180,130,0,0.4) 0%, transparent 45%);
    animation: goldGleam 1.5s ease-in-out infinite;
  }
  
  @keyframes goldGleam {
    0%, 100% { transform: translateX(-15%) translateY(-15%); opacity: 0.8; }
    50% { transform: translateX(15%) translateY(15%); opacity: 1; }
  }
  
  /* ========== ANIMATIONS ARGENTÃ‰ - Chrome brillant ========== */
  .effect-silver .layer-1 {
    background: 
      radial-gradient(ellipse 80% 60% at 30% 30%, rgba(220,230,255,0.4) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 100%, rgba(140,150,170,0.3) 0%, transparent 40%);
    animation: silverGleam 3s ease-in-out infinite;
    mix-blend-mode: hard-light;
  }
  
  .effect-silver:hover .layer-1 {
    background: 
      radial-gradient(ellipse 90% 70% at 30% 30%, rgba(220,230,255,0.6) 0%, transparent 55%),
      radial-gradient(ellipse at 50% 100%, rgba(140,150,170,0.45) 0%, transparent 45%);
    animation: silverGleam 1.5s ease-in-out infinite;
  }
  
  @keyframes silverGleam {
    0%, 100% { transform: translateX(-15%) translateY(-15%); opacity: 0.85; }
    50% { transform: translateX(15%) translateY(15%); opacity: 1; }
  }
  
  /* ========== ANIMATIONS NÃ‰ON - Pulsations colorÃ©es ========== */
  .effect-neon .layer-1 {
    background: 
      radial-gradient(ellipse 70% 50% at 25% 25%, rgba(0,255,255,0.4) 0%, transparent 50%),
      radial-gradient(ellipse 60% 45% at 75% 75%, rgba(255,0,255,0.35) 0%, transparent 45%),
      radial-gradient(ellipse 50% 40% at 50% 50%, rgba(255,255,0,0.25) 0%, transparent 40%);
    animation: neonPulse 2s ease-in-out infinite;
    mix-blend-mode: screen;
  }
  
  .effect-neon:hover .layer-1 {
    background: 
      radial-gradient(ellipse 80% 60% at 25% 25%, rgba(0,255,255,0.65) 0%, transparent 55%),
      radial-gradient(ellipse 70% 55% at 75% 75%, rgba(255,0,255,0.6) 0%, transparent 50%),
      radial-gradient(ellipse 60% 50% at 50% 50%, rgba(255,255,0,0.45) 0%, transparent 45%);
    animation: neonPulse 1s ease-in-out infinite;
  }
  
  @keyframes neonPulse {
    0%, 100% { opacity: 0.7; filter: brightness(1); }
    50% { opacity: 1; filter: brightness(1.2); }
  }
  
  /* ========== ANIMATIONS GALAXIE - Rotation cosmique ========== */
  .effect-galaxy .layer-1 {
    background: 
      radial-gradient(ellipse 60% 45% at 30% 25%, rgba(120,40,200,0.5) 0%, transparent 50%),
      radial-gradient(ellipse 55% 40% at 70% 75%, rgba(60,30,180,0.45) 0%, transparent 45%),
      radial-gradient(circle at 20% 60%, rgba(255,255,255,0.9) 0%, transparent 3%),
      radial-gradient(circle at 80% 30%, rgba(255,255,255,0.85) 0%, transparent 2.5%),
      radial-gradient(circle at 55% 45%, rgba(255,220,255,0.8) 0%, transparent 3%),
      radial-gradient(circle at 35% 80%, rgba(200,200,255,0.75) 0%, transparent 2%),
      radial-gradient(circle at 75% 65%, rgba(255,255,200,0.8) 0%, transparent 2.5%),
      radial-gradient(circle at 15% 35%, rgba(220,255,255,0.7) 0%, transparent 2%);
    animation: galaxyRotate 20s linear infinite;
    mix-blend-mode: screen;
  }
  
  .effect-galaxy:hover .layer-1 {
    animation: galaxyRotate 8s linear infinite;
    filter: brightness(1.3) saturate(1.2);
  }
  
  @keyframes galaxyRotate {
    0% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.02); }
    100% { transform: rotate(360deg) scale(1); }
  }
  
  /* ========== ANIMATIONS FEU - Flammes dynamiques ========== */
  .effect-fire .layer-1 {
    background: 
      linear-gradient(0deg, rgba(255,100,0,0.45) 0%, rgba(255,50,0,0.25) 25%, transparent 55%),
      radial-gradient(ellipse 80% 55% at 50% 85%, rgba(255,180,50,0.55) 0%, transparent 50%),
      radial-gradient(circle at 35% 70%, rgba(255,255,100,0.8) 0%, transparent 10%),
      radial-gradient(circle at 65% 75%, rgba(255,200,50,0.75) 0%, transparent 8%),
      radial-gradient(circle at 50% 60%, rgba(255,150,0,0.7) 0%, transparent 12%),
      radial-gradient(circle at 40% 80%, rgba(255,120,50,0.65) 0%, transparent 7%);
    animation: fireFlicker 0.15s ease-in-out infinite alternate, fireRise 1s ease-in-out infinite;
    mix-blend-mode: screen;
  }
  
  .effect-fire:hover .layer-1 {
    background: 
      linear-gradient(0deg, rgba(255,100,0,0.65) 0%, rgba(255,50,0,0.4) 30%, transparent 60%),
      radial-gradient(ellipse 90% 65% at 50% 85%, rgba(255,180,50,0.75) 0%, transparent 55%),
      radial-gradient(circle at 35% 70%, rgba(255,255,100,1) 0%, transparent 12%),
      radial-gradient(circle at 65% 75%, rgba(255,200,50,0.95) 0%, transparent 10%),
      radial-gradient(circle at 50% 60%, rgba(255,150,0,0.9) 0%, transparent 14%),
      radial-gradient(circle at 40% 80%, rgba(255,120,50,0.85) 0%, transparent 9%);
    animation: fireFlicker 0.08s ease-in-out infinite alternate, fireRise 0.5s ease-in-out infinite;
  }
  
  @keyframes fireFlicker {
    0% { opacity: 0.85; }
    100% { opacity: 1; }
  }
  
  @keyframes fireRise {
    0%, 100% { transform: translateY(0) scaleY(1); }
    50% { transform: translateY(-4px) scaleY(1.03); }
  }
  
  /* ========== ANIMATIONS GLACE - Cristaux scintillants ========== */
  .effect-ice .layer-1 {
    background: 
      linear-gradient(135deg, rgba(180,230,255,0.35) 0%, transparent 35%, rgba(200,240,255,0.3) 65%, transparent 100%),
      linear-gradient(45deg, transparent 40%, rgba(220,250,255,0.25) 50%, transparent 60%),
      radial-gradient(circle at 15% 20%, rgba(255,255,255,0.95) 0%, transparent 5%),
      radial-gradient(circle at 85% 25%, rgba(230,250,255,0.9) 0%, transparent 4%),
      radial-gradient(circle at 20% 75%, rgba(255,255,255,0.85) 0%, transparent 5%),
      radial-gradient(circle at 80% 80%, rgba(220,245,255,0.8) 0%, transparent 4%),
      radial-gradient(circle at 50% 50%, rgba(200,240,255,0.75) 0%, transparent 4%),
      radial-gradient(circle at 35% 40%, rgba(255,255,255,0.8) 0%, transparent 3%);
    animation: iceSparkle 2s ease-in-out infinite;
    mix-blend-mode: hard-light;
  }
  
  .effect-ice:hover .layer-1 {
    background: 
      linear-gradient(135deg, rgba(180,230,255,0.55) 0%, transparent 35%, rgba(200,240,255,0.5) 65%, transparent 100%),
      linear-gradient(45deg, transparent 35%, rgba(220,250,255,0.45) 50%, transparent 65%),
      radial-gradient(circle at 15% 20%, rgba(255,255,255,1) 0%, transparent 6%),
      radial-gradient(circle at 85% 25%, rgba(230,250,255,1) 0%, transparent 5%),
      radial-gradient(circle at 20% 75%, rgba(255,255,255,0.95) 0%, transparent 6%),
      radial-gradient(circle at 80% 80%, rgba(220,245,255,0.9) 0%, transparent 5%),
      radial-gradient(circle at 50% 50%, rgba(200,240,255,0.85) 0%, transparent 5%),
      radial-gradient(circle at 35% 40%, rgba(255,255,255,0.9) 0%, transparent 4%);
    animation: iceSparkle 1s ease-in-out infinite;
    filter: brightness(1.15);
  }
  
  @keyframes iceSparkle {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
  }
  
  .rarity-indicator {
    position: absolute;
    bottom: 12px;
    right: 12px;
    font-size: 14px;
    z-index: 5;
  }
  
  .rarity-indicator.legendary {
    filter: drop-shadow(0 0 4px gold);
  }
  
  .rarity-indicator.mythic {
    filter: drop-shadow(0 0 6px #ff4081);
    animation: pulse 1.5s ease-in-out infinite;
  }
  
  .rarity-indicator.epic {
    filter: drop-shadow(0 0 4px #9C27B0);
  }
  
  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.1); opacity: 0.8; }
  }
  
  .hover-hint {
    text-align: center;
    color: #555;
    font-size: 12px;
    margin-top: 15px;
  }
  
  /* Auto Rotate Button */
  .auto-rotate-btn {
    margin-top: 15px;
    padding: 12px 24px;
    border: 2px solid rgba(100, 150, 255, 0.3);
    border-radius: 25px;
    background: linear-gradient(135deg, rgba(100, 150, 255, 0.1) 0%, rgba(150, 100, 255, 0.1) 100%);
    color: #a0a0c0;
    font-size: 14px;
    font-weight: 600;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .auto-rotate-btn:hover {
    border-color: rgba(100, 150, 255, 0.6);
    background: linear-gradient(135deg, rgba(100, 150, 255, 0.2) 0%, rgba(150, 100, 255, 0.2) 100%);
    color: #fff;
    transform: scale(1.05);
    box-shadow: 0 4px 20px rgba(100, 150, 255, 0.3);
  }
  
  .auto-rotate-btn.active {
    border-color: rgba(100, 255, 150, 0.6);
    background: linear-gradient(135deg, rgba(100, 255, 150, 0.2) 0%, rgba(100, 200, 255, 0.2) 100%);
    color: #7fffaa;
    box-shadow: 0 4px 25px rgba(100, 255, 150, 0.3);
    animation: pulseGlow 2s ease-in-out infinite;
  }
  
  @keyframes pulseGlow {
    0%, 100% { box-shadow: 0 4px 25px rgba(100, 255, 150, 0.3); }
    50% { box-shadow: 0 4px 35px rgba(100, 255, 150, 0.5); }
  }
  
  /* Download Section */
  .download-section {
    margin-top: 20px;
    padding: 15px;
    background: rgba(255,255,255,0.03);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.08);
  }
  
  .download-title {
    text-align: center;
    color: #888;
    font-size: 13px;
    margin-bottom: 12px;
    font-weight: 600;
  }
  
  .download-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .download-btn {
    padding: 10px 16px;
    border: none;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 6px;
    font-family: inherit;
  }
  
  .download-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }
  
  .download-btn:active:not(:disabled) {
    transform: translateY(0);
  }
  
  .download-btn:disabled {
    opacity: 0.6;
    cursor: wait;
  }
  
  .download-png {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
  }
  
  .download-jpg {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
  }
  
  .download-gif {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
  }
  
  .download-html {
    background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
    color: #1a1a2e;
  }

  /* Editor Panel */
  .editor-panel {
    width: 420px;
    max-width: 100%;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .collapsible-section {
    background: rgba(255,255,255,0.03);
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.06);
    overflow: hidden;
  }
  
  .collapsible-header {
    width: 100%;
    padding: 14px 16px;
    background: rgba(255,255,255,0.02);
    border: none;
    color: #fff;
    font-size: 14px;
    font-weight: 600;
    font-family: inherit;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background 0.2s ease;
  }
  
  .collapsible-header:hover {
    background: rgba(255,255,255,0.05);
  }
  
  .collapse-icon {
    font-size: 10px;
    color: #888;
  }
  
  .collapsible-content {
    padding: 16px;
    border-top: 1px solid rgba(255,255,255,0.05);
  }
  
  .section-title {
    color: #fff;
    font-size: 13px;
    font-weight: 600;
  }
  
  .input-group {
    margin-bottom: 12px;
  }
  
  .input-group:last-child {
    margin-bottom: 0;
  }
  
  .input-group label,
  .field-legend {
    display: block;
    color: #a0a0c0;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    font-weight: 600;
  }
  
  .input-group input,
  .input-group select,
  .input-group textarea {
    width: 100%;
    padding: 10px 12px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: #fff;
    font-size: 14px;
    font-family: inherit;
    transition: all 0.2s ease;
  }
  
  .input-group input:focus,
  .input-group select:focus,
  .input-group textarea:focus {
    outline: none;
    border-color: rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.08);
    box-shadow: 0 0 20px rgba(100,150,255,0.1);
  }
  
  .input-group input:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .input-group select option {
    background: #1a1a2e;
  }
  
  /* Color input */
  .color-input-wrapper {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .color-input {
    width: 44px !important;
    height: 38px;
    padding: 2px !important;
    cursor: pointer;
    border-radius: 6px !important;
  }
  
  .color-text-input {
    flex: 1;
  }
  
  /* Checkbox */
  .checkbox-group {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  
  .checkbox-group input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: #ffd700;
  }
  
  .checkbox-group label {
    color: #ccc;
    font-size: 13px;
    cursor: pointer;
  }
  
  /* Image Editor */
  .image-editor {
    margin-bottom: 8px;
  }
  
  .image-editor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .image-actions {
    display: flex;
    gap: 6px;
  }
  
  .small-btn {
    padding: 4px 10px;
    font-size: 11px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 4px;
    color: #ccc;
    cursor: pointer;
    font-family: inherit;
    transition: all 0.2s ease;
  }
  
  .small-btn:hover {
    background: rgba(255,255,255,0.15);
    color: #fff;
  }
  
  .small-btn.danger {
    color: #f48fb1;
  }
  
  .small-btn.danger:hover {
    background: rgba(244,143,177,0.2);
    color: #ff80ab;
  }
  
  .image-preview-container {
    width: 100%;
    aspect-ratio: 16/10;
    border: 2px dashed rgba(255,255,255,0.2);
    border-radius: 10px;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s ease;
    background: rgba(255,255,255,0.02);
  }
  
  .image-preview-container.has-image {
    cursor: grab;
    border-style: solid;
    border-color: rgba(255,255,255,0.1);
  }
  
  .image-preview-container.has-image:active {
    cursor: grabbing;
  }
  
  .image-preview-container:hover,
  .image-preview-container.dragging {
    border-color: rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.04);
  }
  
  .image-preview-container.error {
    border-color: #e53935;
  }
  
  .image-preview {
    width: 100%;
    height: 100%;
    background-repeat: no-repeat;
    position: relative;
  }
  
  .pan-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 12px;
    font-weight: 600;
  }
  
  .upload-placeholder {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }
  
  .upload-icon {
    font-size: 32px;
    margin-bottom: 8px;
  }
  
  .upload-text {
    color: #888;
    font-size: 13px;
    margin-bottom: 4px;
  }
  
  .upload-hint {
    color: #555;
    font-size: 11px;
  }
  
  .image-controls {
    margin-top: 12px;
  }
  
  .zoom-control {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  
  .zoom-control label {
    color: #999;
    font-size: 11px;
  }
  
  .zoom-control input[type="range"] {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(255,255,255,0.1);
    appearance: none;
    cursor: pointer;
  }
  
  .zoom-control input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #ffd700;
    cursor: pointer;
    box-shadow: 0 0 6px rgba(255,215,0,0.5);
  }
  
  .image-hint {
    color: #666;
    font-size: 10px;
    text-align: center;
    margin-top: 8px;
  }
  
  /* Grid layouts */
  .grid-2 {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }
  
  .grid-3 {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 10px;
  }
  
  /* Rarity Selector */
  .rarity-fieldset,
  .effect-fieldset {
    border: none;
    padding: 0;
    margin: 0;
  }
  
  .rarity-selector {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
  }
  
  .rarity-btn {
    padding: 8px 6px;
    border: 1px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.03);
    border-radius: 6px;
    color: #888;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 10px;
    font-family: inherit;
    text-align: center;
    min-height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    word-break: break-word;
    line-height: 1.2;
  }
  
  .rarity-btn.active {
    border-color: var(--rarity-color, #ffd700);
    background: rgba(255,215,0,0.1);
    color: var(--rarity-color, #ffd700);
  }
  
  .rarity-btn:hover:not(.active) {
    background: rgba(255,255,255,0.08);
    color: #bbb;
  }
  
  /* Effect Selector */
  .effect-selector {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 6px;
  }
  
  .effect-btn {
    padding: 6px 3px;
    border: 1px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.03);
    border-radius: 6px;
    color: #888;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 8px;
    font-family: inherit;
    text-align: center;
    min-height: 40px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    word-break: break-word;
    line-height: 1.2;
  }
  
  .effect-btn.active {
    border-color: #4FC3F7;
    background: rgba(79,195,247,0.15);
    color: #4FC3F7;
  }
  
  .effect-btn:hover:not(.active) {
    background: rgba(255,255,255,0.08);
    color: #bbb;
  }
  
  /* Attack Editor */
  .attack-editor {
    background: rgba(255,255,255,0.02);
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 10px;
    border: 1px solid rgba(255,255,255,0.04);
  }
  
  .attack-editor:last-of-type {
    margin-bottom: 0;
  }
  
  .attack-header-edit {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  
  .attack-title {
    color: #a0a0c0;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 600;
    margin: 0;
  }
  
  .remove-attack-btn {
    width: 22px;
    height: 22px;
    border: none;
    background: rgba(244,67,54,0.2);
    color: #f44336;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }
  
  .remove-attack-btn:hover {
    background: rgba(244,67,54,0.3);
  }
  
  .attack-grid {
    display: grid;
    grid-template-columns: 2fr 1fr 1fr;
    gap: 10px;
  }
  
  .add-attack-btn {
    width: 100%;
    padding: 10px;
    border: 2px dashed rgba(255,255,255,0.15);
    background: transparent;
    color: #888;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    font-family: inherit;
    transition: all 0.2s ease;
    margin-top: 10px;
  }
  
  .add-attack-btn:hover {
    border-color: rgba(255,255,255,0.3);
    color: #ccc;
    background: rgba(255,255,255,0.02);
  }
  
  .add-attack-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
  
  /* Responsive */
  @media (max-width: 900px) {
    .main-layout {
      flex-direction: column;
      align-items: center;
    }
    
    .card-preview {
      position: static;
    }
    
    .editor-panel {
      width: 100%;
      max-width: 420px;
    }
    
    .title {
      font-size: 36px;
    }
    
    .effect-selector {
      grid-template-columns: repeat(4, 1fr);
    }
  }
  
  @media (max-width: 500px) {
    .grid-3 {
      grid-template-columns: 1fr 1fr;
    }
    
    .attack-grid {
      grid-template-columns: 1fr 1fr;
    }
    
    .attack-grid > *:first-child {
      grid-column: 1 / -1;
    }
    
    .rarity-selector {
      grid-template-columns: repeat(2, 1fr);
    }
    
    .effect-selector {
      grid-template-columns: repeat(3, 1fr);
    }
    
    .title {
      font-size: 28px;
    }
  }
`;

// ============================================
// COMPOSANT PRINCIPAL
// ============================================
// Composant interne avec accÃ¨s au contexte de langue
function CardCreatorContent() {
  const { t, lang } = useLanguage();
  const [cardData, setCardData] = useState(INITIAL_CARD_DATA);
  const [attacks, setAttacks] = useState(INITIAL_ATTACKS);
  const [image, setImage] = useState(null);
  const [imageSettings, setImageSettings] = useState(INITIAL_IMAGE_SETTINGS);
  const [imageLoading, setImageLoading] = useState(false);
  const [imageError, setImageError] = useState(null);
  const [mousePos, setMousePos] = useState({ x: 0.5, y: 0.5 });
  const [isHovering, setIsHovering] = useState(false);
  const [autoRotate, setAutoRotate] = useState(true);
  const cardRef = useRef(null);
  const autoRotateRef = useRef(null);

  // Animation automatique 3D
  useEffect(() => {
    if (autoRotate) {
      let angle = 0;
      setIsHovering(true); // Active l'effet 3D
      autoRotateRef.current = setInterval(() => {
        angle += 0.02; // Mouvement plus lent et fluide
        // Mouvement en forme de 8 / lemniscate pour un effet fluide
        const x = 0.5 + Math.sin(angle) * 0.35;
        const y = 0.5 + Math.sin(angle * 2) * 0.25;
        setMousePos({ x, y });
      }, 40);
    } else {
      if (autoRotateRef.current) {
        clearInterval(autoRotateRef.current);
        autoRotateRef.current = null;
      }
      setIsHovering(false);
      setMousePos({ x: 0.5, y: 0.5 });
    }
    
    return () => {
      if (autoRotateRef.current) {
        clearInterval(autoRotateRef.current);
      }
    };
  }, [autoRotate]);

  // ArrÃªter l'auto-rotation quand l'utilisateur survole manuellement
  const handleMouseEnterManual = useCallback(() => {
    if (autoRotate && autoRotateRef.current) {
      clearInterval(autoRotateRef.current);
      autoRotateRef.current = null;
    }
    setIsHovering(true);
  }, [autoRotate]);

  const handleMouseLeaveManual = useCallback(() => {
    if (autoRotate) {
      // RedÃ©marrer l'animation automatique
      let angle = 0;
      autoRotateRef.current = setInterval(() => {
        angle += 0.02;
        const x = 0.5 + Math.sin(angle) * 0.35;
        const y = 0.5 + Math.sin(angle * 2) * 0.25;
        setMousePos({ x, y });
      }, 40);
      setIsHovering(true); // Garder l'effet 3D actif
    } else {
      setIsHovering(false);
      setMousePos({ x: 0.5, y: 0.5 });
    }
  }, [autoRotate]);

  // Handlers mÃ©morisÃ©s
  const updateCardData = useCallback((field, value) => {
    setCardData(prev => ({ ...prev, [field]: value }));
  }, []);

  const updateCardDataNumeric = useCallback((field, value, min, max) => {
    const parsed = parseIntSafe(value, min);
    setCardData(prev => ({ ...prev, [field]: clamp(parsed, min, max) }));
  }, []);

  const updateAttack = useCallback((index, newAttack) => {
    setAttacks(prev => prev.map((a, i) => i === index ? newAttack : a));
  }, []);

  const addAttack = useCallback(() => {
    if (attacks.length >= 4) return;
    setAttacks(prev => [...prev, {
      id: generateId(),
      name: t.defaults.newAbility,
      damage: 50,
      cost: 2,
      desc: '',
    }]);
  }, [attacks.length, t]);

  const removeAttack = useCallback((index) => {
    if (attacks.length <= 1) return;
    setAttacks(prev => prev.filter((_, i) => i !== index));
  }, [attacks.length]);

  const processImageFile = useCallback((file) => {
    if (!file) return;

    const validTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      setImageError(t.imageEditor.unsupportedFormat);
      return;
    }

    if (file.size > CARD_LIMITS.MAX_FILE_SIZE) {
      setImageError(t.imageEditor.fileTooLarge);
      return;
    }

    setImageLoading(true);
    setImageError(null);

    const reader = new FileReader();
    
    reader.onload = (e) => {
      setImage(e.target.result);
      setImageSettings(INITIAL_IMAGE_SETTINGS);
      setImageLoading(false);
    };
    
    reader.onerror = () => {
      setImageError('Error');
      setImageLoading(false);
    };
    
    reader.readAsDataURL(file);
  }, [t]);

  const clearImage = useCallback(() => {
    setImage(null);
    setImageSettings(INITIAL_IMAGE_SETTINGS);
    setImageError(null);
  }, []);

  // Throttle le mousemove
  const handleMouseMoveThrottled = useCallback((e) => {
    if (!cardRef.current) return;
    const rect = cardRef.current.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;
    setMousePos({ x: clamp(x, 0, 1), y: clamp(y, 0, 1) });
  }, []);

  const handleMouseMove = useThrottle(handleMouseMoveThrottled, 16);

  // Options pour les selects - avec traductions
  const typeOptions = useMemo(() => 
    ELEMENT_KEYS.map(type => ({
      value: type,
      label: `${ELEMENT_TYPES[type].icon} ${t.elements[type] || type}`
    })),
  [t]);

  const stageOptions = useMemo(() => 
    STAGES.map((stage, index) => ({ 
      value: stage, 
      label: t.stages[index] || stage 
    })),
  [t]);

  const fontOptions = useMemo(() => 
    FONTS.map(font => ({ value: font.id, label: font.name })),
  []);

  const typeIcon = ELEMENT_TYPES[cardData.type]?.icon || 'â­';

  return (
    <div className="app-container">
      <style>{STYLES}</style>

      <h1 className="title">âœ¨ {t.appTitle} âœ¨</h1>
      <p className="subtitle">{t.appSubtitle}</p>
      
      <div className="main-layout">
        {/* Card Preview */}
        <div className="card-preview">
          <Card
            cardData={cardData}
            attacks={attacks}
            image={image}
            imageSettings={imageSettings}
            mousePos={mousePos}
            isHovering={isHovering}
            cardRef={cardRef}
            onMouseMove={handleMouseMove}
            onMouseEnter={handleMouseEnterManual}
            onMouseLeave={handleMouseLeaveManual}
            autoRotate={autoRotate}
            t={t}
          />
          <p className="hover-hint">{t.hoverHint}</p>
          
          {/* Auto Rotate Button */}
          <button
            className={`auto-rotate-btn ${autoRotate ? 'active' : ''}`}
            onClick={() => setAutoRotate(!autoRotate)}
          >
            {autoRotate ? 'â¸ï¸' : 'â–¶ï¸'} {t.buttons.autoRotate}
          </button>
          
          {/* Download Section */}
          <div className="download-section">
            <p className="download-title">{t.download.title}</p>
            <div className="download-buttons">
              <button 
                className="download-btn download-png"
                onClick={() => downloadAsPNG(cardRef.current, cardData.name || 'card')}
                title={t.download.pngTitle}
              >
                ðŸ–¼ï¸ PNG
              </button>
              <button 
                className="download-btn download-jpg"
                onClick={() => downloadAsJPG(cardRef.current, cardData.name || 'card')}
                title={t.download.jpgTitle}
              >
                ðŸ“· JPG
              </button>
              <button 
                className="download-btn download-gif"
                onClick={async () => {
                  const btn = document.querySelector('.download-gif');
                  btn.textContent = t.download.capturing;
                  btn.disabled = true;
                  await downloadAsVideo(cardRef.current, cardData.name || 'card', 4000);
                  btn.textContent = 'ðŸŽ¬ Video';
                  btn.disabled = false;
                }}
                title={t.download.gifTitle}
              >
                ðŸŽ¬ Video
              </button>
              <button 
                className="download-btn download-html"
                onClick={() => downloadAsHTML(cardData, attacks, image, imageSettings)}
                title={t.download.htmlTitle}
              >
                ðŸŒ HTML
              </button>
            </div>
          </div>
        </div>

        {/* Editor Panel */}
        <div className="editor-panel">
          {/* Image Section */}
          <CollapsibleSection title={t.sections.image} icon="ðŸ“·" defaultOpen={true}>
            <ImageEditor
              image={image}
              settings={imageSettings}
              onSettingsChange={setImageSettings}
              isLoading={imageLoading}
              error={imageError}
              onUpload={processImageFile}
              onClear={clearImage}
              t={t}
            />
          </CollapsibleSection>

          {/* Basic Info */}
          <CollapsibleSection title={t.sections.basicInfo} icon="ðŸ“" defaultOpen={true}>
            <div className="grid-2">
              <InputGroup
                id="creature-name"
                label={t.labels.name}
                value={cardData.name}
                onChange={(v) => updateCardData('name', v)}
                maxLength={CARD_LIMITS.NAME_MAX_LENGTH}
              />
              <InputGroup
                id="creature-hp"
                label={t.labels.hp}
                type="number"
                value={cardData.hp}
                onChange={(v) => updateCardDataNumeric('hp', v, CARD_LIMITS.HP_MIN, CARD_LIMITS.HP_MAX)}
                min={CARD_LIMITS.HP_MIN}
                max={CARD_LIMITS.HP_MAX}
              />
            </div>

            <div className="grid-2">
              <InputGroup
                id="creature-type"
                label={t.labels.element}
                value={cardData.type}
                onChange={(v) => updateCardData('type', v)}
                options={typeOptions}
              />
              <InputGroup
                id="creature-stage"
                label={t.labels.stage}
                value={cardData.stage}
                onChange={(v) => updateCardData('stage', v)}
                options={stageOptions}
              />
            </div>

            <InputGroup
              id="creature-description"
              label={t.labels.description}
              value={cardData.description}
              onChange={(v) => updateCardData('description', v)}
              rows={2}
              maxLength={CARD_LIMITS.DESC_MAX_LENGTH}
            />

            <InputGroup
              id="creature-author"
              label={t.labels.author}
              value={cardData.author}
              onChange={(v) => updateCardData('author', v)}
              maxLength={CARD_LIMITS.AUTHOR_MAX_LENGTH}
            />
          </CollapsibleSection>

          {/* Rarity & Effects */}
          <CollapsibleSection title={t.sections.rarityEffects} icon="âœ¨" defaultOpen={true}>
            <RaritySelector
              value={cardData.rarity}
              onChange={(v) => updateCardData('rarity', v)}
              t={t}
            />
            <div style={{ marginTop: '12px' }}>
              <EffectSelector
                value={cardData.effect}
                onChange={(v) => updateCardData('effect', v)}
                t={t}
              />
            </div>
          </CollapsibleSection>

          {/* Attacks */}
          <CollapsibleSection title={t.sections.abilities} icon="âš”ï¸" defaultOpen={true}>
            {attacks.map((attack, idx) => (
              <AttackEditor
                key={attack.id}
                index={idx}
                attack={attack}
                typeIcon={typeIcon}
                onUpdate={updateAttack}
                onRemove={removeAttack}
                canRemove={attacks.length > 1}
                t={t}
              />
            ))}
            <button 
              type="button"
              className="add-attack-btn"
              onClick={addAttack}
              disabled={attacks.length >= 4}
            >
              {t.buttons.addAbility} {attacks.length >= 4 && '(max 4)'}
            </button>
          </CollapsibleSection>

          {/* Stats */}
          <CollapsibleSection title={t.sections.stats} icon="ðŸ“Š" defaultOpen={false}>
            <div className="grid-3">
              <InputGroup
                id="creature-weakness"
                label={t.labels.weakness}
                value={cardData.weakness}
                onChange={(v) => updateCardData('weakness', v)}
                options={typeOptions}
              />
              <InputGroup
                id="creature-resistance"
                label={t.labels.resistance}
                value={cardData.resistance}
                onChange={(v) => updateCardData('resistance', v)}
                options={typeOptions}
              />
              <InputGroup
                id="creature-retreat"
                label={t.labels.retreatCost}
                type="number"
                value={cardData.retreatCost}
                onChange={(v) => updateCardDataNumeric('retreatCost', v, CARD_LIMITS.RETREAT_MIN, CARD_LIMITS.RETREAT_MAX)}
                min={CARD_LIMITS.RETREAT_MIN}
                max={CARD_LIMITS.RETREAT_MAX}
              />
            </div>
          </CollapsibleSection>

          {/* Appearance */}
          <CollapsibleSection title={t.sections.appearance} icon="ðŸŽ¨" defaultOpen={false}>
            <InputGroup
              id="card-font"
              label={t.labels.font}
              value={cardData.font}
              onChange={(v) => updateCardData('font', v)}
              options={fontOptions}
            />
            
            <InputGroup
              id="card-border-color"
              label={t.labels.borderColor}
              type="color"
              value={cardData.borderColor || '#ffd700'}
              onChange={(v) => updateCardData('borderColor', v)}
            />

            <InputGroup
              id="card-bg-color"
              label={t.labels.backgroundColor}
              type="color"
              value={cardData.backgroundColor || '#ff6b35'}
              onChange={(v) => updateCardData('backgroundColor', v)}
            />

            <InputGroup
              id="card-text-color"
              label={t.labels.textColor}
              type="color"
              value={cardData.textColor || '#1a1a2e'}
              onChange={(v) => updateCardData('textColor', v)}
            />

            <div style={{ marginTop: '16px' }}>
              <Checkbox
                id="show-hp"
                label={t.checkboxes.showHP}
                checked={cardData.showHP}
                onChange={(v) => updateCardData('showHP', v)}
              />
              <Checkbox
                id="show-weak-res"
                label={t.checkboxes.showWeakRes}
                checked={cardData.showWeakRes}
                onChange={(v) => updateCardData('showWeakRes', v)}
              />
              <Checkbox
                id="show-retreat"
                label={t.checkboxes.showRetreat}
                checked={cardData.showRetreat}
                onChange={(v) => updateCardData('showRetreat', v)}
              />
              <Checkbox
                id="show-description"
                label={t.checkboxes.showDescription}
                checked={cardData.showDescription}
                onChange={(v) => updateCardData('showDescription', v)}
              />
              <Checkbox
                id="show-texture"
                label={t.checkboxes.showTexture}
                checked={cardData.showTexture}
                onChange={(v) => updateCardData('showTexture', v)}
              />
              <Checkbox
                id="show-particles"
                label={t.checkboxes.showParticles}
                checked={cardData.showParticles}
                onChange={(v) => updateCardData('showParticles', v)}
              />
            </div>
          </CollapsibleSection>
        </div>
      </div>
    </div>
  );
}

// Composant principal avec Language Provider
function CardCreator() {
  const [lang, setLang] = useState('en');
  const t = TRANSLATIONS[lang];
  
  return (
    <LanguageContext.Provider value={{ lang, setLang, t }}>
      <div className="language-dropdown">
        <select 
          value={lang} 
          onChange={(e) => setLang(e.target.value)}
          className="lang-select"
        >
          {Object.entries(LANGUAGES).map(([code, { name, flag }]) => (
            <option key={code} value={code}>
              {flag} {name}
            </option>
          ))}
        </select>
      </div>
      <CardCreatorContent />
    </LanguageContext.Provider>
  );
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<CardCreator />);
  </script>
</body>
</html>
